---
title: マイクロサービスの CI/CD
description: マイクロサービスの継続的インテグレーションと継続的デリバリー。
author: MikeWasson
ms.date: 03/27/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: c52ff3d0a330f564e5f7e9b0b07f0ba84c328c8b
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2019
ms.locfileid: "59639786"
---
# <a name="cicd-for-microservices-architectures"></a><span data-ttu-id="a77a2-103">マイクロサービス アーキテクチャの CI/CD</span><span class="sxs-lookup"><span data-stu-id="a77a2-103">CI/CD for microservices architectures</span></span>

<span data-ttu-id="a77a2-104">マイクロサービス アーキテクチャを主な利点の 1 つは、リリース サイクルの高速化です。</span><span class="sxs-lookup"><span data-stu-id="a77a2-104">Faster release cycles are one of the major advantages of microservices architectures.</span></span> <span data-ttu-id="a77a2-105">しかし、優れた CI/CD プロセスなしでは、マイクロサービスが約束するアジリティは達成できません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-105">But without a good CI/CD process, you won't achieve the agility that microservices promise.</span></span> <span data-ttu-id="a77a2-106">この記事では、これらの課題について説明し、問題に対処するために推奨するいくつかの方法を示します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-106">This article describes the challenges and recommends some approaches to the problem.</span></span>

## <a name="what-is-cicd"></a><span data-ttu-id="a77a2-107">CI/CD とは</span><span class="sxs-lookup"><span data-stu-id="a77a2-107">What is CI/CD?</span></span>

<span data-ttu-id="a77a2-108">CI/CD の話は、実際には、継続的インテグレーション、継続的デリバリー、および継続的デプロイという関連する複数のプロセスについての話です。</span><span class="sxs-lookup"><span data-stu-id="a77a2-108">When we talk about CI/CD, we're really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="a77a2-109">**継続的インテグレーション**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-109">**Continuous integration**.</span></span> <span data-ttu-id="a77a2-110">コード変更は、メイン ブランチに頻繁にマージされます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-110">Code changes are frequently merged into the main branch.</span></span> <span data-ttu-id="a77a2-111">自動化されたビルドとテストのプロセスによって、確実にメイン ブランチのコードが、常に運用環境の品質であるようにします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-111">Automated build and test processes ensure that code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="a77a2-112">**継続的デリバリー**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-112">**Continuous delivery**.</span></span> <span data-ttu-id="a77a2-113">CI プロセスに合格したコード変更は、運用環境に似た環境に自動的に公開されます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-113">Any code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="a77a2-114">運用環境へのデプロイには手動による承認が必要な場合がありますが、それ以外の場合は自動化されます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-114">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="a77a2-115">目標は、コードが常に運用環境にデプロイされる "*準備ができている*" ことです。</span><span class="sxs-lookup"><span data-stu-id="a77a2-115">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="a77a2-116">**継続的なデプロイ:** </span><span class="sxs-lookup"><span data-stu-id="a77a2-116">**Continuous deployment**.</span></span> <span data-ttu-id="a77a2-117">前の 2 つの手順に合格したコード変更は、自動的に*運用環境に*デプロイされます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-117">Code changes that pass the previous two steps are automatically deployed *into production*.</span></span>

<span data-ttu-id="a77a2-118">マイクロサービス アーキテクチャのための堅牢な CI/CD プロセスの目標のいくつかを次に示します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-118">Here are some goals of a robust CI/CD process for a microservices architecture:</span></span>

- <span data-ttu-id="a77a2-119">各チームは、他のチームに影響を与えたり妨害したりすることなく、独立に所有するサービスを構築およびデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-119">Each team can build and deploy the services that it owns independently, without affecting or disrupting other teams.</span></span>

- <span data-ttu-id="a77a2-120">サービスの新しいバージョンは、運用環境にデプロイされる前に、検証のために開発/テスト/QA 環境にデプロイされます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-120">Before a new version of a service is deployed to production, it gets deployed to dev/test/QA environments for validation.</span></span> <span data-ttu-id="a77a2-121">品質ゲートは、各段階で適用されます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-121">Quality gates are enforced at each stage.</span></span>

- <span data-ttu-id="a77a2-122">サービスの新しいバージョンは、以前のバージョンと並行してデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-122">A new version of a service can be deployed side by side with the previous version.</span></span>

- <span data-ttu-id="a77a2-123">十分なアクセス制御ポリシーが設定されています。</span><span class="sxs-lookup"><span data-stu-id="a77a2-123">Sufficient access control policies are in place.</span></span>

- <span data-ttu-id="a77a2-124">コンテナー化されたワークロードの場合、運用環境にデプロイされているコンテナー イメージを信頼できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-124">For containerized workloads, you can trust the container images that are deployed to production.</span></span>

## <a name="why-a-robust-cicd-pipeline-matters"></a><span data-ttu-id="a77a2-125">堅牢な CI/CD パイプラインが必要な理由</span><span class="sxs-lookup"><span data-stu-id="a77a2-125">Why a robust CI/CD pipeline matters</span></span>

<span data-ttu-id="a77a2-126">従来のモノリシック アプリケーションには、その出力がアプリケーション実行可能ファイルである単一のビルド パイプラインがあります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-126">In a traditional monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="a77a2-127">すべての開発作業は、このパイプラインに注ぎ込まれます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-127">All development work feeds into this pipeline.</span></span> <span data-ttu-id="a77a2-128">優先度の高いバグが見つかった場合、修正を統合し、テストして発行する必要がありますが、それによって新機能のリリースが遅れる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-128">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="a77a2-129">これらの問題は、十分にファクタリングされたモジュールを用意し、機能ブランチを使用してコード変更の影響を最小限に抑えることで軽減できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-129">You can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="a77a2-130">ただし、アプリケーションが複雑になり、機能が追加されるにつれて、モノリシックのリリース プロセスは不安定になり、中断される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-130">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span>

<span data-ttu-id="a77a2-131">マイクロサービスの理念に従うと、すべてのチームは、リリースするために一列に並んで待つ必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-131">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="a77a2-132">サービス "A" をビルドしているチームは、サービス "B" の変更がマージされ、テストされ、デプロイされるまで待たずに、更新プログラムをいつでもリリースできます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-132">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span>

![CI/CD モノリスの図](./images/cicd-monolith.png)

<span data-ttu-id="a77a2-134">高速なリリースを実現するには、リリース パイプラインを自動化して、信頼性を高くし、リスクを最小限に抑える必要があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-134">To achieve a high release velocity, your release pipeline must be automated and highly reliable, to minimize risk.</span></span> <span data-ttu-id="a77a2-135">毎日または 1 日に数回、運用環境にリリースを行うと、エラーの再発やサービスの中断はめったに発生しないはずです。</span><span class="sxs-lookup"><span data-stu-id="a77a2-135">If you release to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="a77a2-136">同時に、不適切な更新プログラムがデプロイされた場合は、信頼性の高い方法で、サービスの前のバージョンに迅速にロールバックするかロールフォワードする必要があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-136">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

## <a name="challenges"></a><span data-ttu-id="a77a2-137">課題</span><span class="sxs-lookup"><span data-stu-id="a77a2-137">Challenges</span></span>

- <span data-ttu-id="a77a2-138">**多数の小さな独立したコード ベース**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-138">**Many small independent code bases**.</span></span> <span data-ttu-id="a77a2-139">各チームは、独自のビルド パイプラインを使用して独自のサービスをビルドします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-139">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="a77a2-140">組織によっては、チームは別々のコード リポジトリを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-140">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="a77a2-141">別々のリポジトリでは、システムをビルドするための知識がチームをまたがって分散し、アプリケーション全体をデプロイする方法を知っている人物が組織内に存在しないという状況に陥る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-141">Separate repositories can lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="a77a2-142">たとえば、ディザスター リカバリー シナリオで、すぐに新しいクラスターへのデプロイが必要になったら、どうしたらよいのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="a77a2-142">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>

    <span data-ttu-id="a77a2-143">**対応策**:この知識が各チーム内に "隠れて" しまわないように、統合パイプラインや自動パイプラインを用いてサービスをビルドし、デプロイします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-143">**Mitigation**: Have a unified and automated pipeline to build and deploy services, so that this knowledge is not "hidden" within each team.</span></span>

- <span data-ttu-id="a77a2-144">**複数の言語とフレームワーク**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-144">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="a77a2-145">各チームはテクノロジーを独自に組み合わせて使用するため、組織全体で動作する単一のビルド プロセスを作成するのは困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-145">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="a77a2-146">ビルド プロセスは、すべてのチームが言語やフレームワークを選択できる柔軟性を備えている必要があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-146">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span>

    <span data-ttu-id="a77a2-147">**対応策**:サービスごとにビルド プロセスをコンテナー化します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-147">**Mitigation**: Containerize the build process for each service.</span></span> <span data-ttu-id="a77a2-148">そうすれば、ビルド システムではコンテナーを実行できる必要があるだけです。</span><span class="sxs-lookup"><span data-stu-id="a77a2-148">That way, the build system just needs to be able to run the containers.</span></span>

- <span data-ttu-id="a77a2-149">**統合とロード テスト**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-149">**Integration and load testing**.</span></span> <span data-ttu-id="a77a2-150">チームは独自のペースで更新プログラムをリリースするため、堅牢なエンド ツー エンド テストを設計するのは困難である可能性があります。これは特にサービスに他のサービスとの依存関係がある場合にそうなります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-150">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="a77a2-151">さらに、運用クラスター全体の実行は負荷がかかる可能性があるため、すべてのチームが独自のクラスター全体をテスト目的でのみ運用環境規模で実行することはほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-151">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will run its own full cluster at production scales, just for testing.</span></span>

- <span data-ttu-id="a77a2-152">**リリース管理**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-152">**Release management**.</span></span> <span data-ttu-id="a77a2-153">すべてのチームが、更新プログラムを運用環境にデプロイできる必要があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-153">Every team should be able to deploy an update to production.</span></span> <span data-ttu-id="a77a2-154">これは、すべてのチーム メンバーがこれを行う権限を持っているという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-154">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="a77a2-155">ただし、一元的なリリース マネージャー ロールを使用すると、デプロイの速度が遅くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-155">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span>

    <span data-ttu-id="a77a2-156">**対応策**:CI/CD プロセスが自動化され、信頼性が高くなるにつれて、一元的な権限は必要なくなっていきます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-156">**Mitigation**: The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="a77a2-157">ただし、主要な機能の更新プログラムのリリースと小さなバグ修正に対して、異なるポリシーを設定できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-157">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="a77a2-158">分散型は、ゼロ ガバナンスという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-158">Being decentralized doesn't mean zero governance.</span></span>

- <span data-ttu-id="a77a2-159">**サービスの更新**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-159">**Service updates**.</span></span> <span data-ttu-id="a77a2-160">サービスを新しいバージョンに更新するときは、それに依存するその他のサービスの中断が発生してはなりません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-160">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span>

    <span data-ttu-id="a77a2-161">**対応策**:非破壊的変更の場合は、ブルー グリーンまたはカナリア リリースなどのデプロイ技術を使用します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-161">**Mitigation**: Use deployment techniques such as blue-green or canary release for non-breaking changes.</span></span> <span data-ttu-id="a77a2-162">API の破壊的変更の場合は、新しいバージョンを以前のバージョンと並行してデプロイします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-162">For breaking API changes, deploy the new version side by side with the previous version.</span></span> <span data-ttu-id="a77a2-163">そうすれば、以前の API を使用するサービスを、新しい API に対して更新してテストすることができます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-163">That way, services that consume the previous API can be updated and tested for the new API.</span></span> <span data-ttu-id="a77a2-164">後述の「[サービスの更新](#updating-services)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="a77a2-164">See [Updating services](#updating-services), below.</span></span>

## <a name="monorepo-vs-multi-repo"></a><span data-ttu-id="a77a2-165">単一のリポジトリと複数のリポジトリの対比</span><span class="sxs-lookup"><span data-stu-id="a77a2-165">Monorepo vs multi-repo</span></span>

<span data-ttu-id="a77a2-166">CI/CD ワークフローを作成する前に、コード ベースがどのように構造化され、管理されるかを理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-166">Before creating a CI/CD workflow, you must know how the code base will be structured and managed.</span></span>

- <span data-ttu-id="a77a2-167">チームは、別個のリポジトリで作業するのか、単一のリポジトリで作業するのか。</span><span class="sxs-lookup"><span data-stu-id="a77a2-167">Do teams work in separate repositories or in a monorepo (single repository)?</span></span>
- <span data-ttu-id="a77a2-168">使用するブランチ戦略は何か。</span><span class="sxs-lookup"><span data-stu-id="a77a2-168">What is your branching strategy?</span></span>
- <span data-ttu-id="a77a2-169">運用環境にコードをプッシュできるのは誰か。</span><span class="sxs-lookup"><span data-stu-id="a77a2-169">Who can push code to production?</span></span> <span data-ttu-id="a77a2-170">リリース マネージャー ロールは存在するのか。</span><span class="sxs-lookup"><span data-stu-id="a77a2-170">Is there a release manager role?</span></span>

<span data-ttu-id="a77a2-171">単一リポジトリ アプローチのほうが支持されていますが、どちらにも長所と短所があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-171">The monorepo approach has been gaining favor but there are advantages and disadvantages to both.</span></span>

| &nbsp; | <span data-ttu-id="a77a2-172">単一のリポジトリ</span><span class="sxs-lookup"><span data-stu-id="a77a2-172">Monorepo</span></span> | <span data-ttu-id="a77a2-173">複数のリポジトリ</span><span class="sxs-lookup"><span data-stu-id="a77a2-173">Multiple repos</span></span> |
|--------|----------|----------------|
| <span data-ttu-id="a77a2-174">**長所**</span><span class="sxs-lookup"><span data-stu-id="a77a2-174">**Advantages**</span></span> | <span data-ttu-id="a77a2-175">コードの共有</span><span class="sxs-lookup"><span data-stu-id="a77a2-175">Code sharing</span></span><br/><span data-ttu-id="a77a2-176">コードとツールの標準化が容易</span><span class="sxs-lookup"><span data-stu-id="a77a2-176">Easier to standardize code and tooling</span></span><br/><span data-ttu-id="a77a2-177">コードのリファクタリングが容易</span><span class="sxs-lookup"><span data-stu-id="a77a2-177">Easier to refactor code</span></span><br/><span data-ttu-id="a77a2-178">探しやすさ - コードの単一のビュー</span><span class="sxs-lookup"><span data-stu-id="a77a2-178">Discoverability - single view of the code</span></span><br/> | <span data-ttu-id="a77a2-179">各チームの所有権が明確</span><span class="sxs-lookup"><span data-stu-id="a77a2-179">Clear ownership per team</span></span><br/><span data-ttu-id="a77a2-180">マージ競合の可能性が少ない</span><span class="sxs-lookup"><span data-stu-id="a77a2-180">Potentially fewer merge conflicts</span></span><br/><span data-ttu-id="a77a2-181">マイクロサービスを強制的に分離するのに役立つ</span><span class="sxs-lookup"><span data-stu-id="a77a2-181">Helps to enforce decoupling of microservices</span></span> |
| <span data-ttu-id="a77a2-182">**課題**</span><span class="sxs-lookup"><span data-stu-id="a77a2-182">**Challenges**</span></span> | <span data-ttu-id="a77a2-183">共有コードの変更が複数のマイクロサービスに影響する可能性がある</span><span class="sxs-lookup"><span data-stu-id="a77a2-183">Changes to shared code can affect multiple microservices</span></span><br/><span data-ttu-id="a77a2-184">マージ競合の可能性が大きい</span><span class="sxs-lookup"><span data-stu-id="a77a2-184">Greater potential for merge conflicts</span></span><br/><span data-ttu-id="a77a2-185">大規模なコード ベースに合うようにツールを拡張する必要がある</span><span class="sxs-lookup"><span data-stu-id="a77a2-185">Tooling must scale to a large code base</span></span><br/><span data-ttu-id="a77a2-186">アクセス制御</span><span class="sxs-lookup"><span data-stu-id="a77a2-186">Access control</span></span><br/><span data-ttu-id="a77a2-187">複雑なデプロイ プロセス</span><span class="sxs-lookup"><span data-stu-id="a77a2-187">More complex deployment process</span></span> | <span data-ttu-id="a77a2-188">コードの共有が難しい</span><span class="sxs-lookup"><span data-stu-id="a77a2-188">Harder to share code</span></span><br/><span data-ttu-id="a77a2-189">コーディング規約の適用が難しい</span><span class="sxs-lookup"><span data-stu-id="a77a2-189">Harder to enforce coding standards</span></span><br/><span data-ttu-id="a77a2-190">依存関係の管理</span><span class="sxs-lookup"><span data-stu-id="a77a2-190">Dependency management</span></span><br/><span data-ttu-id="a77a2-191">コード ベースが拡散して探しにくい</span><span class="sxs-lookup"><span data-stu-id="a77a2-191">Diffuse code base, poor discoverability</span></span><br/><span data-ttu-id="a77a2-192">共有インフラストラクチャの欠如</span><span class="sxs-lookup"><span data-stu-id="a77a2-192">Lack of shared infrastructure</span></span>

## <a name="updating-services"></a><span data-ttu-id="a77a2-193">サービスの更新</span><span class="sxs-lookup"><span data-stu-id="a77a2-193">Updating services</span></span>

<span data-ttu-id="a77a2-194">既に運用環境にあるサービスを更新する戦略は複数あります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-194">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="a77a2-195">ここでは、一般的な 3 つのオプション (ローリング アップデート、ブルー グリーン デプロイ、カナリヤ リリース) について説明します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-195">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-updates"></a><span data-ttu-id="a77a2-196">ローリング アップデート</span><span class="sxs-lookup"><span data-stu-id="a77a2-196">Rolling updates</span></span>

<span data-ttu-id="a77a2-197">ローリング アップデートでは、サービスの新しいインスタンスをデプロイし、新しいインスタンスがただちに要求の受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-197">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="a77a2-198">新しいインスタンスが起動すると、前のインスタンスは削除されます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-198">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="a77a2-199">**例:**</span><span class="sxs-lookup"><span data-stu-id="a77a2-199">**Example.**</span></span> <span data-ttu-id="a77a2-200">Kubernetes では、ローリング アップデートが、Deployment のポッド仕様を更新するときの既定の動作です。</span><span class="sxs-lookup"><span data-stu-id="a77a2-200">In Kubernetes, rolling updates are the default behavior when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="a77a2-201">Deployment コントローラーは、更新されたポッドの新しい ReplicaSet を作成します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-201">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="a77a2-202">次に、目的のレプリカ数を維持するために、古い ReplicaSet をスケールダウンしながら新しい ReplicaSet をスケールアップします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-202">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="a77a2-203">古いポッドは、新しいポッドが準備されるまで削除されません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-203">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="a77a2-204">Kubernetes は更新の履歴を保持するため、必要な場合は、更新をロールバックできます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-204">Kubernetes keeps a history of the update, so you can roll back an update if needed.</span></span>

<span data-ttu-id="a77a2-205">ローリング アップデートの 1 つの課題は、更新プロセス中は古いバージョンと新しいバージョンが混在して実行され、トラフィックを受信することです。</span><span class="sxs-lookup"><span data-stu-id="a77a2-205">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="a77a2-206">この期間中は、すべての要求が 2 つのバージョンのどちらにもルーティングされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-206">During this period, any request could get routed to either of the two versions.</span></span>

<span data-ttu-id="a77a2-207">API の破壊的変更の場合は、以前のバージョンのクライアントがすべて更新されるまで、両方のバージョンを並行してサポートすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-207">For breaking API changes, a good practice is to support both versions side by side, until all clients of the previous version are updated.</span></span> <span data-ttu-id="a77a2-208">[API のバージョン管理](./design/api-design.md#api-versioning)に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="a77a2-208">See [API versioning](./design/api-design.md#api-versioning).</span></span>

### <a name="blue-green-deployment"></a><span data-ttu-id="a77a2-209">ブルーグリーン デプロイ</span><span class="sxs-lookup"><span data-stu-id="a77a2-209">Blue-green deployment</span></span>

<span data-ttu-id="a77a2-210">ブルーグリーン デプロイでは、新しいバージョンを前のバージョンと並行してデプロイします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-210">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="a77a2-211">新しいバージョンを検証した後、すべてのトラフィックを前のバージョンから新しいバージョンに一度に切り替えます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-211">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="a77a2-212">切り替え後、アプリケーションを監視して問題があるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-212">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="a77a2-213">問題が生じた場合は、古いバージョンに戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-213">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="a77a2-214">問題がないことを前提として、古いバージョンを削除できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-214">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="a77a2-215">従来のモノリシックまたは N 層アプリケーションでは、ブルーグリーン デプロイは、通常は、2 つの同一環境をプロビジョニングすることを意味します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-215">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="a77a2-216">新しいバージョンをステージング環境にデプロイした後、クライアント トラフィックをステージング環境にリダイレクトします (たとえば、VIP アドレスをスワップします)。</span><span class="sxs-lookup"><span data-stu-id="a77a2-216">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span> <span data-ttu-id="a77a2-217">マイクロサービス アーキテクチャでは、更新はマイクロサービス レベルで発生するため、通常、更新プログラムを同じ環境にデプロイし、サービスの検出機構を使用してスワップします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-217">In a microservices architecture, updates happen at the microservice level, so you would typically deploy the update into the same environment and use a service discovery mechanism to swap.</span></span>

<span data-ttu-id="a77a2-218">**例**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-218">**Example**.</span></span> <span data-ttu-id="a77a2-219">Kubernetes では、ブルーグリーン デプロイを実行するために別のクラスターをプロビジョニングする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="a77a2-219">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="a77a2-220">代わりに、セレクターの利点を実行できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-220">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="a77a2-221">新しいポッド仕様と異なるラベル セットを使用して、新しい Deployment リソースを作成します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-221">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="a77a2-222">このデプロイは、前のデプロイの削除や、それを指しているサービスの変更を行わずに作成します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-222">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="a77a2-223">新しいポッドが実行されたら、新しいデプロイと一致するように、サービスのセレクターを更新できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-223">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span>

<span data-ttu-id="a77a2-224">ブルー グリーン デプロイの 1 つの欠点は、更新中は、サービスで 2 倍のポッド (現在のポッドと次のポッド) が実行されることです。</span><span class="sxs-lookup"><span data-stu-id="a77a2-224">One drawback of blue-green deployment is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="a77a2-225">ポッドが大量の CPU またはメモリ リソースを必要とする場合は、リソースの消費量を処理するために、クラスターを一時的にスケールアウトする必要があります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-225">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span>

### <a name="canary-release"></a><span data-ttu-id="a77a2-226">カナリア リリース</span><span class="sxs-lookup"><span data-stu-id="a77a2-226">Canary release</span></span>

<span data-ttu-id="a77a2-227">カナリヤ リリースでは、更新されたバージョンを少数のクライアントにロールアウトします。</span><span class="sxs-lookup"><span data-stu-id="a77a2-227">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="a77a2-228">その後、すべてのクライアントにロールアウトする前に、新しいサービスの動作を監視します。</span><span class="sxs-lookup"><span data-stu-id="a77a2-228">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="a77a2-229">これにより、制御された方法でロールアウトを時間をかけて実行し、実際のデータを観察し、すべてのユーザーが影響を受ける前に問題を見分けることができます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-229">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="a77a2-230">カナリヤ リリースは、異なるバージョンのサービスに要求を動的にルーティングする必要があるため、ブルーグリーン デプロイやローリング アップデートよりも管理が複雑になります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-230">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span>

<span data-ttu-id="a77a2-231">**例**。</span><span class="sxs-lookup"><span data-stu-id="a77a2-231">**Example**.</span></span> <span data-ttu-id="a77a2-232">Kubernetes では、2 つのレプリカ セット (バージョンごとに 1 つ) にまたがるように Service を構成し、レプリカの数を手動で調整できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-232">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="a77a2-233">ただし、この方法は、Kubernetes の負荷がポッド間に分散されるため、粒度が粗くなります。</span><span class="sxs-lookup"><span data-stu-id="a77a2-233">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="a77a2-234">たとえば、合計 10 個のレプリカがある場合、トラフィックのシフトは 10% の増分でのみ実行できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-234">For example, if you have a total of 10 replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="a77a2-235">サービス メッシュを使用する場合は、サービス メッシュのルーティング規則を使用して、より高度なカナリヤ リリース戦略を実装できます。</span><span class="sxs-lookup"><span data-stu-id="a77a2-235">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span>

## <a name="next-steps"></a><span data-ttu-id="a77a2-236">次の手順</span><span class="sxs-lookup"><span data-stu-id="a77a2-236">Next steps</span></span>

<span data-ttu-id="a77a2-237">Kubernetes で実行されているマイクロサービスについては、特定の CI/CD プラクティスを参照してください。</span><span class="sxs-lookup"><span data-stu-id="a77a2-237">Learn specific CI/CD practices for microservices running on Kubernetes.</span></span>

- [<span data-ttu-id="a77a2-238">Kubernetes 上でのマイクロサービスの CI/CD</span><span class="sxs-lookup"><span data-stu-id="a77a2-238">CI/CD for microservices on Kubernetes</span></span>](./ci-cd-kubernetes.md)