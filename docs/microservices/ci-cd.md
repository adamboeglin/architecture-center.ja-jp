---
title: マイクロサービスの CI/CD
description: マイクロサービスの継続的インテグレーションと継続的デリバリー。
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 219c50fb002a97874310b76de6f3bdbc34eaac6d
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58242363"
---
# <a name="designing-microservices-continuous-integration"></a><span data-ttu-id="41912-103">マイクロサービスの設計:継続的インテグレーション</span><span class="sxs-lookup"><span data-stu-id="41912-103">Designing microservices: Continuous integration</span></span>

<span data-ttu-id="41912-104">継続的インテグレーションと継続的デリバリー (CI/CD) は、マイクロサービスで成功を収めるための重要な要件です。</span><span class="sxs-lookup"><span data-stu-id="41912-104">Continuous integration and continuous delivery (CI/CD) are a key requirement for achieving success with microservices.</span></span> <span data-ttu-id="41912-105">良質の CI/CD プロセスなしでは、マイクロサービスが約束する機敏性は達成できません。</span><span class="sxs-lookup"><span data-stu-id="41912-105">Without a good CI/CD process, you will not achieve the agility that microservices promise.</span></span> <span data-ttu-id="41912-106">マイクロサービスに対する CI/CD の課題の一部は、多様なサービスのための複数のコード ベースと異種ビルド環境が存在することに起因します。</span><span class="sxs-lookup"><span data-stu-id="41912-106">Some of the CI/CD challenges for microservices arise from having multiple code bases and heterogenous build environments for the various services.</span></span> <span data-ttu-id="41912-107">この記事では、これらの課題について説明し、問題に対処するために推奨するいくつかの方法を示します。</span><span class="sxs-lookup"><span data-stu-id="41912-107">This article describes the challenges and recommends some approaches to the problem.</span></span>

![マイクロサービスの CI/CD の図](./images/ci-cd.png)

<span data-ttu-id="41912-109">マイクロサービス アーキテクチャを採用する最大の理由の 1 つは、リリース サイクルの高速化です。</span><span class="sxs-lookup"><span data-stu-id="41912-109">Faster release cycles are one of the biggest reasons to adopt a microservices architecture.</span></span>

<span data-ttu-id="41912-110">純粋なモノリシック アプリケーションには、その出力がアプリケーション実行可能ファイルである単一のビルド パイプラインがあります。</span><span class="sxs-lookup"><span data-stu-id="41912-110">In a purely monolithic application, there is a single build pipeline whose output is the application executable.</span></span> <span data-ttu-id="41912-111">すべての開発作業は、このパイプラインに注ぎ込まれます。</span><span class="sxs-lookup"><span data-stu-id="41912-111">All development work feeds into this pipeline.</span></span> <span data-ttu-id="41912-112">優先度の高いバグが見つかった場合、修正を統合し、テストして発行する必要がありますが、それによって新機能のリリースが遅れる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-112">If a high-priority bug is found, a fix must be integrated, tested, and published, which can delay the release of new features.</span></span> <span data-ttu-id="41912-113">確かに、これらの問題は、十分にファクタリングされたモジュールを用意し、機能ブランチを使用してコード変更の影響を最小限に抑えることで軽減できます。</span><span class="sxs-lookup"><span data-stu-id="41912-113">It's true that you can mitigate these problems by having well-factored modules and using feature branches to minimize the impact of code changes.</span></span> <span data-ttu-id="41912-114">ただし、アプリケーションが複雑になり、機能が追加されるにつれて、モノリシックのリリース プロセスは不安定になり、中断される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-114">But as the application grows more complex, and more features are added, the release process for a monolith tends to become more brittle and likely to break.</span></span>

<span data-ttu-id="41912-115">マイクロサービスの理念に従うと、すべてのチームは、リリースするために一列に並んで待つ必要はありません。</span><span class="sxs-lookup"><span data-stu-id="41912-115">Following the microservices philosophy, there should never be a long release train where every team has to get in line.</span></span> <span data-ttu-id="41912-116">サービス "A" をビルドしているチームは、サービス "B" の変更がマージされ、テストされ、デプロイされるまで待たずに、更新プログラムをいつでもリリースできます。</span><span class="sxs-lookup"><span data-stu-id="41912-116">The team that builds service "A" can release an update at any time, without waiting for changes in service "B" to be merged, tested, and deployed.</span></span> <span data-ttu-id="41912-117">CI/CD プロセスは、これを可能にするために非常に重要です。</span><span class="sxs-lookup"><span data-stu-id="41912-117">The CI/CD process is critical to making this possible.</span></span> <span data-ttu-id="41912-118">リリース パイプラインは、更新プログラムのデプロイ リスクを最小限に抑えることができるように、自動化された高い信頼性を持つものにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-118">Your release pipeline must be automated and highly reliable, so that the risks of deploying updates are minimized.</span></span> <span data-ttu-id="41912-119">毎日または 1 日に数回、運用環境にリリースを行っていれば、エラーの再発やサービスの中断はめったに発生しないはずです。</span><span class="sxs-lookup"><span data-stu-id="41912-119">If you are releasing to production daily or multiple times a day, regressions or service disruptions must be very rare.</span></span> <span data-ttu-id="41912-120">同時に、不適切な更新プログラムがデプロイされた場合は、信頼性の高い方法で、サービスの前のバージョンに迅速にロールバックするかロールフォワードする必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-120">At the same time, if a bad update does get deployed, you must have a reliable way to quickly roll back or roll forward to a previous version of a service.</span></span>

![CI/CD モノリスの図](./images/cicd-monolith.png)

<span data-ttu-id="41912-122">CI/CD の話は、実際には、継続的インテグレーション、継続的デリバリー、および継続的デプロイという関連する複数のプロセスについての話です。</span><span class="sxs-lookup"><span data-stu-id="41912-122">When we talk about CI/CD, we are really talking about several related processes: Continuous integration, continuous delivery, and continuous deployment.</span></span>

- <span data-ttu-id="41912-123">継続的インテグレーションとは、コード変更が、自動化されたビルドとテストのプロセスを使用して頻繁にメイン ブランチにマージされ、メイン ブランチのコードが常に製品レベルの品質であることが保証されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="41912-123">Continuous integration means that code changes are frequently merged into the main branch, using automated build and test processes to ensure that code in the main branch is always production-quality.</span></span>

- <span data-ttu-id="41912-124">継続的配信とは、CI プロセスに合格したコード変更が運用環境に似た環境に自動的に公開されることを意味します。</span><span class="sxs-lookup"><span data-stu-id="41912-124">Continuous delivery means that code changes that pass the CI process are automatically published to a production-like environment.</span></span> <span data-ttu-id="41912-125">運用環境へのデプロイには手動による承認が必要な場合がありますが、それ以外の場合は自動化されます。</span><span class="sxs-lookup"><span data-stu-id="41912-125">Deployment into the live production environment may require manual approval, but is otherwise automated.</span></span> <span data-ttu-id="41912-126">目標は、コードが常に運用環境にデプロイされる "*準備ができている*" ことです。</span><span class="sxs-lookup"><span data-stu-id="41912-126">The goal is that your code should always be *ready* to deploy into production.</span></span>

- <span data-ttu-id="41912-127">継続的配置とは、CI/CD プロセスに合格したコード変更が運用環境に自動的にデプロイされることを意味します。</span><span class="sxs-lookup"><span data-stu-id="41912-127">Continuous deployment means that code changes that pass the CI/CD process are automatically deployed into production.</span></span>

<span data-ttu-id="41912-128">Kubernetes とマイクロサービスのコンテキストでは、CI 段階はコンテナー イメージのビルドとテスト、およびこれらのイメージのコンテナー レジストリへのプッシュに関係しています。</span><span class="sxs-lookup"><span data-stu-id="41912-128">In the context of Kubernetes and microservices, the CI stage is concerned with building and testing container images, and pushing those images to a container registry.</span></span> <span data-ttu-id="41912-129">デプロイ段階では、最新の運用イメージを取得するためにポッド仕様が更新されます。</span><span class="sxs-lookup"><span data-stu-id="41912-129">In the deployment stage, pod specs are updated to pick up the latest production image.</span></span>

## <a name="challenges"></a><span data-ttu-id="41912-130">課題</span><span class="sxs-lookup"><span data-stu-id="41912-130">Challenges</span></span>

- <span data-ttu-id="41912-131">**多数の小さな独立したコード ベース**。</span><span class="sxs-lookup"><span data-stu-id="41912-131">**Many small independent code bases**.</span></span> <span data-ttu-id="41912-132">各チームは、独自のビルド パイプラインを使用して独自のサービスをビルドします。</span><span class="sxs-lookup"><span data-stu-id="41912-132">Each team is responsible for building its own service, with its own build pipeline.</span></span> <span data-ttu-id="41912-133">組織によっては、チームは別々のコード リポジトリを使用する場合があります。</span><span class="sxs-lookup"><span data-stu-id="41912-133">In some organizations, teams may use separate code repositories.</span></span> <span data-ttu-id="41912-134">このため、システムをビルドするための知識がチームに分散し、アプリケーション全体をデプロイする方法を知っている人物が組織内に存在しないという状況に陥る可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-134">This could lead to a situation where the knowledge of how to build the system is spread across teams, and nobody in the organization knows how to deploy the entire application.</span></span> <span data-ttu-id="41912-135">たとえば、ディザスター リカバリー シナリオで、すぐに新しいクラスターへのデプロイが必要になったら、どうしたらよいのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="41912-135">For example, what happens in a disaster recovery scenario, if you need to quickly deploy to a new cluster?</span></span>

- <span data-ttu-id="41912-136">**複数の言語とフレームワーク**。</span><span class="sxs-lookup"><span data-stu-id="41912-136">**Multiple languages and frameworks**.</span></span> <span data-ttu-id="41912-137">各チームはテクノロジーを独自に組み合わせて使用するため、組織全体で動作する単一のビルド プロセスを作成するのは困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-137">With each team using its own mix of technologies, it can be difficult to create a single build process that works across the organization.</span></span> <span data-ttu-id="41912-138">ビルド プロセスは、すべてのチームが言語やフレームワークを選択できる柔軟性を備えている必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-138">The build process must be flexible enough that every team can adapt it for their choice of language or framework.</span></span>

- <span data-ttu-id="41912-139">**統合とロード テスト**。</span><span class="sxs-lookup"><span data-stu-id="41912-139">**Integration and load testing**.</span></span> <span data-ttu-id="41912-140">チームは独自のペースで更新プログラムをリリースするため、堅牢なエンド ツー エンド テストを設計するのは困難である可能性があります。これは特にサービスに他のサービスとの依存関係がある場合にそうなります。</span><span class="sxs-lookup"><span data-stu-id="41912-140">With teams releasing updates at their own pace, it can be challenging to design robust end-to-end testing, especially when services have dependencies on other services.</span></span> <span data-ttu-id="41912-141">さらに、運用クラスター全体の実行は負荷がかかる可能性があるため、すべてのチームが独自のクラスター全体をテスト目的でのみ運用環境規模で実行できる可能性はほとんどありません。</span><span class="sxs-lookup"><span data-stu-id="41912-141">Moreover, running a full production cluster can be expensive, so it's unlikely that every team will be able to run its own full cluster at production scales, just for testing.</span></span>

- <span data-ttu-id="41912-142">**リリース管理**。</span><span class="sxs-lookup"><span data-stu-id="41912-142">**Release management**.</span></span> <span data-ttu-id="41912-143">すべてのチームが、更新プログラムを運用環境にデプロイできる必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-143">Every team should have the ability to deploy an update to production.</span></span> <span data-ttu-id="41912-144">これは、すべてのチーム メンバーがこれを行う権限を持っているという意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="41912-144">That doesn't mean that every team member has permissions to do so.</span></span> <span data-ttu-id="41912-145">ただし、一元的なリリース マネージャー ロールを使用すると、デプロイの速度が遅くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-145">But having a centralized Release Manager role can reduce the velocity of deployments.</span></span> <span data-ttu-id="41912-146">CI/CD プロセスが自動化され、信頼性が高くなるにつれて、一元的な権限は必要なくなっていきます。</span><span class="sxs-lookup"><span data-stu-id="41912-146">The more that your CI/CD process is automated and reliable, the less there should be a need for a central authority.</span></span> <span data-ttu-id="41912-147">ただし、主要な機能の更新プログラムのリリースと小さなバグ修正に対して、異なるポリシーを設定できます。</span><span class="sxs-lookup"><span data-stu-id="41912-147">That said, you might have different policies for releasing major feature updates versus minor bug fixes.</span></span> <span data-ttu-id="41912-148">一元化しないことは、まったく管理しないことを意味するものではありません。</span><span class="sxs-lookup"><span data-stu-id="41912-148">Being decentralized does not mean there should be zero governance.</span></span>

- <span data-ttu-id="41912-149">**コンテナー イメージのバージョン管理**。</span><span class="sxs-lookup"><span data-stu-id="41912-149">**Container image versioning**.</span></span> <span data-ttu-id="41912-150">開発とテストのサイクル中、CI/CD 処理は、多数のコンテナー イメージをビルドします。</span><span class="sxs-lookup"><span data-stu-id="41912-150">During the development and test cycle, the CI/CD process will build many container images.</span></span> <span data-ttu-id="41912-151">リリース候補になるのはその一部のみであり、さらにリリース候補の一部のみが運用環境にプッシュされます。</span><span class="sxs-lookup"><span data-stu-id="41912-151">Only some of those are candidates for release, and then only some of those release candidates will get pushed into production.</span></span> <span data-ttu-id="41912-152">明確なバージョン管理戦略を策定して、どのバージョンが現在運用環境にデプロイされているかを把握し、必要な場合に前のバージョンにロールバックできるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-152">You should have a clear versioning strategy, so that you know which images are currently deployed to production, and can roll back to a previous version if necessary.</span></span>

- <span data-ttu-id="41912-153">**サービスの更新**。</span><span class="sxs-lookup"><span data-stu-id="41912-153">**Service updates**.</span></span> <span data-ttu-id="41912-154">サービスを新しいバージョンに更新するときは、それに依存するその他のサービスの中断が発生してはなりません。</span><span class="sxs-lookup"><span data-stu-id="41912-154">When you update a service to a new version, it shouldn't break other services that depend on it.</span></span> <span data-ttu-id="41912-155">ローリング アップデートを行う場合は、複数のバージョンが混在して実行される期間が存在します。</span><span class="sxs-lookup"><span data-stu-id="41912-155">If you do a rolling update, there will be a period of time when a mix of versions is running.</span></span>

<span data-ttu-id="41912-156">これらの課題は、根本的な緊張関係を反映しています。</span><span class="sxs-lookup"><span data-stu-id="41912-156">These challenges reflect a fundamental tension.</span></span> <span data-ttu-id="41912-157">一方では、チームは、できるだけ独立して作業する必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-157">On the one hand, teams need to work as independently as possible.</span></span> <span data-ttu-id="41912-158">他方では、1 人の人間が、統合テストの実行、新しいクラスターへのソリューション全体の再デプロイ、不適切な更新のロールバックなどのタスクを実行できるように、何らかの調整を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-158">On the other hand, some coordination is needed so that a single person can do tasks like running an integration test, redeploying the entire solution to a new cluster, or rolling back a bad update.</span></span>

## <a name="cicd-approaches-for-microservices"></a><span data-ttu-id="41912-159">マイクロサービスの CI/CD アプローチ</span><span class="sxs-lookup"><span data-stu-id="41912-159">CI/CD approaches for microservices</span></span>

<span data-ttu-id="41912-160">すべてのサービス チームは、各自のビルド環境をコンテナー化することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="41912-160">It's a good practice for every service team to containerize their build environment.</span></span> <span data-ttu-id="41912-161">このコンテナーには、サービスのコード成果物をビルドするために必要なすべてのツールが含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-161">This container should have all of the build tools necessary to build the code artifacts for their service.</span></span> <span data-ttu-id="41912-162">多くの場合、使用する言語とフレームワークに適した公式 Docker イメージを見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="41912-162">Often you can find an official Docker image for your language and framework.</span></span> <span data-ttu-id="41912-163">`docker run` または Docker Compose を使用してビルドを実行できます。</span><span class="sxs-lookup"><span data-stu-id="41912-163">Then you can use `docker run` or Docker Compose to run the build.</span></span>

<span data-ttu-id="41912-164">この方法では、新しいビルド環境のセットアップは取るに足りない問題です。</span><span class="sxs-lookup"><span data-stu-id="41912-164">With this approach, it's trivial to set up a new build environment.</span></span> <span data-ttu-id="41912-165">コードをビルドする開発者は、一連のビルド ツールをインストールする必要はなく、コンテナー イメージを実行するだけです。</span><span class="sxs-lookup"><span data-stu-id="41912-165">A developer who wants to build your code doesn't need to install a set of build tools, but simply runs the container image.</span></span> <span data-ttu-id="41912-166">おそらく、もっと重要なのは、同様の操作を実行するようにビルド サーバーを構成できることです。</span><span class="sxs-lookup"><span data-stu-id="41912-166">Perhaps more importantly, your build server can be configured to do the same thing.</span></span> <span data-ttu-id="41912-167">つまり、ビルド サーバー上にこれらのツールをインストールしたり、ツールのバージョンの競合を管理したりする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="41912-167">That way, you don't need to install those tools onto the build server, or manage conflicting versions of tools.</span></span>

<span data-ttu-id="41912-168">ローカルの開発とテストでは、Docker を使用して、コンテナーの内部でサービスを実行します。</span><span class="sxs-lookup"><span data-stu-id="41912-168">For local development and testing, use Docker to run the service inside a container.</span></span> <span data-ttu-id="41912-169">このプロセスの一環として、ローカル テストで必要なモック サービスやテスト データベースがある他のコンテナーの実行が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="41912-169">As part of this process, you may need to run other containers that have mock services or test databases needed for local testing.</span></span> <span data-ttu-id="41912-170">Docker Compose を使用してこれらのコンテナーを調整するか、Minikube を使用して Kubernetes をローカルで実行できます。</span><span class="sxs-lookup"><span data-stu-id="41912-170">You could use Docker Compose to coordinate these containers, or use Minikube to run Kubernetes locally.</span></span>

<span data-ttu-id="41912-171">コードが準備できたら、pull request を開き、マスターにマージします。</span><span class="sxs-lookup"><span data-stu-id="41912-171">When the code is ready, open a pull request and merge into master.</span></span> <span data-ttu-id="41912-172">ビルド サーバー上でジョブを開始します。</span><span class="sxs-lookup"><span data-stu-id="41912-172">This will start a job on the build server:</span></span>

1. <span data-ttu-id="41912-173">コード アセットをビルドします。</span><span class="sxs-lookup"><span data-stu-id="41912-173">Build the code assets.</span></span>
2. <span data-ttu-id="41912-174">コードに対して単体テストを実行します。</span><span class="sxs-lookup"><span data-stu-id="41912-174">Run unit tests against the code.</span></span>
3. <span data-ttu-id="41912-175">コンテナー イメージをビルドします。</span><span class="sxs-lookup"><span data-stu-id="41912-175">Build the container image.</span></span>
4. <span data-ttu-id="41912-176">実行中のコンテナーで機能テストを実行することで、コンテナー イメージをテストします。</span><span class="sxs-lookup"><span data-stu-id="41912-176">Test the container image by running functional tests on a running container.</span></span> <span data-ttu-id="41912-177">この手順で、無効なエントリ ポイントなどの Docker ファイル内のエラーをキャッチできます。</span><span class="sxs-lookup"><span data-stu-id="41912-177">This step can catch errors in the Docker file, such as a bad entry point.</span></span>
5. <span data-ttu-id="41912-178">イメージをコンテナー レジストリにプッシュします。</span><span class="sxs-lookup"><span data-stu-id="41912-178">Push the image to a container registry.</span></span>
6. <span data-ttu-id="41912-179">新しいイメージでテスト クラスターを更新し、統合テストを実行します。</span><span class="sxs-lookup"><span data-stu-id="41912-179">Update the test cluster with the new image to run integration tests.</span></span>

<span data-ttu-id="41912-180">イメージを運用環境に移動する準備ができたら、必要に応じて、最新のイメージを指定するようにデプロイ ファイルを更新し、Kubernetes 構成ファイルも更新します。</span><span class="sxs-lookup"><span data-stu-id="41912-180">When the image is ready to go into production, update the deployment files as needed to specify the latest image, including any Kubernetes configuration files.</span></span> <span data-ttu-id="41912-181">更新プログラムを運用クラスターに適用します。</span><span class="sxs-lookup"><span data-stu-id="41912-181">Then apply the update to the production cluster.</span></span>

<span data-ttu-id="41912-182">信頼性の高いデプロイを行うための推奨事項を次に示します。</span><span class="sxs-lookup"><span data-stu-id="41912-182">Here are some recommendations for making deployments more reliable:</span></span>

- <span data-ttu-id="41912-183">クラスター (ポッドやサービスなど) にデプロイされるリソースのコンテナー タグ、バージョン管理、および名前付けに関する組織規模の規則を定義します。</span><span class="sxs-lookup"><span data-stu-id="41912-183">Define organization-wide conventions for container tags, versioning, and naming conventions for resources deployed to the cluster (pods, services, and so on).</span></span> <span data-ttu-id="41912-184">これにより、デプロイに関する問題が診断しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="41912-184">That can make it easier to diagnose deployment issues.</span></span>

- <span data-ttu-id="41912-185">開発/テスト用と運用環境用の 2 つのコンテナー レジストリを作成します。</span><span class="sxs-lookup"><span data-stu-id="41912-185">Create two separate container registries, one for development/testing and one for production.</span></span> <span data-ttu-id="41912-186">運用環境にデプロイする準備ができるまで、イメージを運用レジストリにプッシュしないでください。</span><span class="sxs-lookup"><span data-stu-id="41912-186">Don't push an image to the production registry until you're ready to deploy it into production.</span></span> <span data-ttu-id="41912-187">このプラクティスとコンテナー イメージのセマンティックなバージョン管理を組み合わせると、リリースを承認されていないバージョンが誤ってデプロイされる可能性を低くすることができます。</span><span class="sxs-lookup"><span data-stu-id="41912-187">If you combine this practice with semantic versioning of container images, it can reduce the chance of accidentally deploying a version that wasn't approved for release.</span></span>

## <a name="updating-services"></a><span data-ttu-id="41912-188">サービスの更新</span><span class="sxs-lookup"><span data-stu-id="41912-188">Updating services</span></span>

<span data-ttu-id="41912-189">既に運用環境にあるサービスを更新する戦略は複数あります。</span><span class="sxs-lookup"><span data-stu-id="41912-189">There are various strategies for updating a service that's already in production.</span></span> <span data-ttu-id="41912-190">ここでは、一般的な 3 つのオプション (ローリング アップデート、ブルー グリーン デプロイ、カナリヤ リリース) について説明します。</span><span class="sxs-lookup"><span data-stu-id="41912-190">Here we discuss three common options: Rolling update, blue-green deployment, and canary release.</span></span>

### <a name="rolling-update"></a><span data-ttu-id="41912-191">ローリング アップデート</span><span class="sxs-lookup"><span data-stu-id="41912-191">Rolling update</span></span>

<span data-ttu-id="41912-192">ローリング アップデートでは、サービスの新しいインスタンスをデプロイし、新しいインスタンスがただちに要求の受信を開始します。</span><span class="sxs-lookup"><span data-stu-id="41912-192">In a rolling update, you deploy new instances of a service, and the new instances start receiving requests right away.</span></span> <span data-ttu-id="41912-193">新しいインスタンスが起動すると、前のインスタンスは削除されます。</span><span class="sxs-lookup"><span data-stu-id="41912-193">As the new instances come up, the previous instances are removed.</span></span>

<span data-ttu-id="41912-194">ローリング アップデートは、Deployment のポッド仕様を更新するときの Kubernetes の既定の動作です。</span><span class="sxs-lookup"><span data-stu-id="41912-194">Rolling updates are the default behavior in Kubernetes when you update the pod spec for a Deployment.</span></span> <span data-ttu-id="41912-195">Deployment コントローラーは、更新されたポッドの新しい ReplicaSet を作成します。</span><span class="sxs-lookup"><span data-stu-id="41912-195">The Deployment controller creates a new ReplicaSet for the updated pods.</span></span> <span data-ttu-id="41912-196">次に、目的のレプリカ数を維持するために、古い ReplicaSet をスケールダウンしながら新しい ReplicaSet をスケールアップします。</span><span class="sxs-lookup"><span data-stu-id="41912-196">Then it scales up the new ReplicaSet while scaling down the old one, to maintain the desired replica count.</span></span> <span data-ttu-id="41912-197">古いポッドは、新しいポッドが準備されるまで削除されません。</span><span class="sxs-lookup"><span data-stu-id="41912-197">It doesn't delete old pods until the new ones are ready.</span></span> <span data-ttu-id="41912-198">Kubernetes は更新の履歴を保持するため、必要な場合は、kubectl を使用して更新をロールバックできます。</span><span class="sxs-lookup"><span data-stu-id="41912-198">Kubernetes keeps a history of the update, so you can use kubectl to roll back an update if needed.</span></span>

<span data-ttu-id="41912-199">サービスで長いスタートアップ タスクが実行される場合は、準備プローブを定義できます。</span><span class="sxs-lookup"><span data-stu-id="41912-199">If your service performs a long startup task, you can define a readiness probe.</span></span> <span data-ttu-id="41912-200">準備プローブは、コンテナーがトラフィックの受信を開始する準備ができたときに、その旨を報告します。</span><span class="sxs-lookup"><span data-stu-id="41912-200">The readiness probe reports when the container is ready to start receiving traffic.</span></span> <span data-ttu-id="41912-201">Kubernetes は、プローブが成功を報告するまで、ポッドにトラフィックを送信しません。</span><span class="sxs-lookup"><span data-stu-id="41912-201">Kubernetes won't send traffic to the pod until the probe reports success.</span></span>

<span data-ttu-id="41912-202">ローリング アップデートの 1 つの課題は、更新プロセス中は古いバージョンと新しいバージョンが混在して実行され、トラフィックを受信することです。</span><span class="sxs-lookup"><span data-stu-id="41912-202">One challenge of rolling updates is that during the update process, a mix of old and new versions are running and receiving traffic.</span></span> <span data-ttu-id="41912-203">この期間中は、すべての要求が 2 つのバージョンのどちらにもルーティングされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-203">During this period, any request could get routed to either of the two versions.</span></span> <span data-ttu-id="41912-204">これは、2 つのバージョン間の変更範囲に応じて、問題になる場合も問題にならない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="41912-204">That may or may not cause problems, depending on the scope of the changes between the two versions.</span></span>

### <a name="blue-green-deployment"></a><span data-ttu-id="41912-205">ブルーグリーン デプロイ</span><span class="sxs-lookup"><span data-stu-id="41912-205">Blue-green deployment</span></span>

<span data-ttu-id="41912-206">ブルーグリーン デプロイでは、新しいバージョンを前のバージョンと並行してデプロイします。</span><span class="sxs-lookup"><span data-stu-id="41912-206">In a blue-green deployment, you deploy the new version alongside the previous version.</span></span> <span data-ttu-id="41912-207">新しいバージョンを検証した後、すべてのトラフィックを前のバージョンから新しいバージョンに一度に切り替えます。</span><span class="sxs-lookup"><span data-stu-id="41912-207">After you validate the new version, you switch all traffic at once from the previous version to the new version.</span></span> <span data-ttu-id="41912-208">切り替え後、アプリケーションを監視して問題があるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="41912-208">After the switch, you monitor the application for any problems.</span></span> <span data-ttu-id="41912-209">問題が生じた場合は、古いバージョンに戻すことができます。</span><span class="sxs-lookup"><span data-stu-id="41912-209">If something goes wrong, you can swap back to the old version.</span></span> <span data-ttu-id="41912-210">問題がないことを前提として、古いバージョンを削除できます。</span><span class="sxs-lookup"><span data-stu-id="41912-210">Assuming there are no problems, you can delete the old version.</span></span>

<span data-ttu-id="41912-211">従来のモノリシックまたは N 層アプリケーションでは、ブルーグリーン デプロイは、通常は、2 つの同一環境をプロビジョニングすることを意味します。</span><span class="sxs-lookup"><span data-stu-id="41912-211">With a more traditional monolithic or N-tier application, blue-green deployment generally meant provisioning two identical environments.</span></span> <span data-ttu-id="41912-212">新しいバージョンをステージング環境にデプロイした後、クライアント トラフィックをステージング環境にリダイレクトします (たとえば、VIP アドレスをスワップします)。</span><span class="sxs-lookup"><span data-stu-id="41912-212">You would deploy the new version to a staging environment, then redirect client traffic to the staging environment &mdash; for example, by swapping VIP addresses.</span></span>

<span data-ttu-id="41912-213">Kubernetes では、ブルーグリーン デプロイを実行するために別のクラスターをプロビジョニングする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="41912-213">In Kubernetes, you don't need to provision a separate cluster to do blue-green deployments.</span></span> <span data-ttu-id="41912-214">代わりに、セレクターの利点を実行できます。</span><span class="sxs-lookup"><span data-stu-id="41912-214">Instead, you can take advantage of selectors.</span></span> <span data-ttu-id="41912-215">新しいポッド仕様と異なるラベル セットを使用して、新しい Deployment リソースを作成します。</span><span class="sxs-lookup"><span data-stu-id="41912-215">Create a new Deployment resource with a new pod spec and a different set of labels.</span></span> <span data-ttu-id="41912-216">このデプロイは、前のデプロイの削除や、それを指しているサービスの変更を行わずに作成します。</span><span class="sxs-lookup"><span data-stu-id="41912-216">Create this deployment, without deleting the previous deployment or modifying the service that points to it.</span></span> <span data-ttu-id="41912-217">新しいポッドが実行されたら、新しいデプロイと一致するように、サービスのセレクターを更新できます。</span><span class="sxs-lookup"><span data-stu-id="41912-217">Once the new pods are running, you can update the service's selector to match the new deployment.</span></span>

<span data-ttu-id="41912-218">ブルーグリーン デプロイの利点は、サービスがすべてのポッドを同時に切り替えることです。</span><span class="sxs-lookup"><span data-stu-id="41912-218">An advantage of blue-green deployments is that the service switches all the pods at the same time.</span></span> <span data-ttu-id="41912-219">サービスが更新されると、すべての新しい要求は、新しいバージョンにルーティングされます。</span><span class="sxs-lookup"><span data-stu-id="41912-219">After the service is updated, all new requests get routed to the new version.</span></span> <span data-ttu-id="41912-220">1 つの欠点は、更新中は、サービスで 2 倍のポッド (現在のポッドと次のポッド) が実行されることです。</span><span class="sxs-lookup"><span data-stu-id="41912-220">One drawback is that during the update, you are running twice as many pods for the service (current and next).</span></span> <span data-ttu-id="41912-221">ポッドが大量の CPU またはメモリ リソースを必要とする場合は、リソースの消費量を処理するために、クラスターを一時的にスケールアウトする必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-221">If the pods require a lot of CPU or memory resources, you may need to scale out the cluster temporarily to handle the resource consumption.</span></span>

### <a name="canary-release"></a><span data-ttu-id="41912-222">カナリア リリース</span><span class="sxs-lookup"><span data-stu-id="41912-222">Canary release</span></span>

<span data-ttu-id="41912-223">カナリヤ リリースでは、更新されたバージョンを少数のクライアントにロールアウトします。</span><span class="sxs-lookup"><span data-stu-id="41912-223">In a canary release, you roll out an updated version to a small number of clients.</span></span> <span data-ttu-id="41912-224">その後、すべてのクライアントにロールアウトする前に、新しいサービスの動作を監視します。</span><span class="sxs-lookup"><span data-stu-id="41912-224">Then you monitor the behavior of the new service before rolling it out to all clients.</span></span> <span data-ttu-id="41912-225">これにより、制御された方法でロールアウトを時間をかけて実行し、実際のデータを観察し、すべてのユーザーが影響を受ける前に問題を見分けることができます。</span><span class="sxs-lookup"><span data-stu-id="41912-225">This lets you do a slow rollout in a controlled fashion, observe real data, and spot problems before all customers are affected.</span></span>

<span data-ttu-id="41912-226">カナリヤ リリースは、異なるバージョンのサービスに要求を動的にルーティングする必要があるため、ブルーグリーン デプロイやローリング アップデートよりも管理が複雑になります。</span><span class="sxs-lookup"><span data-stu-id="41912-226">A canary release is more complex to manage than either blue-green or rolling update, because you must dynamically route requests to different versions of the service.</span></span> <span data-ttu-id="41912-227">Kubernetes では、2 つのレプリカ セット (バージョンごとに 1 つ) にまたがるように Service を構成し、レプリカの数を手動で調整できます。</span><span class="sxs-lookup"><span data-stu-id="41912-227">In Kubernetes, you can configure a Service to span two replica sets (one for each version) and adjust the replica counts manually.</span></span> <span data-ttu-id="41912-228">ただし、この方法は、Kubernetes の負荷がポッド間に分散されるため、粒度が粗くなります。</span><span class="sxs-lookup"><span data-stu-id="41912-228">However, this approach is rather coarse-grained, because of the way Kubernetes load balances across pods.</span></span> <span data-ttu-id="41912-229">たとえば、合計 10 個のレプリカがある場合、トラフィックのシフトは 10 % 刻みのみで実行できます。</span><span class="sxs-lookup"><span data-stu-id="41912-229">For example, if you have a total of ten replicas, you can only shift traffic in 10% increments.</span></span> <span data-ttu-id="41912-230">サービス メッシュを使用する場合は、サービス メッシュのルーティング規則を使用して、より高度なカナリヤ リリース戦略を実装できます。</span><span class="sxs-lookup"><span data-stu-id="41912-230">If you are using a service mesh, you can use the service mesh routing rules to implement a more sophisticated canary release strategy.</span></span> <span data-ttu-id="41912-231">役に立ついくつかのリソースを次に示します。</span><span class="sxs-lookup"><span data-stu-id="41912-231">Here are some resources that may be helpful:</span></span>

- <span data-ttu-id="41912-232">サービス メッシュのない Kubernetes:[カナリヤ デプロイ](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)</span><span class="sxs-lookup"><span data-stu-id="41912-232">Kubernetes without service mesh: [Canary deployments](https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)</span></span>
- <span data-ttu-id="41912-233">Linkerd:[動的な要求のルーティング](https://linkerd.io/features/routing/)</span><span class="sxs-lookup"><span data-stu-id="41912-233">Linkerd: [Dynamic request routing](https://linkerd.io/features/routing/)</span></span>
- <span data-ttu-id="41912-234">Istio:[Istio を使用したカナリヤ デプロイ](https://istio.io/blog/canary-deployments-using-istio.html)</span><span class="sxs-lookup"><span data-stu-id="41912-234">Istio: [Canary Deployments using Istio](https://istio.io/blog/canary-deployments-using-istio.html)</span></span>

## <a name="conclusion"></a><span data-ttu-id="41912-235">まとめ</span><span class="sxs-lookup"><span data-stu-id="41912-235">Conclusion</span></span>

<span data-ttu-id="41912-236">近年、この業界では、"*レコード システム*" の構築から "*エンゲージメント システム*" の構築への移行という著しい変化が起こっています。</span><span class="sxs-lookup"><span data-stu-id="41912-236">In recent years, there has been a sea change in the industry, a movement from building *systems of record* to building *systems of engagement*.</span></span>

<span data-ttu-id="41912-237">レコード システムとは、従来のバック オフィス データ管理アプリケーションのことです。</span><span class="sxs-lookup"><span data-stu-id="41912-237">Systems of record are traditional back-office data management applications.</span></span> <span data-ttu-id="41912-238">これらのシステムの中心には、多くの場合、信頼できる単一のソースである RDBMS が存在しています。</span><span class="sxs-lookup"><span data-stu-id="41912-238">At the heart of these systems there often sits an RDBMS that is the single source of truth.</span></span> <span data-ttu-id="41912-239">"エンゲージメント システム" という用語は、Geoffrey Moore が 2011 年に記述した「*Systems of Engagement and the Future of Enterprise IT*」(エンゲージメント システムとエンタープライズ IT の未来) という文書で提唱したものです。</span><span class="sxs-lookup"><span data-stu-id="41912-239">The term "system of engagement" is credited to Geoffrey Moore, in his 2011 paper *Systems of Engagement and the Future of Enterprise IT*.</span></span> <span data-ttu-id="41912-240">エンゲージメント システムは、コミュニケーションとコラボレーションに重点を置いたアプリケーションです。</span><span class="sxs-lookup"><span data-stu-id="41912-240">Systems of engagement are applications focused on communication and collaboration.</span></span> <span data-ttu-id="41912-241">それらは、ユーザーをリアルタイムで結びます。</span><span class="sxs-lookup"><span data-stu-id="41912-241">They connect people in real time.</span></span> <span data-ttu-id="41912-242">それらは、24 時間年中無休で使用できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-242">They must be available 24/7.</span></span> <span data-ttu-id="41912-243">新機能は、アプリケーションをオフラインにすることなく、定期的に導入されます。</span><span class="sxs-lookup"><span data-stu-id="41912-243">New features are introduced regularly without taking the application offline.</span></span> <span data-ttu-id="41912-244">ユーザーの期待は高く、予期しない遅延やダウンタイムは許容されません。</span><span class="sxs-lookup"><span data-stu-id="41912-244">Users expect more and are less patient of unexpected delays or downtime.</span></span>

<span data-ttu-id="41912-245">消費者市場では、優れたユーザー エクスペリエンスは、重要なビジネス価値を持つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-245">In the consumer space, a better user experience can have measurable business value.</span></span> <span data-ttu-id="41912-246">ユーザーがアプリケーションを使用する時間を、収益に直接変換できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41912-246">The amount of time that a user engages with an application may translate directly into revenue.</span></span> <span data-ttu-id="41912-247">そして、ビジネス システムの領域では、ユーザーの期待は変化しています。</span><span class="sxs-lookup"><span data-stu-id="41912-247">And in the realm of business systems, users' expectations have changed.</span></span> <span data-ttu-id="41912-248">これらのシステムがコミュニケーションとコラボレーションを目指しているのであれば、コンシューマー向けのアプリケーションからヒントを得る必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-248">If these systems aim to foster communication and collaboration, they must take their cue from consumer-facing applications.</span></span>

<span data-ttu-id="41912-249">マイクロサービスは、この変化する状況に対する 1 つの答えです。</span><span class="sxs-lookup"><span data-stu-id="41912-249">Microservices are a response to this changing landscape.</span></span> <span data-ttu-id="41912-250">モノリシック アプリケーションを緩やかに結合されたサービスのグループに分解することで、各サービスのリリース サイクルを制御でき、ダウンタイムや重大な変更なしで更新を頻繁に実行できます。</span><span class="sxs-lookup"><span data-stu-id="41912-250">By decomposing a monolithic application into a group of loosely coupled services, we can control the release cycle of each service, and enable frequent updates without downtime or breaking changes.</span></span> <span data-ttu-id="41912-251">マイクロサービスは、スケーラビリティ、障害の分離、および回復性にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="41912-251">Microservices also help with scalability, failure isolation, and resiliency.</span></span> <span data-ttu-id="41912-252">同時に、クラウド プラットフォームは、自動化されたコンピューティング リソースのプロビジョニング、サービスとしてのコンテナー オーケストレーター、およびイベント ドリブン サーバーレス環境によって、マイクロサービスを簡単にビルドして実行できるようにしています。</span><span class="sxs-lookup"><span data-stu-id="41912-252">Meanwhile, cloud platforms are making it easier to build and run microservices, with automated provisioning of compute resources, container orchestrators as a service, and event-driven serverless environments.</span></span>

<span data-ttu-id="41912-253">ただし、ここで説明したように、マイクロサービス アーキテクチャには、多くの課題もあります。</span><span class="sxs-lookup"><span data-stu-id="41912-253">But as we've seen, microservices architectures also being a lot of challenges.</span></span> <span data-ttu-id="41912-254">成功するには、堅実な設計から始める必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-254">To succeed, you must start from a solid design.</span></span> <span data-ttu-id="41912-255">ドメインの分析、テクノロジの選択、データのモデリング、API の設計、および成熟した DevOps カルチャの構築について、慎重に考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="41912-255">You must put careful thought into analyzing the domain, choosing technologies, modeling data, designing APIs, and building a mature DevOps culture.</span></span> <span data-ttu-id="41912-256">このガイドと添付の[リファレンス実装](https://github.com/mspnp/microservices-reference-implementation)が、道標として役に立てば幸いです。</span><span class="sxs-lookup"><span data-stu-id="41912-256">We hope that this guide, and the accompanying [reference implementation](https://github.com/mspnp/microservices-reference-implementation), has helped to illuminate the journey.</span></span>
