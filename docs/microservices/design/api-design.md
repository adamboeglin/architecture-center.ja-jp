---
title: API 設計
description: マイクロサービス用の API の設計
author: MikeWasson
ms.date: 02/25/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: c2c96a340465d11c89147e991617d0c1c526e236
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58245573"
---
# <a name="designing-apis-for-microservices"></a><span data-ttu-id="b2eac-103">マイクロサービス用の API の設計</span><span class="sxs-lookup"><span data-stu-id="b2eac-103">Designing APIs for microservices</span></span>

<span data-ttu-id="b2eac-104">サービス間のすべてのデータ交換はメッセージまたは API 呼び出しのいずれかによって行われるため、マイクロサービス アーキテクチャでは優れた API 設計にすることが重要です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="b2eac-105">[頻度の高い I/O](../../antipatterns/chatty-io/index.md) の作成を避けるために、API は効率的にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-105">APIs must be efficient to avoid creating [chatty I/O](../../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="b2eac-106">サービスは独立して作業する複数のチームによって設計されるため、API はセマンティクスとバージョン管理スキームを明確に定義する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![マイクロサービスの API 設計](../images/api-design.png)

<span data-ttu-id="b2eac-108">2 種類の API を区別することが重要です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-108">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="b2eac-109">クライアント アプリケーションが呼び出すパブリック API。</span><span class="sxs-lookup"><span data-stu-id="b2eac-109">Public APIs that client applications call.</span></span>
- <span data-ttu-id="b2eac-110">サービス間通信に使用されるバックエンド API。</span><span class="sxs-lookup"><span data-stu-id="b2eac-110">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="b2eac-111">これら 2 つのユース ケースには、異なる要件が一部にあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-111">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="b2eac-112">パブリック API には、クライアント アプリケーション (通常はブラウザー アプリケーションやネイティブ モバイル アプリケーション) と互換性を持たせる必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-112">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="b2eac-113">ほとんどの場合、パブリック API は REST over HTTP を使用します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-113">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="b2eac-114">一方、バックエンド API では、ネットワークのパフォーマンスを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-114">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="b2eac-115">サービスの細分性によっては、サービス間通信で多くのネットワーク トラフィックが発生する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-115">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="b2eac-116">サービスはすぐに I/O に縛られる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-116">Services can quickly become I/O bound.</span></span> <span data-ttu-id="b2eac-117">そのため、シリアル化の速度やペイロード サイズなどの考慮事項が重要になります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-117">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="b2eac-118">REST over HTTP の一般的な代替手段として、gRPC、Apache Avro、Apache Thrift などがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-118">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="b2eac-119">これらのプロトコルはバイナリのシリアル化をサポートするので、一般に HTTP より効率的です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-119">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="b2eac-120">考慮事項</span><span class="sxs-lookup"><span data-stu-id="b2eac-120">Considerations</span></span>

<span data-ttu-id="b2eac-121">API の実装方法を選択する際に考慮すべき事項がいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-121">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="b2eac-122">**REST か RPC か**。</span><span class="sxs-lookup"><span data-stu-id="b2eac-122">**REST versus RPC**.</span></span> <span data-ttu-id="b2eac-123">REST スタイルのインターフェイスと RPC スタイルのインターフェイスのトレードオフを考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="b2eac-123">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="b2eac-124">REST はリソースをモデル化します。自然な方法でドメイン モデルを表現することができます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-124">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="b2eac-125">また、HTTP 動詞に基づいて統一インターフェイスを定義し、進化を促進しています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-125">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="b2eac-126">REST には、べき等、副作用、および応答コードに関して明確に定義されたセマンティクスがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-126">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="b2eac-127">また、ステートレスな通信を強制するため、スケーラビリティが向上します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-127">And it enforces stateless communication, which improves scalability.</span></span>

- <span data-ttu-id="b2eac-128">RPC は操作やコマンドを中心にしています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-128">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="b2eac-129">RPC インターフェイスはローカルのメソッド呼び出しに似ているため、過度に冗長な API を設計することになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-129">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="b2eac-130">ただし、RPC が常に冗長という意味ではありません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-130">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="b2eac-131">インターフェイスを設計するときには注意する必要があるということです。</span><span class="sxs-lookup"><span data-stu-id="b2eac-131">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="b2eac-132">RESTful インターフェイスの場合、最も一般的な選択肢は、JSON を使用した REST over HTTP です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-132">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="b2eac-133">RPC スタイルのインターフェイスには、gRPC、Apache Avro、Apache Thrift などの一般的なフレームワークがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-133">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.</span></span>

<span data-ttu-id="b2eac-134">**効率**。</span><span class="sxs-lookup"><span data-stu-id="b2eac-134">**Efficiency**.</span></span> <span data-ttu-id="b2eac-135">速度、メモリ、およびペイロード サイズに関して効率を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-135">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="b2eac-136">通常、gRPC ベースのインターフェイスは、REST over HTTP よりも高速です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-136">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="b2eac-137">**インターフェイス定義言語 (IDL)**。</span><span class="sxs-lookup"><span data-stu-id="b2eac-137">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="b2eac-138">IDL は、API のメソッド、パラメーター、および戻り値を定義するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-138">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="b2eac-139">IDL は、クライアント コード、シリアル化コード、および API ドキュメントの生成に使用できます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-139">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="b2eac-140">IDL は、Postman などの API テスト ツールでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-140">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="b2eac-141">gRPC、Avro、および Thrift などのフレームワークには、独自の IDL 仕様が定義されています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-141">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="b2eac-142">REST over HTTP に標準の IDL 形式はありませんが、一般的な選択肢は OpenAPI (旧 Swagger) です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-142">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="b2eac-143">正式な定義言語を使用せずに HTTP REST API を作成することもできますが、コード生成とテストのメリットは失われます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-143">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="b2eac-144">**シリアル化**。</span><span class="sxs-lookup"><span data-stu-id="b2eac-144">**Serialization**.</span></span> <span data-ttu-id="b2eac-145">ネットワーク経由の場合、オブジェクトはどのようにシリアル化しますか。</span><span class="sxs-lookup"><span data-stu-id="b2eac-145">How are objects serialized over the wire?</span></span> <span data-ttu-id="b2eac-146">選択肢として、テキストベースの形式 (主に JSON) やプロトコル バッファーなどのバイナリ形式があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-146">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="b2eac-147">バイナリ形式は一般的にテキストベース形式より高速です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-147">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="b2eac-148">ただし、ほとんどの言語とフレームワークが JSON のシリアル化をサポートしているため、JSON は相互運用性の面で利点があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-148">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="b2eac-149">シリアル化形式には固定スキーマが必要なものや、スキーマ定義ファイルのコンパイルが必要なものがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-149">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="b2eac-150">その場合は、次の手順をビルド プロセスに組み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-150">In that case, you'll need to incorporate this step into your build process.</span></span>

<span data-ttu-id="b2eac-151">**フレームワークと言語のサポート**。</span><span class="sxs-lookup"><span data-stu-id="b2eac-151">**Framework and language support**.</span></span> <span data-ttu-id="b2eac-152">HTTP はほぼすべてのフレームワークと言語でサポートされています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-152">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="b2eac-153">gRPC、Avro、Thrift には、いずれも C++、C#、Java、Python 用のライブラリがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-153">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="b2eac-154">Thrift と gRPC は Go もサポートしています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-154">Thrift and gRPC also support Go.</span></span>

<span data-ttu-id="b2eac-155">**互換性と相互運用性**。</span><span class="sxs-lookup"><span data-stu-id="b2eac-155">**Compatibility and interoperability**.</span></span> <span data-ttu-id="b2eac-156">gRPC のようなプロトコルを選択する場合は、公開 API とバックエンドの間にプロトコル変換レイヤーが必要な場合があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-156">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="b2eac-157">その機能は[ゲートウェイ](./gateway.md)で実行できます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-157">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="b2eac-158">サービス メッシュを使用している場合は、サービス メッシュと互換性のあるプロトコルを検討してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-158">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="b2eac-159">たとえば、linkerd には、HTTP、Thrift、および gRPC のサポートが組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-159">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span>

<span data-ttu-id="b2eac-160">基本的に、バイナリ プロトコルのパフォーマンス上の利点が必要な場合を除き、REST over HTTP を選択することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-160">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="b2eac-161">REST over HTTP に特別なライブラリは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-161">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="b2eac-162">呼び出し側はサービスと通信するためにクライアント スタブを必要としないため、結合が最小限に抑えられます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-162">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="b2eac-163">RESTful HTTP エンドポイントのスキーマ定義、テスト、および監視をサポートするツールの豊富なエコシステムがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-163">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="b2eac-164">最後に、HTTP はブラウザー クライアントと互換性があるため、クライアントとバックエンドの間にプロトコル変換レイヤーは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-164">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span>

<span data-ttu-id="b2eac-165">ただし、REST over HTTP を選択した場合は、開発プロセスの早い段階でパフォーマンスと負荷テストを行い、シナリオに十分に適しているかどうかを検証する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-165">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="b2eac-166">RESTful API の設計</span><span class="sxs-lookup"><span data-stu-id="b2eac-166">RESTful API design</span></span>

<span data-ttu-id="b2eac-167">RESTful API を設計するには、多くのリソースがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-167">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="b2eac-168">そのうち参考になるリソースをいくつか紹介します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-168">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="b2eac-169">API 設計</span><span class="sxs-lookup"><span data-stu-id="b2eac-169">API design</span></span>](../../best-practices/api-design.md)

- [<span data-ttu-id="b2eac-170">API 実装</span><span class="sxs-lookup"><span data-stu-id="b2eac-170">API implementation</span></span>](../../best-practices/api-implementation.md)

- [<span data-ttu-id="b2eac-171">Microsoft REST API のガイドライン</span><span class="sxs-lookup"><span data-stu-id="b2eac-171">Microsoft REST API Guidelines</span></span>](https://github.com/Microsoft/api-guidelines)

<span data-ttu-id="b2eac-172">留意すべき具体的な考慮事項をいくつか挙げます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-172">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="b2eac-173">内部実装の詳細を漏えいする API や、単純に内部データベース スキーマをミラーリングする API には注意してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-173">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="b2eac-174">API でドメインをモデル化するようにします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-174">The API should model the domain.</span></span> <span data-ttu-id="b2eac-175">これはサービス間のコントラクトです。何らかのコードのリファクタリングやデータベース テーブルの正規化のためだけでなく、新しい機能が追加されたときにのみ変更するのが理想的です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-175">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span>

- <span data-ttu-id="b2eac-176">モバイル アプリケーションやデスクトップの Web ブラウザーなど、クライアントの種類によって必要なペイロード サイズや相互作用パターンが異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-176">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="b2eac-177">[フロントエンド用のバックエンド パターン](../../patterns/backends-for-frontends.md)を使用して、各クライアント用に個別のバックエンドを作成し、そのクライアントに最適なインターフェイスを公開することを検討します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-177">Consider using the [Backends for Frontends pattern](../../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="b2eac-178">副作用のある操作については、べき等化して PUT メソッドとして実装することを検討します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-178">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="b2eac-179">こうすることで、安全な再試行が可能になり、回復性が向上します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-179">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="b2eac-180">この問題の詳細については、[サービス間の通信](./interservice-communication.md)に関する記事を参照してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-180">The article [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="b2eac-181">HTTP メソッドは非同期セマンティクスを持つことができます。このようなメソッドでは応答が直ちに返されますが、サービスは非同期に処理を実行します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-181">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="b2eac-182">その場合、メソッドは [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) 応答コードを返す必要があります。これは要求の処理が受け入れられたことを示しますが、処理はまだ完了していません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-182">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="b2eac-183">REST を DDD パターンにマッピングする</span><span class="sxs-lookup"><span data-stu-id="b2eac-183">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="b2eac-184">エンティティ、集約、値オブジェクトなどのパターンは、ドメイン モデルのオブジェクトに特定の制約を課すように設計されています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-184">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="b2eac-185">DDD に関する多くの議論では、コンストラクターやプロパティ ゲッターやセッターなどのオブジェクト指向 (OO) 言語の概念を使用してパターンをモデル化しています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-185">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="b2eac-186">たとえば、*値オブジェクト*は不変にすることになっています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-186">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="b2eac-187">OO プログラミング言語では、この不変性を強制するために、コンストラクターに値を割り当て、プロパティを読み取り専用にしています。</span><span class="sxs-lookup"><span data-stu-id="b2eac-187">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="b2eac-188">このような種類のコーディングは、従来のモノリシック アプリケーションを構築する場合に特に重要です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-188">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="b2eac-189">大規模なコードベースでは、多くのサブシステムが `Location` オブジェクトを使用する可能性があるため、オブジェクトが正しい動作を実行することが重要です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-189">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span>

<span data-ttu-id="b2eac-190">もう 1 つの例は、アプリケーションの他の部分がデータ ストアの読み込みや書き込みを直接行わないようにするリポジトリ パターンです。</span><span class="sxs-lookup"><span data-stu-id="b2eac-190">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

![ドローン リポジトリの図](../images/repository.png)

<span data-ttu-id="b2eac-192">一方、マイクロサービス アーキテクチャでは、サービスは同じコード ベースを共有せず、データ ストアを共有しません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-192">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="b2eac-193">代わりに、API を介して通信します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-193">Instead, they communicate through APIs.</span></span> <span data-ttu-id="b2eac-194">スケジューラ サービスがドローン サービスにドローンに関する情報を要求する場合を考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="b2eac-194">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="b2eac-195">ドローン サービスには、コードで表現されたドローンの内部モデルがあります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-195">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="b2eac-196">ただし、スケジューラにはそれが見えません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-196">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="b2eac-197">代わりに、ドローン エンティティ &mdash; の*表現* (JSON オブジェクトなど) を HTTP 応答で返します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-197">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![ドローン サービスの図](../images/ddd-rest.png)

<span data-ttu-id="b2eac-199">スケジューラ サービスは、ドローン サービスの内部モデルを変更できません。また、ドローン サービスのデータ ストアに書き込むこともできません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-199">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="b2eac-200">つまり、ドローン サービスを実装するコードでは、従来のモノリシック コードと比較して公開される表面領域が小さくなります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-200">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="b2eac-201">ドローン サービスで Location クラスが定義されている場合、そのクラスのスコープは制限されています。そのため、他のサービスはそのクラスを直接使用しません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-201">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span>

<span data-ttu-id="b2eac-202">これらの理由から、このガイダンスは、戦術的な DDD パターンに関連するコーディング方法にあまり焦点を当てていません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-202">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="b2eac-203">ただし、REST API を使用して多くの DDD パターンをモデル化することもできます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-203">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span>

<span data-ttu-id="b2eac-204">例: </span><span class="sxs-lookup"><span data-stu-id="b2eac-204">For example:</span></span>

- <span data-ttu-id="b2eac-205">集約は、REST 内の*リソース*に自然にマップされます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-205">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="b2eac-206">たとえば、Delivery の集約は Delivery API によってリソースとして公開されます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-206">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="b2eac-207">集約は一貫性の境界です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-207">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="b2eac-208">集約に対する操作で、集約が矛盾した状態にならないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-208">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="b2eac-209">そのため、クライアントが集約の内部状態を操作できるような API は作成しないでください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-209">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="b2eac-210">代わりに、リソースとして集約を公開する粗い API を優先します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-210">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="b2eac-211">エンティティには固有の ID があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-211">Entities have unique identities.</span></span> <span data-ttu-id="b2eac-212">REST のリソースには URL 形式の一意の識別子があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-212">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="b2eac-213">エンティティのドメイン ID に対応するリソース URL を作成します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-213">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="b2eac-214">URL からドメイン ID へのマッピングは、クライアントに対して非透過にすることができます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-214">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="b2eac-215">集約の子エンティティには、ルート エンティティからたどって到達することができます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-215">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="b2eac-216">[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) の原則に従うと、親エンティティの表現のリンクを介して子エンティティに到達することができます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-216">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span>

- <span data-ttu-id="b2eac-217">値オブジェクトは不変なので、値オブジェクト全体を置き換えることで更新が実行されます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-217">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="b2eac-218">REST では、PUT または PATCH 要求を使用して更新を実装します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-218">In REST, implement updates through PUT or PATCH requests.</span></span>

- <span data-ttu-id="b2eac-219">クライアントはリポジトリを使用して、コレクション内のオブジェクトを照会、追加、または削除して、基になるデータ ストアの詳細を抽象化できます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-219">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="b2eac-220">REST では、コレクションを照会するメソッド、またはコレクションに新しいエンティティを追加するメソッドを使用して、コレクションを個別のリソースにすることができます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-220">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="b2eac-221">API を設計する場合は、モデル内のデータだけでなく、ビジネス操作やデータの制約など、ドメイン モデルの表現方法について考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-221">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="b2eac-222">DDD の概念</span><span class="sxs-lookup"><span data-stu-id="b2eac-222">DDD concept</span></span> | <span data-ttu-id="b2eac-223">同等の REST</span><span class="sxs-lookup"><span data-stu-id="b2eac-223">REST equivalent</span></span> | <span data-ttu-id="b2eac-224">例</span><span class="sxs-lookup"><span data-stu-id="b2eac-224">Example</span></span> |
|-------------|-----------------|---------|
| <span data-ttu-id="b2eac-225">集約</span><span class="sxs-lookup"><span data-stu-id="b2eac-225">Aggregate</span></span> | <span data-ttu-id="b2eac-226">リソース</span><span class="sxs-lookup"><span data-stu-id="b2eac-226">Resource</span></span> | `{ "1":1234, "status":"pending"... }` |
| <span data-ttu-id="b2eac-227">ID</span><span class="sxs-lookup"><span data-stu-id="b2eac-227">Identity</span></span> | <span data-ttu-id="b2eac-228">URL</span><span class="sxs-lookup"><span data-stu-id="b2eac-228">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="b2eac-229">子エンティティ</span><span class="sxs-lookup"><span data-stu-id="b2eac-229">Child entities</span></span> | <span data-ttu-id="b2eac-230">リンク</span><span class="sxs-lookup"><span data-stu-id="b2eac-230">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="b2eac-231">値オブジェクトの更新</span><span class="sxs-lookup"><span data-stu-id="b2eac-231">Update value objects</span></span> | <span data-ttu-id="b2eac-232">PUT または PATCH</span><span class="sxs-lookup"><span data-stu-id="b2eac-232">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="b2eac-233">リポジトリ</span><span class="sxs-lookup"><span data-stu-id="b2eac-233">Repository</span></span> | <span data-ttu-id="b2eac-234">コレクション</span><span class="sxs-lookup"><span data-stu-id="b2eac-234">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |

## <a name="api-versioning"></a><span data-ttu-id="b2eac-235">API のバージョン管理</span><span class="sxs-lookup"><span data-stu-id="b2eac-235">API versioning</span></span>

<span data-ttu-id="b2eac-236">API は、サービスとそのサービスのクライアントまたはコンシューマー間のコントラクトです。</span><span class="sxs-lookup"><span data-stu-id="b2eac-236">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="b2eac-237">API が変更された場合、外部クライアントか他のマイクロサービスかにかかわらず、API に依存するクライアントが中断する危険があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-237">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="b2eac-238">そのため、API の変更回数を最小限に抑えることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-238">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="b2eac-239">多くの場合、基になる実装の変更で API を変更する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="b2eac-239">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="b2eac-240">ただし現実的には、どこかの時点で、既存の API の変更が必要になる新しい特徴や新しい機能を追加する必要が出てきます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-240">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="b2eac-241">可能な限り、API の変更を下位互換にします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-241">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="b2eac-242">たとえば、モデルからフィールドを削除することは避けます。フィールドが存在すると想定しているクライアントが中断する可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="b2eac-242">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="b2eac-243">フィールドを追加しても互換性は損なわれません。クライアントは応答の理解できないフィールドを無視するためです。</span><span class="sxs-lookup"><span data-stu-id="b2eac-243">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="b2eac-244">ただし、サービスでは、古いクライアントが要求の新しいフィールドを省略した場合に対応する必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-244">However, the service must handle the case where an older client omits the new field in a request.</span></span>

<span data-ttu-id="b2eac-245">API コントラクトのバージョン管理をサポートします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-245">Support versioning in your API contract.</span></span> <span data-ttu-id="b2eac-246">API の重大な変更を導入する場合は、新しい API バージョンに変更してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-246">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="b2eac-247">以前のバージョンを引き続きサポートし、クライアントが呼び出すバージョンを選択できるようにします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-247">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="b2eac-248">これを行うにはいくつかの方法があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-248">There are a couple of ways to do this.</span></span> <span data-ttu-id="b2eac-249">1 つは、単に両方のバージョンを同じサービスで公開する方法です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-249">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="b2eac-250">もう 1 つは、サービスの 2 つのバージョンを並行して実行し、HTTP ルーティング ルールに基づいて要求を一方または別のバージョンにルーティングする方法です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-250">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span>

![バージョン管理](../images/versioning.png)

<span data-ttu-id="b2eac-252">開発者の時間、テスト、および運用上のオーバーヘッドの観点から、複数のバージョンをサポートするには、コストがかかります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-252">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="b2eac-253">そのため、できるだけ早く古いバージョンを非推奨にすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-253">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="b2eac-254">内部 API の場合、API を所有するチームは他のチームと協力して新しいバージョンに移行することができます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-254">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="b2eac-255">このような場合に、チーム間のガバナンス プロセスを持つことが有効です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-255">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="b2eac-256">外部 (パブリック) API の場合、特に API がサードパーティまたはネイティブ クライアント アプリケーションによって使用されている場合、API バージョンを非推奨にすることは困難です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-256">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span>

<span data-ttu-id="b2eac-257">サービスの実装が変更されると、その変更をバージョンでタグ付けすると便利です。</span><span class="sxs-lookup"><span data-stu-id="b2eac-257">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="b2eac-258">このバージョンでは、エラーのトラブルシューティングに重要な情報が提供されます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-258">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="b2eac-259">根本原因解析で、呼び出されたサービスのバージョンを正確に把握する場合に非常に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="b2eac-259">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="b2eac-260">サービス バージョンに[セマンティック バージョン管理](https://semver.org/)を使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-260">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="b2eac-261">セマンティックなバージョン管理は、*MAJOR.MINOR.PATCH* 形式を使用します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-261">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="b2eac-262">ただし、クライアントは、メジャー バージョン番号の API のみを選択することが推奨されます。マイナー バージョン間で重大な (中断されない) 変更があった場合にのみ、マイナー バージョンを選択します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-262">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="b2eac-263">つまり、クライアントが API のバージョン 1 またはバージョン 2 を選択するのは合理的ですが、バージョン 2.1.3 は選択しないようにします。</span><span class="sxs-lookup"><span data-stu-id="b2eac-263">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="b2eac-264">そのレベルの粒度を許可すると、バージョン数の増加をサポートする必要があります。</span><span class="sxs-lookup"><span data-stu-id="b2eac-264">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span>

<span data-ttu-id="b2eac-265">API のバージョン管理の詳細については、[RESTful Web API のバージョン管理](../../best-practices/api-design.md#versioning-a-restful-web-api)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="b2eac-265">For further discussion of API versioning, see [Versioning a RESTful web API](../../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

## <a name="next-steps"></a><span data-ttu-id="b2eac-266">次の手順</span><span class="sxs-lookup"><span data-stu-id="b2eac-266">Next steps</span></span>

<span data-ttu-id="b2eac-267">クライアント アプリケーションとマイクロサービスとの間の境界で API ゲートウェイを使用することについて説明します。</span><span class="sxs-lookup"><span data-stu-id="b2eac-267">Learn about using an API gateway at the boundary between client applications and microservices.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="b2eac-268">API ゲートウェイ</span><span class="sxs-lookup"><span data-stu-id="b2eac-268">API gateways</span></span>](./gateway.md)
