# <a name="choosing-a-compute-option-for-microservices"></a><span data-ttu-id="adf27-101">マイクロサービス用のコンピューティング オプションの選択</span><span class="sxs-lookup"><span data-stu-id="adf27-101">Choosing a compute option for microservices</span></span>

<span data-ttu-id="adf27-102">"*コンピューティング*" という用語は、アプリケーションがそこで実行されるコンピューティング リソースのホスティング モデルを指します。</span><span class="sxs-lookup"><span data-stu-id="adf27-102">The term *compute* refers to the hosting model for the computing resources that your application runs on.</span></span> <span data-ttu-id="adf27-103">マイクロサービス アーキテクチャでは、2 つのアプローチが特によく使われます。</span><span class="sxs-lookup"><span data-stu-id="adf27-103">For a microservices architecture, two approaches are especially popular:</span></span>

- <span data-ttu-id="adf27-104">専用のノード (VM) で実行されるサービスを管理するサービス オーケストレーター。</span><span class="sxs-lookup"><span data-stu-id="adf27-104">A service orchestrator that manages services running on dedicated nodes (VMs).</span></span>
- <span data-ttu-id="adf27-105">サービスとしての関数 (FaaS) を使うサーバーレス アーキテクチャ。</span><span class="sxs-lookup"><span data-stu-id="adf27-105">A serverless architecture using functions as a service (FaaS).</span></span>

<span data-ttu-id="adf27-106">オプションはこれらだけではありませんが、どちらも実証済みのマイクロサービス構築方法です。</span><span class="sxs-lookup"><span data-stu-id="adf27-106">While these aren't the only options, they are both proven approaches to building microservices.</span></span> <span data-ttu-id="adf27-107">1 つのアプリケーションに両方のアプローチが含まれることもあります。</span><span class="sxs-lookup"><span data-stu-id="adf27-107">An application might include both approaches.</span></span>

## <a name="service-orchestrators"></a><span data-ttu-id="adf27-108">サービス オーケストレーター</span><span class="sxs-lookup"><span data-stu-id="adf27-108">Service orchestrators</span></span>

<span data-ttu-id="adf27-109">オーケストレーターは、一連のサービスのデプロイと管理に関連するタスクを処理します。</span><span class="sxs-lookup"><span data-stu-id="adf27-109">An orchestrator handles tasks related to deploying and managing a set of services.</span></span> <span data-ttu-id="adf27-110">ノードへのサービスの配置、サービスの正常性の監視、サービス インスタンス間へのネットワーク トラフィックの負荷分散、サービスの検出、サービスのインスタンスの数のスケーリング、構成の更新の適用などのタスクがあります。</span><span class="sxs-lookup"><span data-stu-id="adf27-110">These tasks include placing services on nodes, monitoring the health of services, restarting unhealthy services, load balancing network traffic across service instances, service discovery, scaling the number of instances of a service, and applying configuration updates.</span></span> <span data-ttu-id="adf27-111">よく使われるオーケストレーターとしては、Kubernetes、Service Fabric、DC/OS、Docker Swarm などがあります。</span><span class="sxs-lookup"><span data-stu-id="adf27-111">Popular orchestrators include Kubernetes, Service Fabric, DC/OS, and Docker Swarm.</span></span>

<span data-ttu-id="adf27-112">Azure プラットフォームでは、以下のオプションを検討してください。</span><span class="sxs-lookup"><span data-stu-id="adf27-112">On the Azure platform, consider the following options:</span></span>

- <span data-ttu-id="adf27-113">[Azure Kubernetes Service](/azure/aks/) (AKS) は、マネージド Kubernetes サービスです。</span><span class="sxs-lookup"><span data-stu-id="adf27-113">[Azure Kubernetes Service](/azure/aks/) (AKS) is a managed Kubernetes service.</span></span> <span data-ttu-id="adf27-114">AKS は、Kubernetes をプロビジョニングして Kubernetes API エンドポイントを公開しますが、Kubernetes 制御プレーンをホストして管理し、自動アップグレード、修正プログラムの自動適用、自動スケーリング、その他の管理タスクを実行します。</span><span class="sxs-lookup"><span data-stu-id="adf27-114">AKS provisions Kubernetes and exposes the Kubernetes API endpoints, but hosts and manages the Kubernetes control plane, performing automated upgrades, automated patching, autoscaling, and other management tasks.</span></span> <span data-ttu-id="adf27-115">AKS は、"サービスとしての Kubernetes API" と考えることができます。</span><span class="sxs-lookup"><span data-stu-id="adf27-115">You can think of AKS as being "Kubernetes APIs as a service."</span></span>

- <span data-ttu-id="adf27-116">[Service Fabric](/azure/service-fabric/) は、マイクロサービスのパッケージ化、デプロイ、管理を行うための分散システム プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="adf27-116">[Service Fabric](/azure/service-fabric/) is a distributed systems platform for packaging, deploying, and managing microservices.</span></span> <span data-ttu-id="adf27-117">マイクロサービスは、コンテナー、バイナリ実行可能ファイル、または [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction) として Service Fabric にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="adf27-117">Microservices can be deployed to Service Fabric as containers, as binary executables, or as [Reliable Services](/azure/service-fabric/service-fabric-reliable-services-introduction).</span></span> <span data-ttu-id="adf27-118">Reliable Services プログラミング モデルを使うと、サービスは Service Fabric プログラミング API を直接使って、システムのクエリ、正常性のレポート、構成とコードの変更に関する通知の受信、他のサービスの検出を行うことができます。</span><span class="sxs-lookup"><span data-stu-id="adf27-118">Using the Reliable Services programming model, services can directly use Service Fabric programming APIs to query the system, report health, receive notifications about configuration and code changes, and discover other services.</span></span> <span data-ttu-id="adf27-119">Service Fabric に関する重要な違いは、Service Fabric では [Reliable Collection](/azure/service-fabric/service-fabric-reliable-services-reliable-collections) を使うステートフル サービスの構築が重視されていることです。</span><span class="sxs-lookup"><span data-stu-id="adf27-119">A key differentiation with Service Fabric is its strong focus on building stateful services using [Reliable Collections](/azure/service-fabric/service-fabric-reliable-services-reliable-collections).</span></span>

- <span data-ttu-id="adf27-120">[Azure Container Service](/azure/container-service/) (ACS) は、運用環境に対応した DC/OS、Docker Swarm、または Kubernetes クラスターをデプロイできる Azure サービスです。</span><span class="sxs-lookup"><span data-stu-id="adf27-120">[Azure Container Service](/azure/container-service/) (ACS) is an Azure service that lets you deploy a production-ready DC/OS, Docker Swarm, or Kubernetes cluster.</span></span>

  > [!NOTE]
  > <span data-ttu-id="adf27-121">ACS では Kubernetes をサポートしていますが、AKS を使用して Azure 上で Kubernetes を実行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="adf27-121">Although ACS supports Kubernetes, we recommended using AKS to run Kubernetes on Azure.</span></span> <span data-ttu-id="adf27-122">AKS を使用すると、強化された管理機能とコスト面の利点を得ることができます。</span><span class="sxs-lookup"><span data-stu-id="adf27-122">AKS provides enhanced management capabilities and cost benefits.</span></span>

## <a name="containers"></a><span data-ttu-id="adf27-123">Containers</span><span class="sxs-lookup"><span data-stu-id="adf27-123">Containers</span></span>

<span data-ttu-id="adf27-124">コンテナーとマイクロサービスは同じものであるかのように言われることがあります。</span><span class="sxs-lookup"><span data-stu-id="adf27-124">Sometimes people talk about containers and microservices as if they were the same thing.</span></span> <span data-ttu-id="adf27-125">それは正しくありませんが (マイクロサービスを構築するためにコンテナーは必要ありません)、コンテナーの次のような利点はマイクロサービスに特に関連があります。</span><span class="sxs-lookup"><span data-stu-id="adf27-125">While that's not true &mdash; you don't need containers to build microservices &mdash; containers do have some benefits that are particularly relevant to microservices, such as:</span></span>

- <span data-ttu-id="adf27-126">**移植性**。</span><span class="sxs-lookup"><span data-stu-id="adf27-126">**Portability**.</span></span> <span data-ttu-id="adf27-127">コンテナー イメージは、ライブラリや他の依存関係をインストールする必要なしに実行するスタンドアロン パッケージです。</span><span class="sxs-lookup"><span data-stu-id="adf27-127">A container image is a standalone package that runs without needing to install libraries or other dependencies.</span></span> <span data-ttu-id="adf27-128">そのため簡単にデプロイできます。</span><span class="sxs-lookup"><span data-stu-id="adf27-128">That makes them easy to deploy.</span></span> <span data-ttu-id="adf27-129">コンテナーはすばやく開始および停止できるので、高い負荷の処理やノード障害からの復旧のために新しいインスタンスを開始できます。</span><span class="sxs-lookup"><span data-stu-id="adf27-129">Containers can be started and stopped quickly, so you can spin up new instances to handle more load or to recover from node failures.</span></span>

- <span data-ttu-id="adf27-130">**密度**。</span><span class="sxs-lookup"><span data-stu-id="adf27-130">**Density**.</span></span> <span data-ttu-id="adf27-131">コンテナーは OS リソースを共有しているため、仮想マシンの実行と比較して軽量です。</span><span class="sxs-lookup"><span data-stu-id="adf27-131">Containers are lightweight compared with running a virtual machine, because they share OS resources.</span></span> <span data-ttu-id="adf27-132">そのため、複数のコンテナーを単一のノードに収めることができ、アプリケーションが多数の小さいサービスで構成される場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="adf27-132">That makes it possible to pack multiple containers onto a single node, which is especially useful when the application consists of many small services.</span></span>

- <span data-ttu-id="adf27-133">**リソースの分離**。</span><span class="sxs-lookup"><span data-stu-id="adf27-133">**Resource isolation**.</span></span> <span data-ttu-id="adf27-134">コンテナーで利用できるメモリと CPU の量を制限することができ、ランナウェイ プロセスによってホストのリソースがすべて使われないようにするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="adf27-134">You can limit the amount of memory and CPU that is available to a container, which can help to ensure that a runaway process doesn't exhaust the host resources.</span></span> <span data-ttu-id="adf27-135">詳しくは、「[Bulkhead pattern](../../patterns/bulkhead.md)」 (バルクヘッド パターン) をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="adf27-135">See the [Bulkhead pattern](../../patterns/bulkhead.md) for more information.</span></span>

## <a name="serverless-functions-as-a-service"></a><span data-ttu-id="adf27-136">サーバーレス (サービスとしての関数)</span><span class="sxs-lookup"><span data-stu-id="adf27-136">Serverless (Functions as a Service)</span></span>

<span data-ttu-id="adf27-137">[サーバーレス](https://azure.microsoft.com/solutions/serverless/) アーキテクチャでは、ユーザーは VM や仮想ネットワーク インフラストラクチャを管理しません。</span><span class="sxs-lookup"><span data-stu-id="adf27-137">With a [serverless](https://azure.microsoft.com/solutions/serverless/) architecture, you don't manage the VMs or the virtual network infrastructure.</span></span> <span data-ttu-id="adf27-138">代わりに、ユーザーがコードをデプロイすると、ホスティング サービスがそのコードを VM 上に配置して実行します。</span><span class="sxs-lookup"><span data-stu-id="adf27-138">Instead, you deploy code and the hosting service handles putting that code onto a VM and executing it.</span></span> <span data-ttu-id="adf27-139">このアプローチには、イベント ベースのトリガーを使って調整される小さく細分化された関数が適しています。</span><span class="sxs-lookup"><span data-stu-id="adf27-139">This approach tends to favor small granular functions that are coordinated using event-based triggers.</span></span> <span data-ttu-id="adf27-140">たとえば、メッセージがキューに配置されると、メッセージをキューから読み取って処理する関数がトリガーされるような場合です。</span><span class="sxs-lookup"><span data-stu-id="adf27-140">For example, a message being placed onto a queue might trigger a function that reads from the queue and processes the message.</span></span>

<span data-ttu-id="adf27-141">[Azure Functions](/azure/azure-functions/) はサーバーレスのコンピューティング サービスであり、HTTP 要求、Service Bus キュー、Event Hubs イベントなど、さまざまな関数トリガーをサポートします。</span><span class="sxs-lookup"><span data-stu-id="adf27-141">[Azure Functions](/azure/azure-functions/) is a serverless compute service that supports various function triggers, including HTTP requests, Service Bus queues, and Event Hubs events.</span></span> <span data-ttu-id="adf27-142">詳しくは、「[Azure Functions でのトリガーとバインドの概念](/azure/azure-functions/functions-triggers-bindings)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="adf27-142">For a complete list, see [Azure Functions triggers and bindings concepts](/azure/azure-functions/functions-triggers-bindings).</span></span> <span data-ttu-id="adf27-143">また、Azure のマネージド イベント ルーティング サービスである [Azure Event Grid](/azure/event-grid/) も検討してください。</span><span class="sxs-lookup"><span data-stu-id="adf27-143">Also consider [Azure Event Grid](/azure/event-grid/), which is a managed event routing service in Azure.</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="orchestrator-or-serverless"></a><span data-ttu-id="adf27-144">オーケストレーターかサーバーレスか</span><span class="sxs-lookup"><span data-stu-id="adf27-144">Orchestrator or serverless?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="adf27-145">オーケストレーター アプローチとサーバーレス アプローチのどちらを選ぶかを検討するときの要因を次に示します。</span><span class="sxs-lookup"><span data-stu-id="adf27-145">Here are some factors to consider when choosing between an orchestrator approach and a serverless approach.</span></span>

<span data-ttu-id="adf27-146">**管理の容易性**。サーバーレス アプリケーションは、プラットフォームがすべてのコンピューティング リソースを管理するので、管理が容易です。</span><span class="sxs-lookup"><span data-stu-id="adf27-146">**Manageability** A serverless application is easy to manage, because the platform manages all the of compute resources for you.</span></span> <span data-ttu-id="adf27-147">オーケストレーターはクラスターの管理と構成の一部を抽象化しますが、基になる VM を完全には隠ぺいしません。</span><span class="sxs-lookup"><span data-stu-id="adf27-147">While an orchestrator abstracts some aspects of managing and configuring a cluster, it does not completely hide the underlying VMs.</span></span> <span data-ttu-id="adf27-148">オーケストレーターでは、負荷分散、CPU とメモリの使用量、ネットワークなどの問題について、ユーザーが考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="adf27-148">With an orchestrator, you will need to think about issues such as load balancing, CPU and memory usage, and networking.</span></span>

<span data-ttu-id="adf27-149">**柔軟性と制御**。</span><span class="sxs-lookup"><span data-stu-id="adf27-149">**Flexibility and control**.</span></span> <span data-ttu-id="adf27-150">オーケストレーターでは、サービスおよびクラスターの構成と管理の広い範囲をユーザーが制御できます。</span><span class="sxs-lookup"><span data-stu-id="adf27-150">An orchestrator gives you a great deal of control over configuring and managing your services and the cluster.</span></span> <span data-ttu-id="adf27-151">その代わり、複雑さは増します。</span><span class="sxs-lookup"><span data-stu-id="adf27-151">The tradeoff is additional complexity.</span></span> <span data-ttu-id="adf27-152">サーバーレス アーキテクチャでは、詳細が抽象化されているため、ユーザーが制御できない部分があります。</span><span class="sxs-lookup"><span data-stu-id="adf27-152">With a serverless architecture, you give up some degree of control because these details are abstracted.</span></span>

<span data-ttu-id="adf27-153">**移植性**。</span><span class="sxs-lookup"><span data-stu-id="adf27-153">**Portability**.</span></span> <span data-ttu-id="adf27-154">ここで示したすべてのオーケストレーター (Kubernetes、DC/OS、Docker Swarm、Service Fabric) は、オンプレミスで、または複数のパブリック クラウドで実行できます。</span><span class="sxs-lookup"><span data-stu-id="adf27-154">All of the orchestrators listed here (Kubernetes, DC/OS, Docker Swarm, and Service Fabric) can run on-premises or in multiple public clouds.</span></span>

<span data-ttu-id="adf27-155">**アプリケーションの統合**。</span><span class="sxs-lookup"><span data-stu-id="adf27-155">**Application integration**.</span></span> <span data-ttu-id="adf27-156">サーバーレス アーキテクチャを使って複雑なアプリケーションを構築するのは、困難な場合があります。</span><span class="sxs-lookup"><span data-stu-id="adf27-156">It can be challenging to build a complex application using a serverless architecture.</span></span> <span data-ttu-id="adf27-157">Azure での 1 つのオプションは、[Azure Logic Apps](/azure/logic-apps/) を使って Azure Functions のセットを調整することです。</span><span class="sxs-lookup"><span data-stu-id="adf27-157">One option in Azure is to use [Azure Logic Apps](/azure/logic-apps/) to coordinate a set of Azure Functions.</span></span> <span data-ttu-id="adf27-158">このアプローチの例については、「[Azure Logic Apps と統合される関数を作成する](/azure/azure-functions/functions-twitter-email)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="adf27-158">For an example of this approach, see [Create a function that integrates with Azure Logic Apps](/azure/azure-functions/functions-twitter-email).</span></span>

<span data-ttu-id="adf27-159">**コスト**。</span><span class="sxs-lookup"><span data-stu-id="adf27-159">**Cost**.</span></span> <span data-ttu-id="adf27-160">オーケストレーターでは、クラスターで実行している VM の料金がかかります。</span><span class="sxs-lookup"><span data-stu-id="adf27-160">With an orchestrator, you pay for the VMs that are running in the cluster.</span></span> <span data-ttu-id="adf27-161">サーバーレス アプリケーションでは、実際に消費したコンピューティング リソースについてだけ課金されます。</span><span class="sxs-lookup"><span data-stu-id="adf27-161">With a serverless application, you pay only for the actual compute resources consumed.</span></span> <span data-ttu-id="adf27-162">どちらの場合も、記憶域、データベース、メッセージング サービスなど、追加サービスのコストを考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="adf27-162">In both cases, you need to factor in the cost of any additional services, such as storage, databases, and messaging services.</span></span>

<span data-ttu-id="adf27-163">**スケーラビリティ**: </span><span class="sxs-lookup"><span data-stu-id="adf27-163">**Scalability**.</span></span> <span data-ttu-id="adf27-164">Azure Functions は、受信イベントの数に基づき、需要に合わせて自動的にスケーリングします。</span><span class="sxs-lookup"><span data-stu-id="adf27-164">Azure Functions scales automatically to meet demand, based on the number of incoming events.</span></span> <span data-ttu-id="adf27-165">オーケストレーターでは、クラスターで実行するサービス インスタンスの数を増やすことによりスケールアウトできます。</span><span class="sxs-lookup"><span data-stu-id="adf27-165">With an orchestrator, you can scale out by increasing the number of service instances running in the cluster.</span></span> <span data-ttu-id="adf27-166">また、クラスターに VM を追加してスケーリングすることもできます。</span><span class="sxs-lookup"><span data-stu-id="adf27-166">You can also scale by adding additional VMs to the cluster.</span></span>

<span data-ttu-id="adf27-167">この参照実装では主に Kubernetes を使っていますが、配送履歴サービスに対しては Azure Functions を使いました。</span><span class="sxs-lookup"><span data-stu-id="adf27-167">Our reference implementation primarily uses Kubernetes, but we did use Azure Functions for one service, namely the Delivery History service.</span></span> <span data-ttu-id="adf27-168">この特定のサービスはイベント ドリブンのワークロードであるため、Azure Functions が適していました。</span><span class="sxs-lookup"><span data-stu-id="adf27-168">Azure Functions was a good fit for this particular service, because it's is an event-driven workload.</span></span> <span data-ttu-id="adf27-169">Event Hubs のトリガーを使って関数を呼び出すことにより、サービスで必要なコードは最小限の量で済みました。</span><span class="sxs-lookup"><span data-stu-id="adf27-169">By using an Event Hubs trigger to invoke the function, the service needed a minimal amount of code.</span></span> <span data-ttu-id="adf27-170">また、配送履歴サービスはメイン ワークフローの一部ではないので、Kubernetes クラスターの外部で実行しても、ユーザー開始操作のエンド ツー エンドの待機時間には影響がありません。</span><span class="sxs-lookup"><span data-stu-id="adf27-170">Also, the Delivery History service is not part of the main workflow, so running it outside of the Kubernetes cluster doesn't affect the end-to-end latency of user-initiated operations.</span></span>

## <a name="next-steps"></a><span data-ttu-id="adf27-171">次の手順</span><span class="sxs-lookup"><span data-stu-id="adf27-171">Next steps</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="adf27-172">サービス間の通信</span><span class="sxs-lookup"><span data-stu-id="adf27-172">Interservice communication</span></span>](./interservice-communication.md)