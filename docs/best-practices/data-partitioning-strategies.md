---
title: データのパーティション分割戦略
titleSuffix: Best practices for cloud applications
description: 個別に管理およびアクセスするためのデータのパーティションの分離についてのガイダンス。
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 43838592ef4176c28e11b90180727a63b1e1f8f6
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58241823"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="4b6c7-103">データのパーティション分割戦略</span><span class="sxs-lookup"><span data-stu-id="4b6c7-103">Data partitioning strategies</span></span>

<span data-ttu-id="4b6c7-104">この記事では、さまざまな Azure データ ストア内のデータをパーティション分割する際のいくつかの戦略について説明します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="4b6c7-105">データをパーティション分割するタイミングとベスト プラクティスに関する一般的なガイダンスについては、「[データのパーティション分割](./data-partitioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="4b6c7-106">Azure SQL Database のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="4b6c7-107">1 つの SQL データベースには保持できるデータ量に制限があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="4b6c7-108">スループットにはアーキテクチャ上の要因とアーキテクチャがサポートするコンカレント接続数による制約があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="4b6c7-109">[エラスティック プール](/azure/sql-database/sql-database-elastic-pool)は、SQL データベースの水平スケーリングをサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="4b6c7-110">エラスティック プールを使用することで、複数の SQL データベースにまたがってデータをシャードにパーティション分割できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="4b6c7-111">また、処理する必要のあるデータ量が増加または減少する場合にシャードを追加または削除できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="4b6c7-112">さらに、エラスティック プールを使用して負荷をデータベース全体に分散することにより、競合を少なくすることもできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="4b6c7-113">各シャードは、SQL データベースとして実装されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="4b6c7-114">1 つのシャードは、"*シャードレット*" と呼ばれる複数のデータセットを保持できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="4b6c7-115">各データベースは、それが含むシャードレットを定義するメタデータを維持します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="4b6c7-116">シャードレットは、単一のデータ項目にすることも、同じシャードレット キーを共有する項目グループにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="4b6c7-117">たとえば、マルチテナント アプリケーションでは、シャードレット キーをテナント ID にし、テナントのすべてのデータを同じシャードレットに保持することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="4b6c7-118">クライアント アプリケーションが、データセットをシャードレット キーに関連付ける役割を担います。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="4b6c7-119">個別の SQL データベースは、グローバル シャード マップ マネージャーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="4b6c7-120">このデータベースには、システム内のすべてのシャードとシャードレットの一覧があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="4b6c7-121">アプリケーションは、シャード マップ マネージャー データベースに接続してシャード マップのコピーを取得します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="4b6c7-122">次に、シャード マップをローカルにキャッシュし、このマップを使用して適切なシャードにデータ要求をルーティングします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="4b6c7-123">この機能は、Java と .NET で利用できる [Elastic Database クライアント ライブラリ](/azure/sql-database/sql-database-elastic-database-client-library)に含まれる一連の API の背後に隠されています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="4b6c7-124">エラスティック プールの詳細については、「[Azure SQL Database によるスケール アウト](/azure/sql-database/sql-database-elastic-scale-introduction)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="4b6c7-125">遅延を小さくし、可用性を高めるには、グローバル シャード マップ マネージャー データベースをレプリケートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="4b6c7-126">Premium 価格レベルを使用すると、アクティブ geo レプリケーションを構成して、データを異なるリージョン内のデータベースに連続してコピーできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="4b6c7-127">または、[Azure SQL データ同期](/azure/sql-database/sql-database-sync-data)か [Azure Data Factory](/azure/data-factory/) を使用して、リージョン間でシャード マップ マネージャー データベースをレプリケートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="4b6c7-128">この形態のレプリケーションは定期的に実行され、シャード マップの変更がまれな場合に適しています。Premium レベルは不要です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="4b6c7-129">Elastic Database では、データをシャードレットにマップし、シャードに格納するために、2 つの構成を利用できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="4b6c7-130">**リスト シャード マップ**は、1 つのキーをシャードレットに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="4b6c7-131">たとえば、マルチテナント システムで、各テナント用のデータを一意のキーに関連付けて、独自のシャードレットに格納することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="4b6c7-132">分離されていることを保証するには、各シャードレットをそれ自身のシャード内に保持します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![リスト シャード マップを使用してテナント データを個別のシャードに格納](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="4b6c7-134">**範囲シャード マップ**は、連続するキー値のセットをシャードレットに関連付けます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="4b6c7-135">たとえば、同じシャードレット内に一連のテナント (それぞれが独自のキーを持つ) のデータをグループ化できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="4b6c7-136">この構成は、各テナントがデータ ストレージを共有するため 1 つ目の構成よりも安価ですが、分離性は緩やかになります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![範囲シャードマップを使用してある範囲のテナントのデータを 1 つのシャードに格納](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="4b6c7-138">単一のシャードに複数のシャードレットのデータを含めることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="4b6c7-139">たとえば、リスト シャードレットを使用してさまざまな非連続テナントのデータを同一のシャードに格納できることがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="4b6c7-140">同一のシャード内で範囲シャードレットとリスト シャードレットを混在させることもできます。ただし、それぞれは、別のマップを介してアドレス指定されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="4b6c7-141">この手法を次の図に示します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-141">The following diagram shows this approach:</span></span>

![複数のシャード マップの実装](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="4b6c7-143">エラスティック プールを使用すると、データ量の増減に合わせて、シャードを追加または削除できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="4b6c7-144">クライアント アプリケーションでは、シャードを動的に作成および削除し、シャード マップ マネージャーを透過的に更新することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="4b6c7-145">ただし、シャードを削除する操作は、そのシャード内のすべてのデータの削除を要求する破壊的な操作です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="4b6c7-146">アプリケーションで、1 つのシャードを 2 つのシャードに分割する、または複数のシャードを結合する必要がある場合は、[Split-Merge ツール](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge)を使用します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="4b6c7-147">これは、Azure の Web サービスとして実行され、シャード間で安全にデータを移行するツールです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="4b6c7-148">パーティション分割構成は、システムのパフォーマンスに大きく影響します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-148">The partitioning scheme can significantly affect the performance of your system.</span></span> <span data-ttu-id="4b6c7-149">また、シャードの追加/削除の頻度、またはシャード間でデータを再パーティション分割する必要がある頻度にも影響を及ぼします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="4b6c7-150">次の点を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-150">Consider the following points:</span></span>

- <span data-ttu-id="4b6c7-151">一緒に使用するデータを同一のシャードにグループ化し、複数のシャードのデータにアクセスする操作が発生しないようにします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="4b6c7-152">シャードは、それ自体が SQL データベースであるため、データベース間結合はクライアント側で実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="4b6c7-153">SQL Database はデータベース間結合をサポートしませんが、Elastic Database ツールを使用すると、[マルチシャード クエリ](/azure/sql-database/sql-database-elastic-scale-multishard-querying)を実行できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [mutli-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="4b6c7-154">マルチシャード クエリでは、各データベースに個々のクエリを送信し、結果をマージします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="4b6c7-155">シャード間に依存関係のあるシステムを設計しないでください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="4b6c7-156">1 つのデータベース内の参照整合性制約、トリガー、およびストアド プロシージャは、別のデータベースのオブジェクトを参照できません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="4b6c7-157">クエリによって頻繁に使用される参照データがある場合は、シャード間でこのデータをレプリケートすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="4b6c7-158">この手法に従うと、データベース間でデータを結合する必要がなくなります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="4b6c7-159">理想的には、レプリケーションの負荷を最小にしたり、無効となる可能性を減らしたりするには、そのようなデータが静的であるか移動頻度が低いものである必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="4b6c7-160">同じシャードマップに属するシャードレットは、同じスキーマを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="4b6c7-161">このルールは SQL Database によって強制されませんが、各シャードレットに異なるスキーマが存在すると、データ管理とクエリが非常に複雑になります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="4b6c7-162">代わりに、スキーマごとに個別のシャード マップを作成します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="4b6c7-163">異なるシャードレットに属するデータを、同じシャードに格納できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="4b6c7-164">トランザクション操作は、1 つのシャード内のデータを対象にする場合にのみサポートされます。シャード間ではサポートされません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="4b6c7-165">トランザクションは、シャードレットをまたがってデータにアクセスできますが、シャードレットが同一のシャードに属する場合に限られます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="4b6c7-166">このため、ビジネス ロジックがトランザクションを実行する必要がある場合、データを同一のシャードに格納するか、または最終的な整合性を実装します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="4b6c7-167">シャードを、シャードのデータにアクセスするユーザーの近くに配置します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="4b6c7-168">この戦略は、遅延を小さくするのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="4b6c7-169">アクセス頻度の非常に高いシャードと低いシャードが混在しないようにします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="4b6c7-170">シャード間で負荷が均等に分散されるようにします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="4b6c7-171">これを行うには、シャーディング キーのハッシュ処理が必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="4b6c7-172">geo 配置シャードを実装する場合、ハッシュ処理されたキーが、データにアクセスするユーザーの近くに格納されているシャードに保持されているシャードレットにマッピングすることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="4b6c7-173">Azure Table Storage のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="4b6c7-174">Azure Table Storage は、パーティション分割に対応するように設計されたキーと値のストアです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="4b6c7-175">すべてのエンティティは、パーティションに格納され、パーティションは Azure Table Storage によって内部的に管理されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="4b6c7-176">テーブルに格納される各エンティティは、次の 2 つの部分で構成されるキーを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="4b6c7-177">**パーティション キー**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-177">**The partition key**.</span></span> <span data-ttu-id="4b6c7-178">これは文字列値で、Azure Table Storage がこのエンティティを配置するパーティションを決定するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="4b6c7-179">同じパーティション キーを持つすべてのエンティティが、同じパーティションに格納されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="4b6c7-180">**行キー**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-180">**The row key**.</span></span> <span data-ttu-id="4b6c7-181">これは文字列値で、パーティション内のエンティティを識別します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="4b6c7-182">パーティション内のすべてのエンティティは、このキーの昇順で辞書的に並び替えられます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="4b6c7-183">パーティション キーと行キーの組み合わせは、各エンティティで一意になる必要があり、1 KB の長さを超えることはできません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="4b6c7-184">以前に使用されていないパーティション キーを使用してエンティティがテーブルに追加される場合、Azure Table Storage はこのエンティティ用に新しいパーティションを作成します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="4b6c7-185">同じパーティション キーを持つ別のエンティティは、同じパーティションに格納されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="4b6c7-186">このメカニズムは、自動スケールアウト戦略を効果的に実装します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="4b6c7-187">各パーティションは、単一パーティションからデータを取得するクエリが高速に実行できるようにするために、Azure データセンターの同じサーバーに格納されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="4b6c7-188">Microsoft は、Azure Storage の[スケーラビリティ ターゲット]を公表しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="4b6c7-189">システムがこれらの制限を超過する可能性がある場合は、エンティティを複数のテーブルに分割することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="4b6c7-190">垂直的パーティション分割を使用し、フィールドを最も一緒にアクセスされる頻度の高いグループに分割します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="4b6c7-191">次の図は、サンプル ストレージ アカウントの論理構造を示しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="4b6c7-192">このストレージ アカウントには、3 つのテーブル(Customer Info、Product Info、および Order Info) が含まれています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![サンプル ストレージ アカウントのテーブルとパーティション](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="4b6c7-194">各テーブルには複数のパーティションがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="4b6c7-195">Customer Info テーブルでは、データは顧客の所在地の市に従ってパーティション分割されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="4b6c7-196">行キーには、顧客 ID が含まれます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="4b6c7-197">Product Info テーブルでは、製品が製品カテゴリによってパーティション分割され、行キーには製品番号が含まれます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="4b6c7-198">Order Info テーブルでは、注文が注文日によってパーティション分割され、行キーには、注文が受信された時刻が指定されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="4b6c7-199">すべてのデータは、各パーティションで行キーの順に並べられることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="4b6c7-200">Azure Table Storage 用にエンティティを設計する際には、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="4b6c7-201">データへのアクセス方法によって、パーティション キーと行キーを選択します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="4b6c7-202">パーティション キーと行キーの組み合わせは、クエリの大半をサポートするように選択する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="4b6c7-203">最も効率的にクエリを実行するには、パーティション キーと行キーを指定してデータを取得します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="4b6c7-204">パーティション キーと行キーの範囲を指定するクエリは、単一のパーティションをスキャンすることによって完了できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="4b6c7-205">データは行キーの順序で並んでいるため、このクエリは比較的高速に実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="4b6c7-206">スキャンするパーティションがクエリで指定されていない場合は、すべてのパーティションをスキャンする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="4b6c7-207">エンティティにナチュラル キーが含まれている場合、それをパーティション キーとして使用し、空の文字列を行キーとして指定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="4b6c7-208">エンティティに 2 つのプロパティで構成される複合キーがある場合、変化の少ない方のプロパティをパーティション キーとして選択し、別のプロパティを行キーとして指定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="4b6c7-209">エンティティに 3 つ以上のキー プロパティがある場合、プロパティの連結を使用して、パーティション キーと行キーを指定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="4b6c7-210">パーティション キーおよび行キー以外のフィールドを使用してデータを検索するクエリを定期的に実行する場合、[インデックス テーブル パターン](../patterns/index-table.md)を使用することを検討するか、Cosmos DB などのインデックス付けをサポートする別のデータ ストアを使用することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="4b6c7-211">単純数列 ("0001"、"0002"、"0003" など) を使用してパーティション キーを生成する場合で、各パーティションには少量のデータしか含まれない場合、Azure Table Storage は、これらのパーティションを物理的にグループ化して、同一のサーバーに配置することがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="4b6c7-212">Azure Storage では、アプリケーションはパーティションの連続した範囲を対象にするクエリ (範囲クエリ) を実行する可能性が最も高いと想定して、このような状況向けに最適化しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="4b6c7-213">ただし、この手法では、新しいエンティティのすべての挿入操作が、連続する範囲の 1 つの末尾に集中する可能性があるので、ホットスポットを発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="4b6c7-214">また、拡張性が損なわれる可能性もあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-214">It can also reduce scalability.</span></span> <span data-ttu-id="4b6c7-215">負荷をさらに均等に分散するには、パーティション キーのハッシュ処理を検討してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="4b6c7-216">Azure Table Storage は、同一パーティションに属するエンティティに対するトランザクション操作をサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="4b6c7-217">アプリケーションは、トランザクションに含まれるエントリが 100 個以下で、要求のペイロードが 4 MB を超えない場合、複数の挿入、更新、削除、置換、またはマージの操作を 1 つのアトミック単位として実行できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="4b6c7-218">複数のパーティションにまたがる操作はトランザクションとしてはサポートされません。また、最終的な整合性を実装することが必要になることがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="4b6c7-219">テーブル ストレージとトランザクションの詳細については、「[Performing entity group transactions (エンティティ グループ トランザクションの実行)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="4b6c7-220">パーティション キーの粒度に配慮してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="4b6c7-221">すべてのエンティティで同じパーティション キーを使用すると、1 つのサーバーに 1 つのパーティションを保持することになります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="4b6c7-222">これにより、パーティションでスケールアウトが機能しなくなり、負荷が単一のサーバーに集中します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="4b6c7-223">結論として、この手法が適しているのは、少量のエンティティを格納している場合のみです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="4b6c7-224">ただし、すべてのエンティティをエンティティ グループ トランザクションの対象にすることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="4b6c7-225">各エンティティに対して一意のパーティション キーを使用すると、Table Storage サービスにより、各エンティティに異なるパーティションが作成され、結果として、小さなパーティションが大量に作成される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="4b6c7-226">この手法は、単一パーティション キーの手法よりも拡張性に優れていますが、エンティティ グループ トランザクションは使用できません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="4b6c7-227">また、複数のエンティティをフェッチするクエリが複数のサーバーからの読み込みを実行する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="4b6c7-228">ただし、アプリケーションが範囲クエリを実行する場合、パーティション キーに単純数列を使用すると、これらのクエリの最適化に役立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="4b6c7-229">一部のエンティティト間でパーティション キーを共有すると、関連するエンティティをグループ化して同一のパーティションに格納できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="4b6c7-230">関連するエンティティにアクセスする操作は、エンティティ グループ トランザクションを使用して実行でき、一連の関連するエンティティをフェッチするクエリは単一サーバーにアクセスするだけで結果が返される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="4b6c7-231">詳細については、[Azure ストレージ テーブルの設計ガイド]に関するページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="4b6c7-232">Azure Blob Storage のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="4b6c7-233">Azure Blob Storage を使用すると、大きなバイナリ オブジェクトを保持できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="4b6c7-234">大量のデータを高速にアップロードまたはダウンロードする必要があるシナリオでは、ブロック BLOB を使用します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="4b6c7-235">データの一部への順次アクセスではなくランダム アクセスを必要とするアプリケーションでは、ページ BLOB を使用します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="4b6c7-236">ブロック BLOB とページ BLOB のいずれも、Azure ストレージ アカウントのコンテナーに保持されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="4b6c7-237">コンテナーを使用することにより、同じセキュリティ要件を持つ関連する BLOB をグループ化することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="4b6c7-238">このグループ化は、物理的ではなく、論理的です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="4b6c7-239">コンテナー内では、各 BLOB は一意の名前を持ちます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="4b6c7-240">BLOB のパーティション キーは、アカウント名とコンテナー名と BLOB 名を組み合わせたものです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="4b6c7-241">データを範囲にパーティション分割するには、パーティション キーが使用されます。これらの範囲はシステム全体にわたって負荷分散されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="4b6c7-242">BLOB は、アクセスをスケールアウトするために多数のサーバーに分散させることができますが、1 つの BLOB を処理できるのは 1 台のサーバーのみです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="4b6c7-243">名前付けスキームでタイムスタンプまたは数値識別子を使用すると、1 つのパーティションに過剰なトラフィックが送信され、システムの効果的な負荷分散が制限される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="4b6c7-244">たとえば、*yyyy-mm-dd* などのタイムスタンプを持つ BLOB オブジェクトを使用する毎日の操作がある場合、その操作に対するすべてのトラフィックが、1 つのパーティション サーバーに送信されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="4b6c7-245">代わりに、名前の前に 3 桁のハッシュを付けることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="4b6c7-246">詳細については、「[パーティションの命名規則](/azure/storage/common/storage-performance-checklist#subheading47)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="4b6c7-247">単一のブロックまたはページを書き込む操作はアトミックですが、複数のブロック、ページ、または BLOB にまたがる操作はアトミックではありません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="4b6c7-248">複数のブロック、ページ、または BLOB にまたがる書き込み操作の実行中に一貫性を確保するには、BLOB リースを使用して書き込みロックを取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="4b6c7-249">Azure ストレージ キューのパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="4b6c7-250">Azure ストレージ キューを使用すると、プロセス間の非同期メッセージ処理を実装できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="4b6c7-251">Azure ストレージ アカウントは任意の数のキューを含むことができ、各キューは任意の数のメッセージを含むことができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="4b6c7-252">唯一の制限は、ストレージ アカウントで利用できる領域です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="4b6c7-253">個々のメッセージの最大サイズは、64 KB です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="4b6c7-254">このサイズよりも大きいメッセージを必要とする場合は、代わりに Azure Service Bus キューの使用を検討します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="4b6c7-255">各ストレージ キューは、それを含むストレージ アカウント内で一意の名前を持ちます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="4b6c7-256">Azure はこの名前に基づいてキューをパーティション分割します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="4b6c7-257">同じキューのすべてのメッセージは同一のパーティションに格納され、単一のサーバーにより制御されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="4b6c7-258">負荷を均等化するために、キューごとに異なるサーバーで管理することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="4b6c7-259">サーバーへのキューの割り当ては、アプリケーションおよびユーザーにとって透過的です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="4b6c7-260">大規模なアプリケーションでは、アプリケーションのすべてのインスタンスに対して同一のストレージ キューを使用しないでください。この手法では、キューをホストするサーバーがホットスポットになる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="4b6c7-261">代わりに、アプリケーションの機能分野ごとに異なるキューを使用してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="4b6c7-262">Azure ストレージ キューはトランザクションをサポートしません。このため、メッセージを別のキューに転送することは、メッセージ処理の一貫性にほとんど影響を与えません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-262">Azure storage queues do not support transactions, so directing messages to different queues should have little effect on messaging consistency.</span></span>

<span data-ttu-id="4b6c7-263">Azure ストレージ キューは、最大 2,000 メッセージ/秒を処理できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="4b6c7-264">これよりも多いメッセージを処理する必要がある場合、複数のキューを作成することを検討します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="4b6c7-265">たとえば、グローバル アプリケーションで、複数のストレージ アカウントのそれぞれにストレージ キューを作成し、各リージョンで動作するアプリケーション インスタンスを処理します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="4b6c7-266">Azure Service Bus のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="4b6c7-267">Azure Service Bus はメッセージ ブローカーを使用して、Service Bus のキューまたはトピックに送信されるメッセージを処理します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="4b6c7-268">既定では、キューまたはトピックに送信されるすべてのメッセージは、同一のメッセージ ブローカー プロセスによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="4b6c7-269">このアーキテクチャにより、メッセージ キューの全体的なスループットに制限が生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="4b6c7-270">ただし、キューまたはトピックの作成時にそれらをパーティション分割することもできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="4b6c7-271">そのためには、キューまたはトピックの *EnablePartitioning* プロパティを *true* に設定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="4b6c7-272">パーティション分割されたキューまたはトピックは複数のフラグメントに分割され、それぞれのフラグメントは個別のメッセージ ストアおよびメッセージ ブローカーにより返されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="4b6c7-273">これらのフラグメントの作成および管理は、Service Bus によって行われます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="4b6c7-274">アプリケーションがメッセージをパーティション分割されたキューまたはトピックに送信すると、Service Bus はメッセージをそのキューまたはトピックのフラグメントに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="4b6c7-275">アプリケーションがメッセージをキューまたはサブスクリプションから受信すると、Service Bus は各フラグメントで次に利用可能なメッセージが存在するかどうかを確認し、存在する場合はそのメッセージを処理するために、アプリケーションに渡します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="4b6c7-276">この構造は、メッセージ ブローカー間およびメッセージ ストア間で負荷を分散するのに役立ち、拡張性と可用性を向上させます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="4b6c7-277">1 つのフラグメントのメッセージ ブローカーまたはメッセージ ストアが一時的に利用できなくなると、Service Bus は利用可能な残りのフラグメントの 1 つからメッセージを取得できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="4b6c7-278">Service Bus は、次の手順に従って、メッセージをフラグメントに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="4b6c7-279">メッセージがセッションに属する場合、*SessionId* プロパティと同じ値を持つすべてのメッセージは、同一のフラグメントに送信されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="4b6c7-280">メッセージはセッションに属していないが、送信者が *PartitionKey* プロパティの値を指定している場合、同じ *PartitionKey* 値を持つすべてのメッセージは、同一のフラグメントに送信されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="4b6c7-281">*SessionId* および *PartitionKey* プロパティの両方を指定している場合、これらを同じ値に設定する必要があります。そうしないと、メッセージは拒否されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="4b6c7-282">メッセージの *SessionId* プロパティと *PartitionKey* プロパティは指定されていないが、重複検出が有効な場合、*MessageId* プロパティが使用されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="4b6c7-283">同じ *MessageId* を持つすべてのメッセージは、同一のフラグメントに転送されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="4b6c7-284">メッセージに *SessionId、PartitionKey*、または *MessageId* のいずれのプロパティも含まれていない場合、Service Bus は順番にメッセージをフラグメントに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="4b6c7-285">あるフラグメントが利用できない場合、Service Bus は次のフラグメントに移動します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="4b6c7-286">つまり、メッセージ インフラストラクチャで一時的な障害が発生しても、メッセージ送信操作が失敗することはありません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="4b6c7-287">Service Bus のメッセージのキューまたはトピックをパーティション分割するかどうか、また、パーティション分割する方法を決定するときは、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="4b6c7-288">Service Bus のキューとトピックは、Service Bus 名前空間のスコープ内で作成されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="4b6c7-289">Service Bus は、現在、名前空間あたり最大 100 のパーティション分割されたキューまたはトピックをサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="4b6c7-290">各 Service Bus 名前空間は利用可能なリソースについてクォータが適用されます。これらのリソースには、トピックあたりのサブスクリプションの数、秒あたりのコンカレント送受信要求の数、確立可能なコンカレント接続の最大数などがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="4b6c7-291">これらのクォータについては、「[Service Bus のクォータ]」に記載されています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="4b6c7-292">これらの値を超えることが予想される場合、独自のキューとトピックを持つ追加の名前空間を作成し、負荷をこれらの名前空間間で分散します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="4b6c7-293">たとえば、グローバル アプリケーションで、リージョンごとに個別の名前空間を作成し、最も近い名前空間のキューとトピックを使用するように、アプリケーション インスタンスを構成します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="4b6c7-294">トランザクションの一部として送信されるメッセージでは、パーティション キーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="4b6c7-295">これは、*SessionId*、*PartitionKey*、または *MessageId* プロパティで指定できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="4b6c7-296">同一トランザクションの一部として送信されるすべてのメッセージは、同じパーティション キーを指定する必要があります。これは、これらのメッセージが同一のメッセージ ブローカー プロセスによって処理される必要があるためです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="4b6c7-297">同一トランザクション内のメッセージを異なるキューまたはトピックに送信することはできません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="4b6c7-298">パーティション分割されたキューおよびトピックは、アイドル状態になったときに自動的に削除されるように構成することはできません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="4b6c7-299">クロスプラットフォームまたはハイブリッドのソリューションを構築している場合、現在、パーティション分割されたキューおよびトピックを Advanced Message Queuing Protocol (AMQP) で使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="4b6c7-300">Cosmos DB のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="4b6c7-301">Azure Cosmos DB は [Azure Cosmos DB SQL API][cosmosdb-sql-api] を使用して JSON ドキュメントを格納できる NoSQL データベースです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="4b6c7-302">Cosmos DB データベースのドキュメントは、オブジェクトまたは他の種類のデータの JSON シリアル化された表現です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="4b6c7-303">すべてのドキュメントは一意な ID を含む必要があることを除いて、いずれの固定されたスキーマも強制されません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="4b6c7-304">ドキュメントはコレクションに編成されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-304">Documents are organized into collections.</span></span> <span data-ttu-id="4b6c7-305">コレクションでは、関連するドキュメントをグループ化できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="4b6c7-306">たとえば、ブログ投稿を維持するシステムでは、各ブログ投稿のコンテンツをドキュメントとしてコレクションに格納できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="4b6c7-307">また、各サブジェクト タイプのコレクションも作成できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="4b6c7-308">また、さまざまな著者が自身のブログ投稿を制御および管理するシステムなどのマルチテナント アプリケーションでは、ブログを著者別にパーティション分割して、著者ごとに個別のコレクションを作成できることがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="4b6c7-309">コレクションに割り当てられるストレージ領域は、弾力性があり、必要に応じて縮小または拡大できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="4b6c7-310">Cosmos DB では、アプリケーションで定義されたパーティション キーに基づくデータの自動パーティション分割をサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="4b6c7-311">"*論理パーティション*" は、1 つのパーティション キー値に対応するすべてのデータを格納するパーティションです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="4b6c7-312">同じパーティション キー値を共有するすべてのドキュメントは、同じ論理パーティション内に配置されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="4b6c7-313">Cosmos DB では、パーティション キーのハッシュに従って値を分散配置します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="4b6c7-314">論理パーティションの最大サイズは 10 GB です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="4b6c7-315">したがって、パーティション キーの選択は、設計時の重要な決定事項の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="4b6c7-316">値が多岐にわたっていて、なおかつ均等なアクセス パターンを持つプロパティを選択します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="4b6c7-317">詳細については、「[Azure Cosmos DB でのパーティション分割とスケーリング](/azure/cosmos-db/partition-data)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="4b6c7-318">各 Cosmos DB データベースには、取得するリソースの量を決定する "*パフォーマンス レベル*" があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="4b6c7-319">パフォーマンス レベルには、関連する "*要求ユニット*" (RU) レートの制限があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="4b6c7-320">RU レートの制限は、そのコレクションに予約されており、そのコレクションによって排他使用できるリソースの量を指定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="4b6c7-321">コレクションのコストは、そのコレクションによって選択されたパフォーマンス レベルに依存します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="4b6c7-322">パフォーマンス レベル (および RU レートの制限) が高くなるほど、料金も高くなります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="4b6c7-323">コレクションのパフォーマンス レベルは、Azure Portal を使用することにより調整できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="4b6c7-324">詳細については、「[Azure Cosmos DB の要求ユニット][cosmos-db-ru]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="4b6c7-325">Cosmos DB が提供するパーティション分割メカニズムでは十分でない場合、アプリケーション レベルでデータをシャード化する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="4b6c7-326">ドキュメント コレクションは、単一データベース内でデータをパーティション分割するための自然なメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="4b6c7-327">シャーディングを実装するための最も簡単な方法は、各シャード用にコレクションを作成することです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="4b6c7-328">コンテナーは論理リソースであり、1 つ以上のサーバーにまたがることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="4b6c7-329">固定サイズのコンテナーの上限は、容量が 10 GB で、スループットが毎秒 10,000 RU となります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="4b6c7-330">無制限のコンテナーには最大ストレージ サイズはありませんが、パーティション キーを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="4b6c7-331">クライアント アプリケーションは、アプリケーション シャーディングを使用して要求を適切なシャードに転送する必要があります。このためには、通常、シャード キーを定義するデータのいくつかの属性に基づいて、独自のマッピング メカニズムを実装します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="4b6c7-332">すべてのデータベースは、Cosmos DB アカウントのコンテキストで作成されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="4b6c7-333">1 つのアカウントに複数のデータベースを含めることができ、アカウントによりデータベースの作成先となるリージョンが指定されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="4b6c7-334">また、各アカウントは、独自のアクセス制御を実行します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="4b6c7-335">Cosmos DB アカウントを使用して、シャード (データベース内のコレクション) をそれらにアクセスする必要のあるユーザーの近くに geo 配置し、それらのユーザーだけがそれらのシャードに接続できるように制限を強制することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="4b6c7-336">Cosmos DB SQL API でデータをパーティション分割する方法を決定する際には、次の点を考慮する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="4b6c7-337">**Cosmos DB データベースで利用できるリソースは、アカウントのクォータ制限の対象になります**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="4b6c7-338">各データベースは複数のコレクションを保持できます。各コレクションには、そのコレクションの RU レートの制限 (予約されているスループット) を管理するパフォーマンス レベルが関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="4b6c7-339">詳細については、「[Azure サブスクリプションとサービスの制限、クォータ、制約][azure-limits]」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="4b6c7-340">**各ドキュメントには、それが保持されるコレクション内でそれを一意に識別するために使用できる属性が存在する必要があります**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="4b6c7-341">この属性は、ドキュメントの保持先となるコレクションを定義するシャード キーとは異なります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="4b6c7-342">コレクションは大量のドキュメントを含むことができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="4b6c7-343">理論的には、ドキュメント ID の最大長によってのみ制限されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="4b6c7-344">ドキュメント ID の最大長は、255 文字です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="4b6c7-345">**ドキュメントに対するすべての操作は、トランザクションのコンテキスト内で実行されます。トランザクションは、ドキュメントが含まれているコレクションに対象が制限されます。**</span><span class="sxs-lookup"><span data-stu-id="4b6c7-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="4b6c7-346">操作が失敗すると、それまでに実行された作業はロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="4b6c7-347">ドキュメントは操作の対象ですが、実行されるすべての変更は、スナップショット レベルで分離されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="4b6c7-348">このメカニズムは、たとえば、新しいドキュメントを作成する要求が失敗すると、同時にデータベースをクエリしている別のユーザーが、その時点で削除された不完全なドキュメントを見ることはないことを保証します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="4b6c7-349">**データベース クエリもまた、コレクション レベルの範囲に制限されます**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="4b6c7-350">単一のクエリは、1 つのコレクションのみからのデータを取得できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="4b6c7-351">複数のコレクションからデータを取得する必要がある場合、各コレクションを個別にクエリし、結果をアプリケーション コードでマージする必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="4b6c7-352">**Cosmos DB はプログラム可能な項目をサポートします。これらはすべて、ドキュメントと一緒にコレクションに格納できます**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="4b6c7-353">このような項目としては、ストアド プロシージャ、ユーザー定義の関数、および JavaScript で記述されたトリガーがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="4b6c7-354">これらの項目は、同一コレクション内の任意のドキュメントにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="4b6c7-355">さらに、これらの項目は、ドキュメントに対して実行された作成、削除、または置換の操作の結果として起動されるトリガーの場合には、アンビエント トランザクションのスコープ内で実行します。また、明示的なクライアント要求の結果として実行されるストアド プロシージャの場合には、新しいトランザクションを開始することによって実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="4b6c7-356">プログラム可能な項目内のコードが例外をスローすると、トランザクションはロールバックされます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="4b6c7-357">ストアド プロシージャとトリガーを使用してドキュメント間の整合性と一貫性を維持できますが、これらのドキュメントはすべて、同一のコレクション内に含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="4b6c7-358">**データベースに保持することが想定されているコレクションが、コレクションのパフォーマンス レベルによって定義されているスループット制限を超えないことを確認する必要があります**。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="4b6c7-359">詳細については、「[Azure Cosmos DB の要求ユニット][cosmos-db-ru]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="4b6c7-360">これらの制限に到達することが予想される場合は、異なるアカウントのデータベースにまたがってコレクションを分割して、コレクションあたりの負荷を軽減します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="4b6c7-361">Azure Search のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-361">Partitioning Azure Search</span></span>

<span data-ttu-id="4b6c7-362">データを検索する機能は、多くの Web アプリケーションによって提供されるナビゲーションと探索の主要な方法です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="4b6c7-363">ユーザーは、検索条件の組み合わせに基づいて、リソース (たとえば、e コマース アプリケーションでの製品) をすばやく見つけることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="4b6c7-364">Azure Search サービスは、Web コンテンツに対するフルテキスト検索機能に加えて、先行入力、近似一致に基づくクエリ候補表示、ファセット ナビゲーションなどの機能を提供しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="4b6c7-365">詳細については、「[Azure Search とは]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="4b6c7-366">Azure Search は、検索可能なコンテンツを JSON ドキュメントとしてデータベースに格納します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="4b6c7-367">これらのドキュメントの検索可能なフィールドを指定するインデックスを定義し、これらの定義を Azure Search に提供します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="4b6c7-368">ユーザーが検索要求を発行すると、Azure Search は適切なインデックスを使用して一致する項目を検索します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="4b6c7-369">競合を少なくするために、Azure Search によって使用されるストレージは、最大 1、2、3、4、6、または 12 のパーティションに分割でき、各パーティションは最大 6 回レプリケートできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="4b6c7-370">パーティションの数とレプリカの数の積は、"*検索単位*" (SU) と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="4b6c7-371">Azure Search の単一インスタンスは、最大 36 SU を含むことができます (12 のパーティションを持つデータベースは、最大 3 つのレプリカをサポートします)。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="4b6c7-372">課金は、サービスに割り当てられている各 SU に対して行われます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="4b6c7-373">検索可能なコンテンツの量、または検索要求の割合が増加した場合、Azure Search の既存のインスタンスに SU を追加して、増加した負荷を処理できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="4b6c7-374">Azure Search 自体が、パーティション間にドキュメントを均等に分散します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="4b6c7-375">手動によるパーティション分割戦略は、現時点でサポートされていません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="4b6c7-376">各パーティションは、最大 1,500 万のドキュメント、または 300 GB のストレージ領域のいずれか少ない方を収容できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="4b6c7-377">最大 50 のインデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="4b6c7-378">サービスのパフォーマンスは、ドキュメントの複雑さ、利用可能なインデックス、およびネットワーク遅延の影響によって異なります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="4b6c7-379">平均すると、単一レプリカ (1 SU) は 15 クエリ/秒 (QPS) を処理できます。ただし、スループットをより正確に測定するために、自身のデータを使用してベンチマークを実行することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="4b6c7-380">詳細については、「[Azure Search サービスの制限] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="4b6c7-381">検索可能ドキュメントには、限定されたセットのデータ型を格納できます。これらのデータには、文字列、ブール値、数値データ、日付時刻データ、および一部の地理的データが含まれます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="4b6c7-382">詳細については、Microsoft Web サイトの「[Supported data types (Azure Search) (サポートされるデータ型 (Azure Search))]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="4b6c7-383">Azure Search がサービスの各インスタンス用にデータをパーティション分割する方法については、限定された制御しかできません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="4b6c7-384">ただし、グローバル環境では、次のいずれかの戦略を使用してサービス自体をパーティション分割することにより、パフォーマンスを向上させ、遅延を小さくし、競合を少なくすることができる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="4b6c7-385">各リージョンで Azure Search のインスタンスを作成し、クライアント アプリケーションの要求が最も近い利用可能なインスタンスに転送されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="4b6c7-386">この戦略では、検索可能なコンテンツに対するすべての更新がサービスのすべてのインスタンスに対して、遅れることなくレプリケートされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="4b6c7-387">Azure Search の 2 つの階層を作成します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="4b6c7-388">各リージョンに、そのリージョンで最も頻繁にアクセスされるデータを含むローカル サービス。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="4b6c7-389">限定的な結果でも早くほしい場合は、ここに要求できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="4b6c7-390">すべてのデータを収容するグローバル サービス。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="4b6c7-391">時間がかかっても完全な結果が必要な場合は、ここに要求できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="4b6c7-392">この手法は、検索対象のデータに大きな地域的な相違がある場合に最も適しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="4b6c7-393">Azure Redis Cache のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="4b6c7-394">Azure Redis Cache は、Redis キー/値データ ストアに基づく、クラウド内の共有キャッシュ サービスを提供します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="4b6c7-395">名前が示すように、Azure Redis Cache はキャッシュ ソリューションを意図しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="4b6c7-396">恒久的なデータ ストアとしてではなく、一時的なデータを保持するためにのみ使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="4b6c7-397">Azure Redis Cache を使用するアプリケーションは、キャッシュが利用できない場合でも、継続して動作できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-397">Applications that use Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="4b6c7-398">Azure Redis Cache はプライマリ/セカンダリ レプリケーションをサポートし、高可用性を提供しますが、現在、最大キャッシュ サイズは 53 GB に制限されています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="4b6c7-399">このサイズを超える領域を必要とする場合は、追加のキャッシュを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="4b6c7-400">詳細については、[Azure Redis Cache] に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="4b6c7-401">Redis データ ストアをパーティション分割する場合、Redis サービスのインスタンス全体でデータを分割します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="4b6c7-402">各インスタンスは、単一パーティションを構成します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="4b6c7-403">Azure Redis Cache はファサードの背後に Redis サービスを抽象化し、それらが直接アクセスされないようにします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="4b6c7-404">パーティション分割を実装する最も簡単な方法は、複数の Azure Redis Cache インスタンスを作成し、データをそれら全体に分散することです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="4b6c7-405">データ項目の格納先となるキャッシュを指定する識別子 (パーティション キー) と各データ項目を関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="4b6c7-406">クライアント アプリケーション ロジックはこの識別子を使用して、要求を適切なパーティションにルーティングできます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="4b6c7-407">この構成は非常に単純ですが、パーティション分割構成が変更されると (たとえば、追加の Azure Redis Cache インスタンスが作成されると)、クライアント アプリケーションの再構成が必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="4b6c7-408">Azure Redis Cache ではないネイティブ Redis は、Redis クラスタリングに基づくサーバー側のパーティション分割をサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="4b6c7-409">この手法では、ハッシュ メカニズムを使用することにより、データをサーバー間で均等に分散できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="4b6c7-410">各 Redis サーバーは、パーティションが保持するハッシュ キーの範囲を定義するメタデータを格納します。また、他のサーバーのパーティションに配置されているハッシュ キーに関する情報も含みます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="4b6c7-411">クライアント アプリケーションは単純に要求を、パーティション分割された任意の Redis サーバー (最も近いサーバーの可能性大) に送信します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="4b6c7-412">Redis サーバーは、クライアント要求を調べます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-412">The Redis server examines the client request.</span></span> <span data-ttu-id="4b6c7-413">ローカルで解決できる場合、要求された操作が実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="4b6c7-414">ローカルで解決できない場合、適切なサーバーに要求が転送されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="4b6c7-415">このモデルは Redis クラスタリングを使用することによって実装されます。詳細については、Redis Web サイトの「[Redis cluster tutorial (Redis クラスターのチュートリアル)]」ページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="4b6c7-416">Redis クラスタリングはクライアント アプリケーションにとって透過的なものです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="4b6c7-417">クライアントを再構成しなくても追加の Redis サーバーをクラスターに追加できます (およびデータを再パーティション分割できます)。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4b6c7-418">現在、Azure Redis Cache は、[Premium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) レベルでのみ Redis クラスタリングをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-418">Azure Redis Cache currently supports Redis clustering in [premium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) tier only.</span></span>

<span data-ttu-id="4b6c7-419">Redis Web サイトの「 [Partitioning: how to split data among multiple Redis instances (パーティション分割: 複数の Redis インスタンス間でデータを分割する方法)] 」には、Redis へのパーティション分割の実装に関する詳細情報が記載されています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-419">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="4b6c7-420">このセクションの以降の説明では、クライアント側またはプロキシに支援されたパーティション分割を実装していると想定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-420">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="4b6c7-421">Azure Redis Cache でデータをパーティション分割する方法を決定する際には、次の点を検討する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-421">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="4b6c7-422">Azure Redis Cache は恒久的なデータ ストアとして動作するようには意図されていません。このため、実装するパーティション分割構成に関係なく、アプリケーション コードはキャッシュではない場所からデータを取得できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-422">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="4b6c7-423">頻繁に一緒にアクセスされるデータは、同一パーティションに維持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-423">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="4b6c7-424">Redis は強力なキー値ストアで、データを構造化するための高度に最適化された一連のメカニズムを提供します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-424">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="4b6c7-425">次のようなメカニズムがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-425">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="4b6c7-426">単純な文字列 (最大 512 MB の長さバイナリ データ)</span><span class="sxs-lookup"><span data-stu-id="4b6c7-426">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="4b6c7-427">リストなどの集約型 (キューおよびスタックとして動作可能)</span><span class="sxs-lookup"><span data-stu-id="4b6c7-427">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="4b6c7-428">セット (順序ありおよび順序なし)</span><span class="sxs-lookup"><span data-stu-id="4b6c7-428">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="4b6c7-429">ハッシュ (オブジェクト内のフィールドを表す項目などの関連するフィールドをグループ化することが可能)</span><span class="sxs-lookup"><span data-stu-id="4b6c7-429">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="4b6c7-430">集約型を使用すると、多くの関連する値を同じキーに関連付けることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-430">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="4b6c7-431">Redis キーは、それが含むデータ項目ではなく、リスト、セット、またはハッシュを識別します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-431">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="4b6c7-432">これらの型は、Azure Redis Cache ですべて利用できます。詳細については、Redis Web サイトの「[Data Types (データ型)]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-432">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="4b6c7-433">たとえば、顧客により登録された注文を追跡する e コマース システムの一部として、各顧客の詳細情報を、顧客 ID をキーとして使用して Redis ハッシュに格納できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-433">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="4b6c7-434">各ハッシュは、その顧客の注文 ID のコレクションを保持することができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-434">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="4b6c7-435">別の Redis セットで注文を保持することもできます。この場合も、ハッシュとして構造化され、注文 ID をキーとして使用します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-435">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="4b6c7-436">図 8 に、この構造を示します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-436">Figure 8 shows this structure.</span></span> <span data-ttu-id="4b6c7-437">Redis では、いずれの形態の参照整合性も実装しないので、開発者は、顧客と注文の間の関係を維持するロジックを組み込む必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-437">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![顧客の注文とそれらの詳細情報を記録するために Redis ストレージで想定される構造](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="4b6c7-439">*図 8: 顧客の注文とそれらの詳細情報を記録するために Redis ストレージで想定される構造。*</span><span class="sxs-lookup"><span data-stu-id="4b6c7-439">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="4b6c7-440">Redis では、すべてのキーは、Redis 文字列と同じようなバイナリ データ値で、最大で 512 MB のデータを含むことができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-440">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="4b6c7-441">理論的には、キーはあらゆる情報を含むことができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-441">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="4b6c7-442">ただし、キーに対して一貫した名前付け規則を適用し、データの型をわかりやすく表し、エンティティを識別し、しかも過度に長すぎないような名前を割り当てることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-442">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="4b6c7-443">一般的な方法では、"entity_type:ID" の形のキーを使用します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-443">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="4b6c7-444">たとえば、"customer:99" は ID 99 の顧客のキーを示します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-444">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="4b6c7-445">関連する情報を同一データベースの異なる集約型に格納することによって、垂直的パーティション分割を実装できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-445">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="4b6c7-446">たとえば、e コマース アプリケーションで、製品について共通してアクセスされる情報を 1 つの Redis ハッシュに格納し、アクセス頻度の低い詳細情報を別の Redis ハッシュに格納できることがあります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-446">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="4b6c7-447">両方のハッシュはキーの一部として同じ製品 ID を使用できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-447">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="4b6c7-448">たとえば、製品情報用の "product: *nn*" (*nn* は製品 ID) や詳細データ用の "product_details: *nn*" を使用できます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-448">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="4b6c7-449">この戦略は、ほとんどのクエリが取得する可能性が高いデータの量を少なくするのに役立てることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-449">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="4b6c7-450">Redis データ ストアを再パーティションできますが、複雑で時間のかかる作業であることに留意してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-450">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="4b6c7-451">Redis クラスタリングではデータの再パーティション分割を自動的に実行できますが、この機能は、Azure Redis Cache とは併用できません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-451">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="4b6c7-452">このため、パーティション分割構成を設計する際には、各パーティションに十分な空き領域を確保して、予想される将来のデータ増加に最初から備える必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-452">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="4b6c7-453">ただし、Azure Redis Cache はデータを一時的にキャッシュすることを意図しており、キャッシュに保持されるデータは有効期間 (TTL) 値として指定される期間だけ有効であることに注意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-453">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="4b6c7-454">揮発性が比較的高いデータでは TTL を短くできますが、静的なデータでは、TTL を非常に長くすることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-454">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="4b6c7-455">有効期間の長いデータをキャッシュに大量に格納しないでください。そのデータにより、キャッシュがいっぱいになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-455">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="4b6c7-456">強制退去ポリシーを指定して、利用できる領域が少ない場合に Azure Redis Cache がデータを削除できるようにすることができます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-456">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="4b6c7-457">Azure Redis Cache を使用する場合は、適切な価格レベルを選択することにより、キャッシュの最大サイズを 250 MB から 53 GB の範囲で指定します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-457">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="4b6c7-458">ただし、いったん Azure Redis Cache を作成したら、その後にはサイズを大きくしたり小さくしたりすることはできません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-458">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="4b6c7-459">Redis のバッチおよびトランザクションは、複数の接続を利用できないので、バッチまたはトランザクションによりアクセスされるすべてのデータは同一のデータベース (シャード) で保持する必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-459">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="4b6c7-460">Redis トランザクションの一連の操作は、必ずしもアトミックである必要はありません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-460">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="4b6c7-461">トランザクションを構成するコマンドは、実行前に検証されてキューに登録されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-461">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="4b6c7-462">この段階でエラーが発生すると、キュー全体が破棄されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-462">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="4b6c7-463">ただし、トランザクションが正常に発行されると、キューに登録されていた一連のコマンドが正しい順序で実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-463">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="4b6c7-464">いずれかのコマンドで障害が発生すると、そのコマンドの実行だけが中止されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-464">If any command fails, only that command stops running.</span></span> <span data-ttu-id="4b6c7-465">キュー内の前後にあるコマンドはすべて実行されます。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-465">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="4b6c7-466">詳細については、Redis Web サイトの「 [トランザクション] 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-466">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="4b6c7-467">Redis は、限定された数のアトミック操作をサポートします。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-467">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="4b6c7-468">複数のキーと値をサポートするこの種の操作は、MGET 操作と MSET 操作だけです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-468">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="4b6c7-469">MGET 操作は指定したキー リストの値のコレクションを返し、MSET 操作は指定したキー リストの値のコレクションを格納します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-469">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="4b6c7-470">これらの操作を使用する必要がある場合、MSET コマンドと MGET コマンドによって参照されるキー値ペアは、同一のデータベースに格納される必要があります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-470">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="4b6c7-471">Azure Service Fabric のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-471">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="4b6c7-472">Azure Service Fabric は、クラウドの分散アプリケーションにランタイムを提供する microservices プラットフォームです。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-472">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="4b6c7-473">Service Fabric は、.Net ゲストの実行可能ファイル、ステートフルおよびステートレスなサービス、およびコンテナーをサポートしています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-473">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="4b6c7-474">ステートフルなサービスは、Service Fabric クラスター内のキー値コレクションにデータを永続的に格納する[信頼性の高いコレクション][service-fabric-reliable-collections]を提供します。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-474">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="4b6c7-475">リライアブル コレクション内のパーティション分割キー戦略の詳細については、「[Azure Service Fabric の Reliable Collections のガイドラインと推奨事項]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-475">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="4b6c7-476">詳細情報</span><span class="sxs-lookup"><span data-stu-id="4b6c7-476">More information</span></span>

- <span data-ttu-id="4b6c7-477">[Azure Service Fabric の概要]は、Azure Service Fabric の導入です。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-477">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="4b6c7-478">[Service Fabric Reliable Services のパーティション分割]では、Azure Service Fabric で信頼性の高いサービスについて詳しく説明しています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-478">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="4b6c7-479">Azure Event Hubs のパーティション分割</span><span class="sxs-lookup"><span data-stu-id="4b6c7-479">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="4b6c7-480">[Azure Event Hubs][event-hubs] は、大規模なデータ ストリーミングのために設計されており、パーティション分割は、水平方向のスケーリングを可能にするためにサービスに組み込まれています。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-480">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="4b6c7-481">各コンシューマーは、メッセージ ストリームの特定のパーティションのみを読み取ります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-481">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="4b6c7-482">イベント発行元は、そのパーティション キーのみを認識し、イベントの発行先となるパーティションは認識しません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-482">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="4b6c7-483">このようにキーとパーティションを分離することにより、送信者はダウンストリーム処理について余分な情報を把握しなくてもよくなります。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-483">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="4b6c7-484">(特定のパーティションにイベントを直接送信することも可能ですが、通常は推奨されません)。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-484">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="4b6c7-485">パーティション数を選択する場合は、長期間にわたる拡張を考慮してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-485">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="4b6c7-486">Event hub を作成した後は、パーティションの数を変更できません。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-486">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="4b6c7-487">Event Hubs でのパーティションの使用の詳細については、「[Event Hubs とは]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-487">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="4b6c7-488">可用性と一貫性の間のトレードオフに関する詳細については、「[Event Hubs における可用性と一貫性]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="4b6c7-488">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[Event Hubs における可用性と一貫性]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Azure ストレージ テーブルの設計ガイド]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Data Types (データ型)]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Azure Service Fabric の Reliable Collections のガイドラインと推奨事項]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Azure Service Fabric の概要]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[Service Fabric Reliable Services のパーティション分割]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partitioning: how to split data among multiple Redis instances (パーティション分割: 複数の Redis インスタンス間でデータを分割する方法)]: https://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[Performing Entity Group Transactions (エンティティ グループ トランザクションの実行)]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Redis cluster tutorial (Redis クラスターのチュートリアル)]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus のクォータ]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Azure Search サービスの制限]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[Supported data types (Azure Search) (サポートされるデータ型 (Azure Search))]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[トランザクション]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[Event Hubs とは]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Azure Search とは]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[スケーラビリティ ターゲット]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
