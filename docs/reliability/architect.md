---
title: 回復性と可用性に対応するように Azure アプリケーションを設計する
description: Azure アプリケーションに回復性と可用性を組み込みます
author: MikeWasson
ms.date: 04/10/2019
ms.topic: article
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.openlocfilehash: ee4bb5b4a85e48fe0ff017297c31823c93a48f04
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2019
ms.locfileid: "59642886"
---
# <a name="architecting-azure-applications-for-resiliency-and-availability"></a>回復性と可用性に対応するように Azure アプリケーションを設計する

アプリケーションの要件を開発した後の次のステップは、そこに回復性と可用性を組み込むことです。 これらの属性を最後に追加することはできません。アーキテクチャに組み込む必要があります。

## <a name="conduct-a-failure-mode-analysis"></a>障害モード分析を実行する

"*障害モード分析*" (FMA) では、可能性のある障害点を特定し、アプリケーションでそれらの障害にどのように対応するかを定義することによって、システムに回復性を持たせます。 FMA をアーキテクチャおよび設計のフェーズで行って、最初からシステムに障害復旧が組み込まれるようにする必要があります。 FMA の目標は次のとおりです。

- アプリケーションで発生する可能性がある障害の種類と、アプリケーションでそれらの障害を検出する方法を決定します。
- 障害の種類ごとに潜在的な影響を把握し、アプリでの対応方法を決定します。
- 障害のログ記録と監視を計画し、復旧の戦略を明らかにします。

次に示すのは、外部 Web サービスの呼び出しという特定の障害点に対する障害モードと検出戦略の例です。

| 障害モード           | 検出戦略           |
|------------------------|------------------------------|
| サービスを使用できない | HTTP 5xx                     |
| Throttling             | HTTP 429 (要求が多すぎます) |
| Authentication         | HTTP 401 (権限がありません)      |
| 遅い応答          | 要求のタイムアウト            |

FMA プロセスの詳細と、Azure 固有の推奨事項については、[障害モード分析](../resiliency/failure-mode-analysis.md)に関するセクションをご覧ください。

## <a name="plan-for-redundancy"></a>冗長性を計画する

障害によって影響の範囲が異なります。 たとえば、ディスク障害などの一部のハードウェア障害は、1 台のホスト コンピューターに影響を及ぼします。 ネットワーク スイッチで障害が発生すると、サーバー ラック全体に影響する可能性があります。 停電などのあまり発生しない障害では、データセンター全体が停止します。 リージョン全体が利用できなくなることはほとんどありません。

冗長性は、回復性があるアプリケーションにする方法の 1 つです。 冗長性のレベルは、ビジネス要件によって異なります。すべてのアプリケーションで、リージョン障害に備えるためのリージョン間の冗長性が必要なわけではありません。 一般に、冗長性と信頼性を高めると、コストと複雑さが増すというトレードオフがあります。

### <a name="review-azure-redundancy-features"></a>Azure の冗長性機能を確認する

Azure には、個別の仮想マシン (VM) からリージョン全体まで、すべての障害レベルに複数の冗長性機能があります。

- **1 つの VM** には、Azure によって[稼働時間のサービス レベル アグリーメント (SLA)](https://azure.microsoft.com/support/legal/sla/virtual-machines) が提供されています。 (VM では、すべてのオペレーティング システム ディスクとデータ ディスクに対して Premium Storage を使用する必要があります。)2 つ以上の VM を実行すると高い SLA を得られますが、ワークロードによっては単一の VM で十分な信頼性が得られる場合もあります。 ただし、運用環境のワークロードの場合は、2 台以上の VM を使用して冗長性を確保することをお勧めします。
- **可用性セット**では、ディスクやネットワーク スイッチの障害など、局所的なハードウェア障害に対して保護されます。 可用性セット内の VM は、最大で 3 つの "*障害ドメイン*" 間に分散されます。 障害ドメインでは、共通の電源とネットワーク スイッチを共有する VM のグループが定義されています。 ハードウェア障害の影響を受ける障害ドメインが 1 つの場合、ネットワーク トラフィックは他の障害ドメイン内の VM にルーティングされます。 可用性セットの詳細については、「[Azure での Windows 仮想マシンの可用性の管理](/azure/virtual-machines/windows/manage-availability)」を参照してください。
- **Availability Zones** は、Azure リージョン内の物理的に分離されたゾーンです。 可用性ゾーンはそれぞれ異なる電源、ネットワーク、および冷却装置を持ちます。 Availability Zones に VM をデプロイすると、データセンター全体の障害からアプリケーションを保護するのに役立ちます。 Availability Zones は、すべてのリージョンでサポートされているわけではありません。 サポートされているリージョンとサービスの一覧については、「[Azure の可用性ゾーンの概要](/azure/availability-zones/az-overview)」を参照してください。

    デプロイで Availability Zones を使用する予定がある場合は、アプリケーションのアーキテクチャとコード ベースでこの構成がサポートされていることを最初に確認してください。 市販のソフトウェアをデプロイする場合は、ソフトウェア ベンダーに問い合わせて、運用環境にデプロイする前に十分にテストしてください。 アプリケーションでは、構成されたゾーン内での停止の間に、状態を維持し、データの消失を防ぐ必要があります。 アプリケーションでは、インフラストラクチャのコンポーネントをハード コーディングせずに、エラスティックな分散されたインフラストラクチャでの実行をサポートする必要があります。
- **Azure Site Recovery** では、ビジネス継続性 (BC) とディザスター リカバリー (DR) のニーズに応じて、Azure Virtual Machines が別の Azure リージョンにレプリケートされます。 ディザスター リカバリーの訓練を定期的に行って、コンプライアンス ニーズが満たされていることを確認できます。 ソース リージョンで停止が発生した場合にアプリケーションを復旧できるように、VM は指定した設定で選択したリージョンにレプリケートされます。 詳細については、「[Azure VM のセカンダリ Azure リージョンへのディザスター リカバリーの設定](/azure/site-recovery/azure-to-azure-quickstart/)」を参照してください。

    テストの間に、"*目標復旧時間*" (RTO) と "*目標復旧時点*" (RPO) が要件を満たすことを確認します。 RTO はインシデント発生後にアプリケーションが使用不可能になる最大時間であり、RPO は障害の間にデータが失われる最大期間です。
- **ペアのリージョン**は、異なるリージョンにインターネット トラフィックを分散することによって、リージョン停止からアプリケーションを保護するため、Azure Traffic Manager を使って作成します。 各 Azure リージョンは別のリージョンとペアになります。 これらのリージョンにより、[*リージョン ペア*](/azure/best-practices-availability-paired-regions)が形成されます。 税および法の執行を目的としたデータ常駐要件を満たすため、リージョン ペアは同じ地理的場所に配置されます (ブラジル南部を除きます)。

    アプリケーションの回復性を高めるため、Azure ではプラットフォームの更新 (計画メンテナンス) は各リージョンのペアで順番に実行されるようになっており、一度に 1 つのペアになったリージョンだけが更新されます。
- 複数リージョンのアプリケーションを設計するときは、リージョン間のネットワーク待機時間は、リージョン内の待機時間より長くなることを考慮してください。 たとえば、フェールオーバーを有効にするためにデータベースをレプリケートする場合は、リージョン間の非同期データ レプリケーションではなく、リージョン内の同期データ レプリケーションを使います。

次の表は、さまざまな回復性戦略の間で冗長性要因を比較したものです。

| &nbsp; | 可用性セット | 可用性ゾーン | Azure Site Recovery/ペアのリージョン |
|--------|------------------|-------------------|-----------------------------------|
| 障害の範囲 | ラック                  | データセンター               | リージョン                               |
| 要求のルーティング  | Azure Load Balancer   | クロスゾーン ロード バランサー | Azure の Traffic Manager                |
| ネットワーク待ち時間  | 非常に低い              | 低                      | 中～高                          |
| 仮想ネットワーク  | Azure Virtual Network | Azure Virtual Network          | リージョン間の Virtual Network ピアリング |

### <a name="complete-azure-redundancy-tasks"></a>Azure の冗長性のタスクを完了する

冗長性の要件を満たすには以下のタスクを使用します。

- **複数のインスタンスのサービスをデプロイします。** アプリケーションがサービスの 1 つのインスタンスに依存する場合は、単一障害点が発生します。 複数のインスタンスをプロビジョニングすると、回復性とスケーラビリティの両方が改善されます。 [Azure App Service](/azure/app-service/app-service-value-prop-what-is/) の場合は、複数のインスタンスを提供する [App Service プラン](/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview/)を選択してください。 [Azure Virtual Machines](/azure/virtual-machines/virtual-machines-windows-about/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) の場合は、アーキテクチャに 1 つ以上の VM が含まれていることと、[可用性セット](/azure/virtual-machines/virtual-machines-windows-manage-availability/)に各 VM が含まれていることを確認します。

- **Azure Site Recovery を使用して VM をレプリケートします。** [Site Recovery](/azure/site-recovery/) を使用して Azure VM をレプリケートすると、すべての VM ディスクが、ターゲット リージョンに継続的かつ非同期的にレプリケートされます。 復旧ポイントが数分ごとに作成されて、分単位の RPO が提供されます。

- **アプリケーションを複数のリージョンにデプロイすることを検討します。** アプリケーションが 1 つのリージョンにデプロイされている場合、リージョンが使用できなくなると、アプリケーションも使用できなくなります。 これは、アプリケーションの SLA の条件の下では許容できないことがあります。 その場合は、アプリケーションとそのサービスを複数のリージョンにデプロイすることを検討してください。 マルチリージョンのデプロイでは、"*アクティブ/アクティブ*" または "*アクティブ/パッシブ*" の構成を使うことができます。 アクティブ/アクティブ構成では、要求は複数のアクティブなリージョンに分散されます。 アクティブ/パッシブ構成では、セカンダリ リージョンにウォーム インスタンスが保持されていますが、プライマリ リージョンで障害が発生しない限り、そこにトラフィックが送信されることはありません。 マルチリージョンのデプロイでは、上で説明したペアのリージョンにデプロイすることをお勧めします。 詳しくは、「[ビジネス継続性とディザスター リカバリー (BCDR):Azure のペアになっているリージョン](/azure/best-practices-availability-paired-regions)」をご覧ください。

- **Azure Traffic Manager を使用して、アプリケーションのトラフィックをさまざまなリージョンにルーティングします。** [Azure Traffic Manager](/azure/traffic-manager/traffic-manager-overview/) では、DNS レベルで負荷分散が実行され、[トラフィック ルーティング](/azure/traffic-manager/traffic-manager-routing-methods/)の方法とアプリケーションのエンドポイントの正常性に基づいて、トラフィックが異なるリージョンにルーティングされます。 Traffic Manager を使用しないと、デプロイできるのは 1 つのリージョンに制限されるので、スケールが制約され、一部のユーザーの待機時間が増加し、リージョン全体のサービスが停止した場合に、アプリケーションのダウンタイムが発生します。

- **複数のインスタンスを使用するように Azure Application Gateway を構成します。** アプリケーションの要件によっては、アプリケーションのサービスに対する要求の分散には、[Azure Application Gateway](/azure/application-gateway/application-gateway-introduction/) のほうが適している場合があります。 ただし、Application Gateway サービスの単一インスタンスは SLA によって保証されないため、Application Gateway のインスタンスが失敗した場合はアプリケーションが失敗する可能性があります。 [Application Gateway SLA](https://azure.microsoft.com/support/legal/sla/application-gateway/) の条件に基づいてサービスの可用性を保証するには、複数の中規模以上のインスタンスをプロビジョニングしてください。

## <a name="design-for-scalability"></a>スケーラビリティのための設計

"*スケーラビリティ*" とは、増加した負荷を処理するシステムの能力であり、[ソフトウェア品質の重要な要素](../guide/pillars.md)の 1 つです。 設計フェーズ中には次のようなスケーラビリティ タスクがあります。

- **ワークロードをパーティション分割します。** プロセスのパーツを別個に分解できるように設計します。 各パーツのサイズを最小限に抑えます。 これにより、各コンピューティング ユニットを最大限に使用できるようにコンポーネントのパーツを分散できます。 また、特定のリソースのインスタンスを追加することで、アプリケーションのスケーリングが容易になります。 複雑なドメインの場合、[マイクロサービス アーキテクチャ](../guide/architecture-styles/microservices.md)の採用を検討してください。
- **スケーリングを考慮して設計します。** スケーリングにより、アプリケーションは、ロール、キュー、および他のサービスのインスタンスの数を増減することで、変動負荷に対応できます。 ただし、アプリケーションを設計する際には、次の点を考慮に入れる必要があります。 たとえば、アプリケーションとそれが使用するサービスをステートレスにして、要求をどのインスタンスにもルーティングできるようにする必要があります。 また、サービスをステートレスにすると、インスタンスを追加または削除しても現在のユーザーに悪影響がありません。
- **スケール ユニットで成長を計画します。** リソースごとに、スケーリングの上限を確認し、シャーディングまたは分解を使用して、これらの限度を超える必要があります。 1 つ以上のスケール ユニットを追加することでスケーリングが容易になるように、アプリケーションを設計してください。 明確に定義されたリソースのセットを単位として、システムのスケール ユニットを判別します。 これにより、スケールアウト操作の適用が容易になるだけでなく、システム全体の一部分でのリソース不足による悪影響を避けることができます。 たとえば、*X* 個のフロントエンド VM を追加すると、追加のワークロードを処理するために、*Y* 個の追加キューおよび *Z* 個のストレージ アカウントが必要になる場合があります。 したがって、*X* 個の VM インスタンス、*Y* 個のキュー、*Z* 個のストレージ アカウントで、スケール ユニットを構成できます。
- **クライアント アフィニティを回避します。** 可能であれば、アプリケーションでアフィニティが必要にならないようにします。 そうすれば、どのインスタンスにも要求をルーティングでき、インスタンスの数に影響されずに済みます。 これにより、各ユーザーの状態情報を格納、取得、保守するためのオーバーヘッドが生じることもなくなります。
- **プラットフォームの自動スケーリング機能を利用します。** 可能であれば、カスタムまたはサードパーティのメカニズムではなく、組み込みの自動スケーリング機能を使います。 可能な限り、スケジュールされたスケーリング ルールを使用し、起動時の遅延なしでリソースを使用可能にします。ただし、必要に応じてリアクティブな自動スケーリングをルールに追加し、予期しない要求の変化に対応します。 詳しくは、「[自動スケール](../best-practices/auto-scaling.md)」のガイダンスをご覧ください。  

  負荷が増したときに自動的にスケールアウトするようにアプリケーションが構成されていない場合は、ユーザーの要求で飽和状態になるとアプリケーションのサービスが失敗する可能性があります。 詳細については、次の記事を参照してください。

  - 全般:[スケーラビリティのチェックリスト](../checklist/scalability.md)
  - Azure App Service:[手動または自動によるインスタンス数のスケール変更](/azure/monitoring-and-diagnostics/insights-how-to-scale/)
  - クラウド サービス:[クラウド サービスを自動スケーリングする方法](/azure/cloud-services/cloud-services-how-to-scale/)
  - 仮想マシン:[自動スケールと仮想マシン スケール セット](/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-autoscale-overview/)

- **負荷の高い CPU/IO タスクをバックグラウンド タスクとしてオフロードします。** サービスへの要求の実行に長時間かかったり、かなりのリソースを消費したりすることが予想される場合は、処理を別のタスクにオフロードします。 バックグラウンド ジョブを使って、これらのタスクを実行します。 この戦略を使用すると、サービスはさらに多くの要求を引き続き受信したり、即座に対応したりすることが可能になります。 詳細については、「 [Background jobs guidance (バックグラウンド ジョブのガイダンス)](../best-practices/background-jobs.md)」を参照してください。
- **バックグラウンド タスクのワークロードを分散します。** 多くのバックグラウンド タスクがある場合、またはタスクの実行に相当の時間かリソースが必要な場合、複数のコンピューティング ユニットに作業を分散します。 考えられる解決策の 1 つについては、[競合コンシューマー パターン](../patterns/competing-consumers.md)に関するページを参照してください。
- **"*シェアード ナッシング*" アーキテクチャの使用を検討します。** このアーキテクチャでは、単一競合点 (共有サービスや共有ストレージなど) を持たない、独立した自己充足的なノードが使われます。 理論上、そのようなシステムはほぼ無制限にスケールできます。 通常、完全なシェアード ナッシング アプローチは実用的ではありませんが、スケーラビリティの向上を考慮した設計には適している場合があります。 データをパーティション分割し、サーバー側のセッション状態やクライアント アフィニティを避けるのは、シェアード ナッシング アーキテクチャを目指す場合のよい例です。
- **アプリケーションのストレージ要件を、Azure Storage のスケーラビリティとパフォーマンスのターゲットの範囲に入るように設計します。** Azure Storage は、事前定義済みのスケーラビリティとパフォーマンスのターゲットの中で機能するように設計されているため、それらのターゲットの中でストレージを使うようにアプリケーションを設計します。 これらのターゲットを上回ると、アプリケーションでストレージが調整されます。 調整されないようにするには、追加のストレージ アカウントをプロビジョニングします。 ストレージ アカウントの制限に達する場合は、追加の Azure サブスクリプションをプロビジョニングしてから、そこに追加のストレージ アカウントをプロビジョニングします。 詳細については、「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット](/azure/storage/storage-scalability-targets/)」を参照してください。
- **アプリケーションに適した VM サイズを選択します。** 運用環境の VM の実際の CPU、メモリ、ディスク、および I/O を測定し、選択した VM のサイズが十分であることを確認します。 そうでない場合は、VM がその制限に近くなると、アプリケーションで容量の問題が発生する可能性があります。 VM のサイズについては、「[Azure の仮想マシンのサイズ](/azure/virtual-machines/virtual-machines-windows-sizes/?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)」をご覧ください。

## <a name="determine-subscription-and-service-requirements"></a>サブスクリプションとサービスの要件を決定する

以下のタスクを行って、アプリに適したサブスクリプションとサービスの機能を選択します。

- **[Azure のサブスクリプションとサービスの制限](/azure/azure-subscription-service-limits/)に対して要件を評価します。** "*Azure サブスクリプション*" には、リソース グループの数、コアの数、ストレージ アカウントの数など、特定のリソースの種類に対する制限があります。 アプリケーションの要件が Azure サブスクリプションの制限を超えた場合は、別の Azure サブスクリプションを作成し、そこに十分なリソースをプロビジョニングしてください。 個々 の Azure サービスには消費量に制限があります。たとえば、ストレージ、スループット、接続数、秒あたりの要求、およびその他のメトリックに関する制限です。 これらの制限を超えてリソースを使おうとするとアプリケーションは失敗し、サービスの調整が行われて、影響を受けたユーザーにダウンタイムが発生する可能性があります。 特定のサービスとアプリケーションの要件に応じて、スケールアップ (たとえば、別の価格層の選択) するか、スケールアウト (新しいインスタンスの追加など) することで、多くの場合はこれらの制限を回避できます。
- **必要なストレージ アカウントの数を決定します。** Azure では、サブスクリプションあたり特定の数のストレージ アカウントが許可されます。 詳細については、「[Azure サブスクリプションとサービスの制限、クォータ、制約](/azure/azure-subscription-service-limits/#storage-limits)」をご覧ください。
- **Azure SQL Database に適したサービス層を選択します。** アプリケーションで Azure SQL Database を使う場合は、適切なサービス レベルを選択します。 アプリケーションのデータベース トランザクション ユニット (DTU) の要件を処理できないレベルでは、データの使用が調整されます。 適切なサービス プランの選択の詳細については、「[SQL Database のオプションとパフォーマンス:各サービス階層で使用できる内容について理解します](/azure/sql-database/sql-database-service-tiers/)」をご覧ください。
- **Azure Cosmos DB で十分な要求ユニット (RU) をプロビジョニングします**。 Azure Cosmos DB では、プロビジョニングするスループットおよび消費するストレージに対して時間単位で支払います。 すべてのデータベース操作のコストは RU として正規化され、CPU、IOPS、メモリなどのシステム リソースが抽象化されます。 詳細については、「[Azure Cosmos DB の要求ユニット](/azure/cosmos-db/request-units)」をご覧ください。

## <a name="load-balance-as-needed"></a>必要に応じて負荷分散する

適切に負荷分散すると、可用性の要件を満たし、可用性に関連するコストを最小限にできます。

- **負荷分散を使用して要求を分散します。** 負荷分散は、正常でないインスタンスをローテーションから除去することで、アプリケーションの要求を正常なサービス インスタンスに分散します。 サービスで Azure App Service または Azure Cloud Services が使われている場合は、既に負荷が分散されています。 ただし、アプリケーションが Azure VM を使用している場合は、ロード バランサーをプロビジョニングする必要があります。 詳細については、「[Azure Load Balancer の概要](/azure/load-balancer/load-balancer-overview/)」を参照してください。

  Azure Load Balancer を使って次のことができます。

  - 受信インターネット トラフィックを VM に負荷分散します。 この構成は、[*パブリック ロード バランサー*](/azure/load-balancer/load-balancer-overview#publicloadbalancer)と呼ばれます。
  - 仮想ネットワーク内の VM 間にトラフィックを負荷分散します。 ハイブリッド シナリオでは、オンプレミスのネットワークから Load Balancer フロントエンドに到達することもできます。 どちらのシナリオでも、[*内部ロード バランサー*](/azure/load-balancer/load-balancer-overview#internalloadbalancer)と呼ばれる構成が使われます。
  - 受信ネットワーク アドレス変換 (NAT) 規則を使って、特定の VM 上の列挙されたポートに、トラフィックをポート転送します。
  - パブリック ロード バランサー を使って、仮想ネットワーク内の VM に[送信接続](/azure/load-balancer/load-balancer-outbound-connections)を提供します。

- **Azure Traffic Manager などのトラフィック マネージャーで、リージョン間に負荷を分散します。** リージョン間でトラフィックの負荷分散を行うためには、トラフィック管理ソリューションが必要であり、Azure では [Traffic Manager](https://azure.microsoft.com/services/traffic-manager/) が提供されています。 また、同様のトラフィック管理機能が提供されているサードパーティのサービスを利用することもできます。

## <a name="implement-resiliency-strategies"></a>回復性戦略を実装する

このセクションでは、いくつかの一般的な回復性戦略について説明します。 これらの戦略のほとんどは、特定のテクノロジに限定されていません。 説明では、各手法の背後にある一般的な考えがまとめられており、詳細なドキュメントへのリンクが含まれます。

- 必要に応じて、リモート操作に対する**回復性パターンを実装します**。 アプリケーションがリモート サービス間の通信に依存する場合は、一時的な障害に対処するための[設計パターン](../patterns/category/resiliency.md)に従います。

- **一時的な障害を再試行します。** これらは、ネットワーク接続の一時的な喪失、データベース接続の欠落、またはサービスがビジー状態のときのタイムアウトが原因で発生します。 多くの場合、一時的な障害は、要求を再試行することで解決できます。

  - 多くの Azure サービスでは、クライアント ソフトウェア開発キット (SDK) において、呼び出し元には認識されない方法で自動再試行が実装されています。 「[Retry guidance for specific services](../best-practices/retry-service-specific.md)」(特定のサービスの再試行ガイダンス) をご覧ください。
  - または、[再試行パターン](../patterns/retry.md)を実装して、サービスまたはネットワーク リソースへの接続を試みるときに予想される一時エラーをアプリケーションで透過的に処理するのに役立てます。

- **サーキット ブレーカーを使って**、解決に要する時間が一定ではない場合がある障害を処理します。 [サーキット ブレーカー](../patterns/circuit-breaker.md) パターンを使用すると、失敗する可能性のある操作がアプリケーションで繰り返し再試行されるのを回避できます。 サーキット ブレーカーはサービスの呼び出しをラップし、最近発生したエラーの数を追跡します。 エラーの数がしきい値を超えると、サーキット ブレーカーはサービスを呼び出さずに、エラー コードを返し始めます。 これにより、復旧のための時間がサービスに提供され、障害の連鎖を回避するのに役立ちます。
- **重要なリソースを分離します。** 1 つのサブシステムで複数の障害が連鎖した結果、アプリケーションの他の部分で障害が発生する可能性があります。 このようなことが起きる可能性があるのは、障害によってスレッドやソケットなどのリソースが解放されず、リソースが枯渇する場合です。 これを回避すため、システムを複数の分離したグループにパーティション分割し、1 つのパーティションでの障害によりシステム全体がダウンしないようにできます。

    この手法の例をいくつか示します。これは、[バルクヘッド パターン](../patterns/bulkhead.md)と呼ばれることがあります。

  - データベースをパーティション分割し (テナント別など)、各パーティションに Web サーバー インスタンスの個別のプールを割り当てます。
  - 個別のスレッド プールを使用して、異なるサービスの呼び出しを分離します。 こうすることで、いずれかのサービスで障害が発生した場合の障害の連鎖を回避できます。 例については、Netflix の [Hystrix ライブラリ](https://medium.com/netflix-techblog/introducing-hystrix-for-resiliency-engineering-13531c1ab362)を参照してください。
  - [コンテナー](https://en.wikipedia.org/wiki/Operating-system-level_virtualization)を使って、特定のサブシステムに使用できるリソースを制限します。

      ![バルクヘッド パターンの図](_images/bulkhead.png)

- **[*補正トランザクション*](../patterns/compensating-transaction.md)を適用します**。 補正トランザクションは、別の完了したトランザクションの影響を元に戻すトランザクションです。 分散システムでは、厳密なトランザクションの一貫性を実現することが困難な場合があります。 補正トランザクションは、各手順で元に戻すことができる一連の小規模な個別トランザクションを使用することで、一貫性を実現するのに役立ちます。 たとえば、旅行を予約する場合、ユーザーは車、ホテルの客室、航空便を予約する可能性があります。 これらのステップの 1 つが失敗した場合、操作全体が失敗します。 操作全体に単一の分散トランザクションを使用するのではなく、各手順に補正トランザクションを定義することができます。
- **可能な限り、非同期操作を実装します。** 同期操作は、呼び出し元がプロセスの完了を待機している間はリソースを独占でき、その他の操作をブロックすることができます。 可能な場合は常に、アプリケーションの各部分を、非同期操作が可能なように設計します。 C\# での非同期プログラミングの実装方法の詳細については、「[非同期プログラミング](/dotnet/articles/csharp/async)」をご覧ください。

## <a name="ensure-that-availability-meets-slas"></a>可用性が SLA を満たしていることを確認する

"*可用性*" とは、システムが機能し、動作している時間の割合であり、[ソフトウェア品質の重要な要素](../guide/pillars.md)の 1 つです。 このセクションのタスクを使って、ご自分のアプリケーション アーキテクチャを可用性の観点から見直し、可用性が SLA を満たしていることを確認します。

- **すべての単一障害点を回避します。**  単一障害点が可用性に影響することを防ぐため、すべてのコンポーネント、サービス、リソース、およびコンピューティング インスタンスを複数のインスタンスとして展開する必要があります。 認証メカニズムも単一障害点になる可能性があります。 複数のインスタンスを使用するよう構成ができるように、そして自動的に障害を検出して要求を障害のないインスタンスにリダイレクトするように (プラットフォームで自動的に行われない場合)、アプリケーションを設計します。
- **サービス レベル目標に基づいてワークロードを分解します。**  サービスが重要なワークロードとあまり重要ではないワークロードで構成されている場合は、それらを異なる方法で管理し、それぞれの可用性の要件を満たすようにサービスの機能とインスタンスの数を指定します。
- **サービスの依存関係を最少化し、把握します。** 可能な限り、使用される異なるサービスの数を最小限に抑えます。 システムに存在するすべての機能とサービスの依存関係を理解していることを確認します。 特に、各依存関係での障害またはパフォーマンス低下の全体的な影響を理解します。
- **可能な限り、タスクとメッセージが "*べき等*" になるように設計します。** 操作を複数回繰り返し、同じ結果を生成できる場合、その操作はべき等です。 これにより、重複した要求による問題の発生を防ぐことができます。 前に実行された操作を繰り返すことで結果が無効にならないように、メッセージ コンシューマーとコンシューマーが実行する操作がべき等である必要があります。 これは、重複したメッセージの検出、または競合処理のためのオプティミスティックな方法を使用した一貫性の確認を意味する場合があります。
- **要求タイムアウトを構成します。** サービスとリソースが使用不可能になり、要求が失敗する原因となる場合があります。 適用するタイムアウトが、各サービスまたはリソースと、それらにアクセスしているクライアントに対して、適切であることを確認します。 コンテキストやクライアントが実行しているアクションによっては、クライアントの特定のインスタンスのタイムアウトを長くすることができる場合もあります。 タイムアウトが短いと、待機時間が非常に長いサービスとリソースで過剰な再試行操作が発生する可能性があります。 また、タイムアウトが長いと、大量の要求がキューにあり、サービスまたはリソースの応答を待機している場合にブロックが発生する可能性があります。
- **重要なトランザクションの高可用性を実装する、メッセージ ブローカーを使用します。** 多くのクラウド アプリケーションでは、非同期タスクをトリガーするためにメッセージングが使われます。 メッセージの配信を保証するために、このメッセージング システムは高可用性を実現する必要があります。 [Azure Service Bus メッセージング](/azure/service-bus-messaging)では、"*1 回以上*" というセマンティクスが実装されています。これは、メッセージが少なくとも 1 回は配信されることが保証されることを意味します。 特定の状況では、重複するメッセージが配信される可能性があります。 メッセージの処理がべき等である場合 (前の項目を参照)、繰り返しの配信は問題にはなりません。
- **高負荷のユーザーを調整します。** 少数のユーザーによって過剰な負荷が発生することがあります。 これにより、他のユーザーが影響を受け、アプリケーションの全体的な可用性が低下する可能性があります。 単一のクライアントが大量の要求を行った場合、一定期間、アプリケーションはクライアントを調整することができます。 この調整期間、アプリケーションはそのクライアントからの要求の一部またはすべてを拒否します。 調整のしきい値は、多くの場合、お客様のサービス レベルに依存します。 詳細については、「[調整パターン](../patterns/throttling.md)」を参照してください。

    調整は、クライアントが悪意を持って実行したことを必ずしも意味するものではありません。サービス クォータを超えたことだけを意味します。 場合によっては、コンシューマーが常にクォータを超えているか、動作が正しくない可能性があります。 この場合は、さらにユーザーをブロックすることがあります。 通常、このブロックを行うには、API キーまたは IP アドレス範囲をブロックします。
- **グレースフル デグラデーションを実現するようにアプリケーションを設計します。** アプリケーションの負荷が 1 つ以上の部分の容量を超えたことによって、可用性が低下し、接続が失敗する場合があります。 この問題を軽減するにはスケーリングが役立ちますが、リソースの可用性やコストなどのその他の要因によって制限に到達する可能性があります。 アプリケーションがリソースの上限に達したときに、適切なアクションを実行してユーザーへの影響を最小限に抑える必要があります。 たとえば、eコマース システムで注文処理サブシステムに負荷がかかっている場合やエラーが発生した場合は、サブシステムを一時的に無効にし、他の機能 (製品カタログの参照など) を続行することができます。 エラーが発生しているサブシステムへの要求を遅らせることが適切な場合があります。たとえば、顧客が注文を送信し、その注文を注文サブシステムが再度使用可能になったら後で処理できるように保存することができます。
- **急速なバースト イベントを適切に処理します。** ほとんどのアプリケーションでは、経時的に変化するワークロードを処理する必要があります。 自動スケーリングは負荷の処理に役立ちますが、追加のインスタンスがオンラインになり、要求を処理するまでに時間がかかる場合があります。 アクティビティのバーストによってアプリケーションが過負荷にならないようにするには、使用するサービスに対するキューに要求を入れ、キューが容量に近づいたら適切に機能が低下するように設計します。 バーストがない状況では、キューをドレインして未処理の要求を処理するのに十分なパフォーマンスと容量が確保されるようにします。 詳細については、「[キュー ベースの負荷平準化パターン](../patterns/queue-based-load-leveling.md)」を参照してください。
- **複数のコンポーネントを構成するか、複数のコンポーネントにフォールバックします。** 可能な限り、操作や既存の接続に影響を与えずに複数のインスタンスを使用するように、アプリケーションを設計します。 可用性を最大にするには、複数のインスタンスを使用してそれらの間に要求を分散させ、障害が発生したインスタンスを検出して、それに要求が送信されないようにします。
- **別のサービスまたはワークフローにフォールバックします。** たとえば、SQL Database への書き込みに失敗した場合は、一時的にデータを Blob Storage または Redis Cache に保存します。 サービスが利用可能になったときに SQL Database への書き込みを再生する方法を提供します。 場合によっては、失敗した操作に、コンポーネントまたはサービスで障害が発生してもアプリケーションが動作し続けられるような、代替のアクションが存在することがあります。 可能であれば、障害を検出し、プライマリ サービスがオフラインの間は、他のサービスに要求をリダイレクトします。
- **負荷平準化を使用してトラフィックの急増をなくします。** アプリケーションではトラフィックが急増することがあり、これによってバックエンドのサービスに大きな負荷がかかる可能性があります。 バックエンド サービスが十分にすばやく要求に応答できない場合、保留中の要求が蓄積したり、サービスによってアプリケーションが調整されたりすることがあります。 この状況を回避するために、バッファーとしてキューを使用することができます。 新しい作業項目がある場合、バックエンド サービスをすぐに呼び出すのではなく、アプリケーションで作業項目をキューに格納して非同期に実行します。 キューは、負荷のピークを平準化するバッファーとして機能します。 詳細については、「[キュー ベースの負荷平準化パターン](../patterns/queue-based-load-leveling.md)」を参照してください。

## <a name="manage-your-data"></a>データを管理する

データを管理する方法は、アプリケーションの可用性に直接関係します。 このセクションのタスクは、可用性を確保の役立つ管理計画の作成に役立てることができます。

- **データをレプリケートし、アプリケーションのデータ ストアのレプリケーション方法を理解します。** データのレプリケートは、データ ストアの一時的ではない障害を処理する場合の一般的な戦略です。 読み取りパスと書き込みパスの両方を考慮します。 ストレージのテクノロジに応じて、複数の書き込み可能レプリカがある場合、または単一の書き込み可能レプリカと複数の読み取り専用レプリカがある場合があります。 可用性を最大限にするために、レプリカを複数のリージョンに配置する方法もあります。 ただし、このアプローチでは、データをレプリケートするときの待機時間が長くなります。 通常、複数リージョンをまたがるレプリケートは非同期に行われます。これは最終的な整合性モデルであり、レプリカで障害が発生した場合にはデータ損失が発生する可能性があります。  

  [Azure Site Recovery](/azure/site-recovery/azure-to-azure-quickstart/) を使って、異なるリージョン間で Azure Virtual Machines をレプリケートすることができます。 Site Recovery では、ターゲット リージョンに、データが継続的にレプリケートされます。 プライマリ サイトで障害が発生した場合は、セカンダリの場所にフェールオーバーします。

- **1 つのユーザー アカウントで運用データとバックアップ データの両方にアクセスできることがないようにします。** 1 つのユーザー アカウントに運用とバックアップの両方のソースの両方に書き込みアクセス許可があると、データのバックアップが侵害されます。 悪意のあるユーザーはすべてのデータを意図的に削除する可能性があり、正規のユーザーは誤って削除する可能性があります。 各ユーザー アカウントのアクセス許可を制限するようにアプリケーションを設計します。 書き込みが必要なユーザーだけに、書き込みアクセスを許可します。また、運用環境またはバックアップ環境のどちらか一方に対するアクセスだけを許可し、両方へのアクセスを許可しないようにします。
- **データ ストアのフェールオーバーおよびフェールバックのプロセスをドキュメント化してテストします。** データ ストアで壊滅的な障害が発生した場合、人間のオペレーターは、文書化されている手順に従って、新しいデータ ストアにフェールオーバーする必要があります。 文書化されている手順に誤りがあると、オペレーターは適切にそれに従うことができず、リソースをフェールオーバーできなくなります。 手順の指示を定期的にテストし、ドキュメントに従うオペレーターが正常にフェールオーバーおよびフェールバックできることを確認します。
- **データをバックアップして、データのバックアップを検証します。** 定期的にスクリプトを実行してデータ整合性、スキーマ、クエリを検証し、バックアップ データが期待どおりのものであることを確認します。 バックアップ サービスを修復できるよう、不一致を記録し、レポートしてください。
- **定期的なバックアップと特定時点への復元を使用します。** どこにも保持されていないデータを、定期的かつ自動的にバックアップします。 障害が発生した場合に、データとアプリケーション自体の両方を確実に復元できることを確認します。 バックアップが、RPO を満たしていることを確認します。 データ レプリケーションはバックアップ機能ではありません。人為的なミスや悪意のある操作によって、すべてのレプリカでデータが破損する可能性があるためです。 バックアップ プロセスは、転送中のデータと格納中のデータを保護するため、セキュリティで保護する必要があります。 データベースは通常、トランザクション ログを使用して前の時点まで復旧することができます。 詳細については、「[データの破損または偶発的な削除から復旧する](../resiliency/recovery-data-corruption.md)」を参照してください。
- **geo 冗長ストレージ アカウントの使用を検討します。** Azure Storage アカウントに格納されているデータは、常にローカルでレプリケートされます。 ただし、ストレージ アカウントをプロビジョニングするときに選択するレプリケーション戦略は複数あります。 まれに発生するリージョン全体が使用できなくなったときに備えてアプリケーション データを保護するには、[Azure の読み取りアクセス geo 冗長ストレージ (RA-GRS)](/azure/storage/storage-redundancy/#read-access-geo-redundant-storage) を選択します。  

    > [!NOTE]
    > VM の場合は、RA-GRS レプリケーションを利用して VM ディスク (VHD ファイル) を復元しないでください。 代わりに、[Azure Backup](/azure/backup) を使用してください。

- **参照データを複数のリージョンにデプロイすることを検討します。** 参照データはアプリケーションの機能をサポートする読み取り専用のデータです。 通常、頻繁に変更されることはありません。 バックアップからの復元はリージョン全体にわたるサービス中断を処理する 1 つの方法ですが、RTO は比較的長くなります。 セカンダリ リージョンにアプリケーションをデプロイする場合、参照データの RTO を改善する方法がいくつかあります。

    参照データは頻繁に変化しないので、永続的なコピーをセカンダリ リージョンに保持することで、RTO を改善できます。 これにより、障害の後で時間をかけてバックアップを復元する必要がなくなります。 複数リージョンのディザスター リカバリーの要件を満たすには、アプリケーションと参照データを一緒に複数のリージョンにデプロイする必要があります。

- **オプティミスティック同時実行制御と最終的な整合性を使用します。** ロックによってリソースへのアクセスをブロックするトランザクション (*ペシミスティック同時実行制御*) では、パフォーマンスと可用性が低下する場合があります。 これらの問題は、分散システムで特に深刻になります。 多くの場合、パーティション分割などの入念な設計や技法によって、更新の競合が発生する可能性を最小限に抑えることができます。 データがレプリケートされたり、個別に更新されたスコアから読み取られたりする場合は、データは最終段階でのみ整合性が確保されます。 ただし、通常、その利点は、トランザクションを使用して即時整合性を保証することの可用性に対する影響を大きく上回ります。
- **SQL Database 用のアクティブ geo レプリケーションを使用して、変更をセカンダリ データベースにレプリケートします。** SQL Database 用のアクティブ geo レプリケーションでは、データベースの変更が、同じリージョンまたは別のリージョンのセカンダリ データベースに、自動的にレプリケートされます。 詳細については、「[アクティブ geo レプリケーションの作成と使用](/azure/sql-database/sql-database-active-geo-replication)」を参照してください。

  または、**DATABASE COPY** コマンドを使ってトランザクションの一貫性を保つデータベースのバックアップ コピーを作成するという、より手動的なアプローチを使用できます。 Azure SQL Database のインポート/エクスポート サービスを使用することもできます。このサービスでは、Azure Blob Storage に格納されている BACPAC ファイル (ご利用のデータベース スキーマおよび関連するデータを含む圧縮されたファイル) へのデータベースのエクスポートをサポートします。 Azure Storage では、バックアップ ファイルの 2 個のレプリカが同じリージョンに作成されます。 ただし、バックアップ プロセスの頻度により、障害シナリオで失われる可能性があるデータ量を表す RPO が決まります。 たとえば、1 時間ごとにデータをバックアップする場合、バックアップの 2 分前に障害が発生すると、58 分間のデータが失われます。 また、リージョン全体のサービス中断を防ぐには、BACPAC ファイルを代替リージョンにコピーする必要があります。 詳細については、「[Azure SQL Database によるビジネス継続性の概要](/azure/sql-database/sql-database-business-continuity)」を参照してください。

- **SQL Data Warehouse の geo バックアップを使用します。** SQL Data Warehouse については、[geo バックアップ](/azure/sql-data-warehouse/backup-and-restore)を使用して、ディザスター リカバリー用のペア リージョンに復元します。 これらのバックアップは、24 時間ごとに作成され、20 分以内にペア リージョンに復元できます。 この機能は、すべての SQL Data Warehouse インスタンスに対して既定で有効になります。 データ ウェアハウスを復元する方法の詳細については、「[PowerShell を使用して Azure 地理的リージョンから復元する](/azure/sql-data-warehouse/sql-data-warehouse-restore)」を参照してください。

- **Azure Site Recovery を使用して VM ディスクをレプリケートします。** [Site Recovery](/azure/site-recovery/) を使用して Azure VM をレプリケートすると、すべての VM ディスクが、ターゲット リージョンに継続的かつ非同期的にレプリケートされます。 復旧ポイントは数分ごとに作成されます。 これにより、RPO は分単位になります。
- **VM で実行されている SQL Server をバックアップするか、またはログ配布セッションを構成します。** VM 上で実行される SQL Server の場合、従来のバックアップとログ配布の 2 つのオプションがあります。 従来のバックアップを使用すると、特定の時点の状態に復元できますが、復旧プロセスに時間がかかります。 従来のバックアップを復元するには、最初に完全バックアップから開始し、その後にそれ以降に作成されたバックアップを適用する必要があります。 2 番目のオプションでは、ログ バックアップの復元を (たとえば 2 時間) 遅延するログ配布セッションを構成します。 これにより、プライマリで発生したエラーから回復するための時間が確保されます。
- **Azure Storage のバックアップに対してカスタム プロセスまたはサード パーティ製ツールを使用します。** Azure Storage の場合、カスタム バックアップ プロセスを開発したり、サード パーティ製のバックアップ ツールを使用したりすることができます。 ほとんどのアプリケーション設計では、ストレージ リソース間の相互参照によって複雑さが増します。 たとえば、Azure Storage の BLOB にリンクしている列を含む SQL データベースがあるものとします。 バックアップが同時に実行されない場合、データベースには、障害発生前にバックアップされなかった BLOB へのポインターが含まれる可能性があります。 アプリケーションまたはディザスター リカバリー計画では、復旧後のこのような不整合を処理するプロセスを実装する必要があります。
- **VM でホストされている他のデータ プラットフォームに対してネイティブのレプリケーション機能またはスナップショット機能を使用します。** Elasticsearch や MongoDB など、他のデータ プラットフォームには、バックアップと復元の統合プロセスを作成するときに、独自の機能および考慮事項があります。 これらのデータ プラットフォームに対して、一般に、ネイティブの、または利用可能な統合に基づく、レプリケーション機能またはスナップショット機能を使うことをお勧めします。 そのような機能が存在しないか、または適切でない場合は、Azure Backup サービスまたはディスク スナップショットを使って、アプリケーション データの特定時点のコピーを作成することを検討します。 すべてのケースにおいて、一貫性のあるバックアップを実現する方法を決定することが重要です。これは、アプリケーション データが複数のファイル システムにまたがる場合や、複数のドライブが 1 つのファイル システムに結合されている場合に特に重要です。
- **アプリケーションのデータ ソースのレプリケーション方法を理解します。** アプリケーション データは、さまざまなデータ ソースに格納され、さまざまな可用性の要件を持ちます。 アプリケーションのデータ要件が確実に満たされるように、[Azure Storage の冗長性](/azure/storage/storage-redundancy/)や [SQL Database のアクティブ geo レプリケーション](/azure/sql-database/sql-database-geo-replication-overview/)など、Azure のデータ ストレージの種類ごとに、レプリケーションの方法を評価します。 [Site Recovery](/azure/site-recovery/) を使って Azure VM をレプリケートすると、すべての VM ディスクが、ターゲット リージョンに継続的かつ非同期的にレプリケートされます。 復旧ポイントは数分ごとに作成されます。
- **ディザスター リカバリーのためのデータ戦略を確立します。** 適切なデータ処理は、すべてのディザスター リカバリー計画における難しい課題です。 通常、回復プロセス中はデータの復元に最も時間がかかります。 機能を削減するためのさまざまな選択肢は、データ復旧および一貫性に対する困難な課題になります。

## <a name="next-steps"></a>次の手順

> [!div class="nextstepaction"]
> [回復性と可用性をテストする](./testing.md)
