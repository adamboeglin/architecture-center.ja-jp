---
title: リレーショナル データ
description: ''
author: zoinerTejada
ms.date: 02/12/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.openlocfilehash: d68bddcb75e5c8f786a7739e85de2645a2c3d641
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58345415"
---
# <a name="traditional-relational-database-solutions"></a><span data-ttu-id="9a912-102">従来のリレーショナル データベース ソリューション</span><span class="sxs-lookup"><span data-stu-id="9a912-102">Traditional relational database solutions</span></span>

<span data-ttu-id="9a912-103">リレーショナル データは、リレーショナル モデルを使用してモデル化されたデータです。</span><span class="sxs-lookup"><span data-stu-id="9a912-103">Relational data is data modeled using the relational model.</span></span> <span data-ttu-id="9a912-104">このモデルでは、データは、タプルとして表現されます。</span><span class="sxs-lookup"><span data-stu-id="9a912-104">In this model, data is expressed as tuples.</span></span> <span data-ttu-id="9a912-105">"*タプル*" は、属性/値のペアのセットです。</span><span class="sxs-lookup"><span data-stu-id="9a912-105">A *tuple* is a set of attribute/value pairs.</span></span> <span data-ttu-id="9a912-106">たとえば、タプルは、(itemid = 5, orderid = 1, item = "Chair", amount = 200.00) のようになります。</span><span class="sxs-lookup"><span data-stu-id="9a912-106">For example, a tuple might be (itemid = 5, orderid = 1, item = "Chair", amount = 200.00).</span></span> <span data-ttu-id="9a912-107">すべてが同じ属性を共有するタプルのセットは、"*リレーション*" と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9a912-107">A set of tuples that all share the same attributes is called a *relation*.</span></span>

<span data-ttu-id="9a912-108">リレーションは必然的にテーブルとして表現され、各タプルがテーブルの行として公開されます。</span><span class="sxs-lookup"><span data-stu-id="9a912-108">Relations are naturally represented as tables, where each tuple is exposed as a row in the table.</span></span> <span data-ttu-id="9a912-109">ただし、タプルとは異なり、行には明示的な順序があります。</span><span class="sxs-lookup"><span data-stu-id="9a912-109">However, rows have an explicit ordering, unlike tuples.</span></span> <span data-ttu-id="9a912-110">各テーブルの列 (見出し) は、データベース スキーマが定義します。</span><span class="sxs-lookup"><span data-stu-id="9a912-110">The database schema defines the columns (headings) of each table.</span></span> <span data-ttu-id="9a912-111">各列には、名前と、テーブル内のすべての行のその列に格納されるすべての値のデータ型が定義されます。</span><span class="sxs-lookup"><span data-stu-id="9a912-111">Each column is defined with a name and a data type for all values stored in that column across all rows in the table.</span></span>

![リレーショナル データベースを使用したデータの表示例](../images/example-relational.png)

<span data-ttu-id="9a912-113">リレーショナル モデルを使用してデータを編成しているデータ ストアは、リレーショナル データベースと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="9a912-113">A data store that organizes data using the relational model is referred to as a relational database.</span></span> <span data-ttu-id="9a912-114">プライマリ キーは、テーブル内の行を一意に識別します。</span><span class="sxs-lookup"><span data-stu-id="9a912-114">Primary keys uniquely identify rows within a table.</span></span> <span data-ttu-id="9a912-115">外部キー フィールドは 1 つのテーブルで使用され、別のテーブルの主キーを参照することで参照先のテーブル内の行を参照します。</span><span class="sxs-lookup"><span data-stu-id="9a912-115">Foreign key fields are used in one table to refer to a row in another table by referencing the primary key of the other table.</span></span> <span data-ttu-id="9a912-116">外部キーは参照整合性を維持するために使用され、参照元の行が参照先の行に依存している間、参照先の行が変更されることも削除されることもないことを保証します。</span><span class="sxs-lookup"><span data-stu-id="9a912-116">Foreign keys are used to maintain referential integrity, ensuring that the referenced rows are not altered or deleted while the referencing row depends on them.</span></span>

![リレーショナル データベースを使用したデータの表示例](../images/example-relational2.png)

<span data-ttu-id="9a912-118">リレーショナル データベースでは、データの整合性を保証するために役立つさまざまな種類の制約をサポートします。</span><span class="sxs-lookup"><span data-stu-id="9a912-118">Relational databases support various types of constraints that help to ensure data integrity:</span></span>

- <span data-ttu-id="9a912-119">一意制約は、列内のすべての値が一意であることを保証します。</span><span class="sxs-lookup"><span data-stu-id="9a912-119">Unique constraints ensure that all values in a column are unique.</span></span>

- <span data-ttu-id="9a912-120">外部キー制約は、2 つのテーブル内のデータ間のリンクを強化します。</span><span class="sxs-lookup"><span data-stu-id="9a912-120">Foreign key constraints enforce a link between the data in two tables.</span></span> <span data-ttu-id="9a912-121">外部キーは、別のテーブルの主キーまたは別の一意キーを参照します。</span><span class="sxs-lookup"><span data-stu-id="9a912-121">A foreign key references the primary key or another unique key from another table.</span></span> <span data-ttu-id="9a912-122">外部キー制約は参照整合性を強化し、外部キーの値を無効にする変更を禁止します。</span><span class="sxs-lookup"><span data-stu-id="9a912-122">A foreign key constraint enforces referential integrity, disallowing changes that cause invalid foreign key values.</span></span>

- <span data-ttu-id="9a912-123">Check 制約 (エンティティの整合性制約とも呼ばれます) は、1 つの列に格納できる値を制限します。リレーションの場合は、同じ行の他の列の値に制限します。</span><span class="sxs-lookup"><span data-stu-id="9a912-123">Check constraints, also known as entity integrity constraints, limit the values that can be stored within a single column, or in relationship to values in other columns of the same row.</span></span>

<span data-ttu-id="9a912-124">ほとんどのリレーショナル データベースでは、クエリの実行に対して宣言型の方法を実行できるように構造化照会言語 (SQL) 言語を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a912-124">Most relational databases use the Structured Query Language (SQL) language that enables a declarative approach to querying.</span></span> <span data-ttu-id="9a912-125">このクエリは目的の結果を記述しますが、クエリを実行する手順は記述しません。</span><span class="sxs-lookup"><span data-stu-id="9a912-125">The query describes the desired result, but not the steps to execute the query.</span></span> <span data-ttu-id="9a912-126">クエリを実行する最善の方法はエンジンが決定します。</span><span class="sxs-lookup"><span data-stu-id="9a912-126">The engine then decides the best way to execute the query.</span></span> <span data-ttu-id="9a912-127">これは、クエリ プログラムが処理手順を明示的に指定する手続き型の方法とは異なります。</span><span class="sxs-lookup"><span data-stu-id="9a912-127">This differs from a procedural approach, where the query program specifies the processing steps explicitly.</span></span> <span data-ttu-id="9a912-128">ただし、リレーショナル データベースでは、実行可能コードのルーチンをストアド プロシージャと関数の形式で保存でき、それによって宣言型と手続き型の方法を混在させることができます。</span><span class="sxs-lookup"><span data-stu-id="9a912-128">However, relational databases can store executable code routines in the form of stored procedures and functions, which enables a mixture of declarative and procedural approaches.</span></span>

<span data-ttu-id="9a912-129">クエリのパフォーマンスを向上させるため、リレーショナル データベースでは "*インデックス* " を使用します。</span><span class="sxs-lookup"><span data-stu-id="9a912-129">To improve query performance, relational databases use *indexes*.</span></span> <span data-ttu-id="9a912-130">プライマリ インデックスは主キーによって使用され、ディスク上に配置されるデータの順序を定義します。</span><span class="sxs-lookup"><span data-stu-id="9a912-130">Primary indexes, which are used by the primary key, define the order of the data as it sits on disk.</span></span> <span data-ttu-id="9a912-131">セカンダリ インデックスはフィールドの別の組み合わせを提供します。このため、目的の行を効率的にクエリでき、ディスク上のデータ全体を再度並べ替える必要はありません。</span><span class="sxs-lookup"><span data-stu-id="9a912-131">Secondary indexes provide an alternative combination of fields, so the desired rows can be queried efficiently, without having to re-sort the entire data on disk.</span></span>

<span data-ttu-id="9a912-132">リレーショナル データベースでは参照整合性を維持する必要があるため、リレーショナル データベースのスケーリングは困難になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="9a912-132">Because relational databases enforce referential integrity, scaling a relational database can become challenging.</span></span> <span data-ttu-id="9a912-133">その理由は、クエリまたは挿入操作でアクセスするテーブルの数が一定ではないためです。</span><span class="sxs-lookup"><span data-stu-id="9a912-133">That's because any query or insert operation might touch any number of tables.</span></span> <span data-ttu-id="9a912-134">リレーショナル データベースは、データを "*シャーディング*" することでスケール アウトできますが、これを行うには、スキーマを慎重に設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="9a912-134">You can scale out a relational database by *sharding* the data, but this requires careful design of the schema.</span></span> <span data-ttu-id="9a912-135">詳細については、「[シャーディング パターン](../../patterns/sharding.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="9a912-135">For more information, see the [Sharding pattern](../../patterns/sharding.md).</span></span>

<span data-ttu-id="9a912-136">データがリレーショナルでない、またはリレーショナル データベースに適していない要件がある場合は、[非リレーショナルまたは NoSQL](../big-data/non-relational-data.md) データ ストアを検討してください。</span><span class="sxs-lookup"><span data-stu-id="9a912-136">If data is non-relational or has requirements that are not suited to a relational database, consider a [Non-relational or NoSQL](../big-data/non-relational-data.md) data store.</span></span>
