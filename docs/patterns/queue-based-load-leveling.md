---
title: キュー ベースの負荷平準化パターン
titleSuffix: Cloud Design Patterns
description: タスクとそのタスクが呼び出すサービスとの間でバッファーとして機能するキューを使用して、断続的な大きい負荷を平準化します。
keywords: 設計パターン
author: dragon119
ms.date: 01/02/2019
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: c736afced1b0478e8eb1a2694acc4d6a6f0c62fc
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58248727"
---
# <a name="queue-based-load-leveling-pattern"></a><span data-ttu-id="bb643-104">キュー ベースの負荷平準化パターン</span><span class="sxs-lookup"><span data-stu-id="bb643-104">Queue-Based Load Leveling pattern</span></span>

<span data-ttu-id="bb643-105">タスクとそのタスクが呼び出すサービスの間のバッファーとして機能するキューを使用して、サービスの障害やタスクのタイム アウトが発生する場合がある断続的な大きい負荷を平準化します。これは、タスクとサービスの両方の可用性と応答性の需要ピークへの影響を最小限に抑えるのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bb643-105">Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks in demand on availability and responsiveness for both the task and the service.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="bb643-106">コンテキストと問題</span><span class="sxs-lookup"><span data-stu-id="bb643-106">Context and problem</span></span>

<span data-ttu-id="bb643-107">クラウド内の多くのソリューションでは、サービスを呼び出すタスクを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-107">Many solutions in the cloud involve running tasks that invoke services.</span></span> <span data-ttu-id="bb643-108">この環境では、サービスに断続的に大きい負荷がかかると、パフォーマンスまたは信頼性の問題が発生する場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-108">In this environment, if a service is subjected to intermittent heavy loads, it can cause performance or reliability issues.</span></span>

<span data-ttu-id="bb643-109">サービスはそのサービスを使用するタスクと同じソリューションの一部である場合や、キャッシュまたはストレージ サービスなどの頻繁に使用されるリソースへのアクセスを提供するサードパーティのサービスである場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-109">A service could be part of the same solution as the tasks that use it, or it could be a third-party service providing access to frequently used resources such as a cache or a storage service.</span></span> <span data-ttu-id="bb643-110">同じサービスが同時に実行されている多数のタスクで使用されると、サービスに対する要求のボリュームを常に予測するのが困難になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-110">If the same service is used by a number of tasks running concurrently, it can be difficult to predict the volume of requests to the service at any time.</span></span>

<span data-ttu-id="bb643-111">サービスの需要がピークに達する可能性があります。その場合、過負荷となり、適時に要求に応答できなくなります。</span><span class="sxs-lookup"><span data-stu-id="bb643-111">A service might experience peaks in demand that cause it to overload and be unable to respond to requests in a timely manner.</span></span> <span data-ttu-id="bb643-112">多数の同時要求がサービスに殺到すると、これらの要求が原因の競合を処理できない場合にサービス障害が発生することもあります。</span><span class="sxs-lookup"><span data-stu-id="bb643-112">Flooding a service with a large number of concurrent requests can also result in the service failing if it's unable to handle the contention these requests cause.</span></span>

## <a name="solution"></a><span data-ttu-id="bb643-113">解決策</span><span class="sxs-lookup"><span data-stu-id="bb643-113">Solution</span></span>

<span data-ttu-id="bb643-114">ソリューションをリファクタリングし、タスクとサービス間でキューを導入します。</span><span class="sxs-lookup"><span data-stu-id="bb643-114">Refactor the solution and introduce a queue between the task and the service.</span></span> <span data-ttu-id="bb643-115">タスクとサービスを非同期に実行します。</span><span class="sxs-lookup"><span data-stu-id="bb643-115">The task and the service run asynchronously.</span></span> <span data-ttu-id="bb643-116">タスクは、キューにサービスで必要なデータを含むメッセージを投稿します。</span><span class="sxs-lookup"><span data-stu-id="bb643-116">The task posts a message containing the data required by the service to a queue.</span></span> <span data-ttu-id="bb643-117">キューは、サービスが取得するまでメッセージを格納するバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="bb643-117">The queue acts as a buffer, storing the message until it's retrieved by the service.</span></span> <span data-ttu-id="bb643-118">サービスはキューからメッセージを取得して処理します。</span><span class="sxs-lookup"><span data-stu-id="bb643-118">The service retrieves the messages from the queue and processes them.</span></span> <span data-ttu-id="bb643-119">さまざま速度で生成可能な、多数のタスクからの要求は、同じメッセージ キューを通じてサービスに渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="bb643-119">Requests from a number of tasks, which can be generated at a highly variable rate, can be passed to the service through the same message queue.</span></span> <span data-ttu-id="bb643-120">以下の図は、キューを使用したサービス負荷の平準化を示しています。</span><span class="sxs-lookup"><span data-stu-id="bb643-120">This figure shows using a queue to level the load on a service.</span></span>

![図 1 - キューを使用したサービス負荷の平準化](./_images/queue-based-load-leveling-pattern.png)

<span data-ttu-id="bb643-122">キューはサービスからタスクを切り離すため、サービスは、同時タスクからの要求のボリュームに関係なく、独自のペースでメッセージを処理できます。</span><span class="sxs-lookup"><span data-stu-id="bb643-122">The queue decouples the tasks from the service, and the service can handle the messages at its own pace regardless of the volume of requests from concurrent tasks.</span></span> <span data-ttu-id="bb643-123">また、サービスがキューにメッセージを投稿したときに使用できない場合でも、タスクの遅延は発生しません。</span><span class="sxs-lookup"><span data-stu-id="bb643-123">Additionally, there's no delay to a task if the service isn't available at the time it posts a message to the queue.</span></span>

<span data-ttu-id="bb643-124">このパターンには次のような利点があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-124">This pattern provides the following benefits:</span></span>

- <span data-ttu-id="bb643-125">サービスで発生する遅延がすぐにアプリケーションに直接影響することはないため、可用性を最大化するのに役立ちます。サービスが使用できない場合や、現在、メッセージを処理していない場合であっても、キューにメッセージを継続的に投稿できます。</span><span class="sxs-lookup"><span data-stu-id="bb643-125">It can help to maximize availability because delays arising in services won't have an immediate and direct impact on the application, which can continue to post messages to the queue even when the service isn't available or isn't currently processing messages.</span></span>
- <span data-ttu-id="bb643-126">需要を満たすためにキューの数とサービスの数の両方を変更できるため、スケーラビリティを最大化するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bb643-126">It can help to maximize scalability because both the number of queues and the number of services can be varied to meet demand.</span></span>
- <span data-ttu-id="bb643-127">ピーク時の負荷ではなく、平均負荷に対応するのに十分な数のサービス インスタンスをデプロイするだけでよいため、コスト管理に役立ちます。</span><span class="sxs-lookup"><span data-stu-id="bb643-127">It can help to control costs because the number of service instances deployed only have to be adequate to meet average load rather than the peak load.</span></span>

    >  <span data-ttu-id="bb643-128">一部のサービスでは、それを超えるとシステムで障害が発生する可能性があるしきい値に需要が達した場合に、スロットルを実装します。</span><span class="sxs-lookup"><span data-stu-id="bb643-128">Some services implement throttling when demand reaches a threshold beyond which the system could fail.</span></span> <span data-ttu-id="bb643-129">スロットルにより使用可能な機能を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="bb643-129">Throttling can reduce the functionality available.</span></span> <span data-ttu-id="bb643-130">このしきい値に達しないように、これらのサービスの負荷を平準化することができます。</span><span class="sxs-lookup"><span data-stu-id="bb643-130">You can implement load leveling with these services to ensure that this threshold isn't reached.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="bb643-131">問題と注意事項</span><span class="sxs-lookup"><span data-stu-id="bb643-131">Issues and considerations</span></span>

<span data-ttu-id="bb643-132">このパターンの実装方法を決めるときには、以下の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="bb643-132">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="bb643-133">ターゲット リソースが過多にならないように、サービスによるメッセージの処理速度を制御するアプリケーション ロジックを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-133">It's necessary to implement application logic that controls the rate at which services handle messages to avoid overwhelming the target resource.</span></span> <span data-ttu-id="bb643-134">システムの次のステージで需要が急増しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="bb643-134">Avoid passing spikes in demand to the next stage of the system.</span></span> <span data-ttu-id="bb643-135">負荷がかかっているシステムをテストし、必要な平準化が行われることを確認し、キューの数とメッセージを処理するサービス インスタンスの数を調整してください。</span><span class="sxs-lookup"><span data-stu-id="bb643-135">Test the system under load to ensure that it provides the required leveling, and adjust the number of queues and the number of service instances that handle messages to achieve this.</span></span>
- <span data-ttu-id="bb643-136">メッセージ キューは一方向の通信メカニズムです。</span><span class="sxs-lookup"><span data-stu-id="bb643-136">Message queues are a one-way communication mechanism.</span></span> <span data-ttu-id="bb643-137">タスクがサービスからの応答を予期している場合、サービスが応答を送信するために使用できるメカニズムを実装する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-137">If a task expects a reply from a service, it might be necessary to implement a mechanism that the service can use to send a response.</span></span> <span data-ttu-id="bb643-138">詳細については、「[非同期メッセージングの基本](https://msdn.microsoft.com/library/dn589781.aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb643-138">For more information, see the [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span>
- <span data-ttu-id="bb643-139">キューで要求をリッスンしているサービスに自動スケールを適用する場合は注意してください。</span><span class="sxs-lookup"><span data-stu-id="bb643-139">Be careful if you apply autoscaling to services that are listening for requests on the queue.</span></span> <span data-ttu-id="bb643-140">これにより、サービスが共有するすべてのリソースの競合が増え、負荷を平準化するためのキューの使用効果が弱まる場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-140">This can result in increased contention for any resources that these services share and diminish the effectiveness of using the queue to level the load.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="bb643-141">このパターンを使用する状況</span><span class="sxs-lookup"><span data-stu-id="bb643-141">When to use this pattern</span></span>

<span data-ttu-id="bb643-142">このパターンは、過負荷になる可能性のあるサービスを使用するすべてのアプリケーションに有効です。</span><span class="sxs-lookup"><span data-stu-id="bb643-142">This pattern is useful to any application that uses services that are subject to overloading.</span></span>

<span data-ttu-id="bb643-143">アプリケーションが最短の待機時間でサービスからの応答を予期している場合、このパターンは有効ではありません。</span><span class="sxs-lookup"><span data-stu-id="bb643-143">This pattern isn't useful if the application expects a response from the service with minimal latency.</span></span>

## <a name="example"></a><span data-ttu-id="bb643-144">例</span><span class="sxs-lookup"><span data-stu-id="bb643-144">Example</span></span>

<span data-ttu-id="bb643-145">Web アプリでは、外部データ ストアにデータを書き込みます。</span><span class="sxs-lookup"><span data-stu-id="bb643-145">A web app writes data to an external data store.</span></span> <span data-ttu-id="bb643-146">Web アプリの多くのインスタンスが同時に実行されている場合、データ ストアでは要求に迅速に応答できない可能性があります。これにより、要求がタイムアウトになるか、調整されるか、それ以外の場合は失敗します。</span><span class="sxs-lookup"><span data-stu-id="bb643-146">If a large number of instances of the web app run concurrently, the data store might be unable to respond to requests quickly enough, causing requests to time out, be throttled, or otherwise fail.</span></span> <span data-ttu-id="bb643-147">以下の図は、アプリケーションのインスタンスからの多くの同時要求がデータ ストアに殺到している様子を示しています。</span><span class="sxs-lookup"><span data-stu-id="bb643-147">The following diagram shows a data store being overwhelmed by a large number of concurrent requests from instances of an application.</span></span>

![図 2 - Web アプリのインスタンスからの多くの同時要求がサービスに殺到している様子](./_images/queue-based-load-leveling-overwhelmed.png)

<span data-ttu-id="bb643-149">これを解決するために、キューを使用して、アプリケーション インスタンスとデータ ストア間の負荷を平準化することができます。</span><span class="sxs-lookup"><span data-stu-id="bb643-149">To resolve this, you can use a queue to level the load between the application instances and the data store.</span></span> <span data-ttu-id="bb643-150">Azure 関数アプリではメッセージをキューから読み取り、データ ストアへの読み取り/書き込み要求を実行します。</span><span class="sxs-lookup"><span data-stu-id="bb643-150">An Azure Functions app reads the messages from the queue and performs the read/write requests to the data store.</span></span> <span data-ttu-id="bb643-151">関数アプリのアプリケーション ロジックでは、データ ストアの過負荷を防ぐために、データ ストアに要求を渡す速度を制御できます </span><span class="sxs-lookup"><span data-stu-id="bb643-151">The application logic in the function app can control the rate at which it passes requests to the data store, to prevent the store from being overwhelmed.</span></span> <span data-ttu-id="bb643-152">(それ以外の場合、関数アプリではバック エンドで同じ問題が再発するだけです)。</span><span class="sxs-lookup"><span data-stu-id="bb643-152">(Otherwise the function app will just re-introduce the same problem at the back end.)</span></span>

![図 3 - キューと関数アプリを使用した負荷の平準化](./_images/queue-based-load-leveling-function.png)



## <a name="related-patterns-and-guidance"></a><span data-ttu-id="bb643-154">関連のあるパターンとガイダンス</span><span class="sxs-lookup"><span data-stu-id="bb643-154">Related patterns and guidance</span></span>

<span data-ttu-id="bb643-155">このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-155">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="bb643-156">[非同期メッセージングの基本](https://msdn.microsoft.com/library/dn589781.aspx)。</span><span class="sxs-lookup"><span data-stu-id="bb643-156">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="bb643-157">メッセージ キューでは本質的に非同期です。</span><span class="sxs-lookup"><span data-stu-id="bb643-157">Message queues are inherently asynchronous.</span></span> <span data-ttu-id="bb643-158">サービスとの直接通信からメッセージ キューの使用にまで適応される場合は、タスクでアプリケーション ロジックを再設計する必要がある可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-158">It might be necessary to redesign the application logic in a task if it's adapted from communicating directly with a service to using a message queue.</span></span> <span data-ttu-id="bb643-159">同様に、メッセージ キューからの要求を受け入れるためにサービスをリファクタリングする必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-159">Similarly, it might be necessary to refactor a service to accept requests from a message queue.</span></span> <span data-ttu-id="bb643-160">例に示されているように、プロキシ サービスを実装できる場合もあります。</span><span class="sxs-lookup"><span data-stu-id="bb643-160">Alternatively, it might be possible to implement a proxy service, as described in the example.</span></span>

- <span data-ttu-id="bb643-161">[競合コンシューマー パターン](./competing-consumers.md)。</span><span class="sxs-lookup"><span data-stu-id="bb643-161">[Competing Consumers pattern](./competing-consumers.md).</span></span> <span data-ttu-id="bb643-162">それぞれが負荷平準化キューのメッセージ コンシューマーとして機能する、サービスの複数のインスタンスを実行できる場合があります。</span><span class="sxs-lookup"><span data-stu-id="bb643-162">It might be possible to run multiple instances of a service, each acting as a message consumer from the load-leveling queue.</span></span> <span data-ttu-id="bb643-163">この方法を使用して、メッセージを受信してサービスに渡す速度を調整することができます。</span><span class="sxs-lookup"><span data-stu-id="bb643-163">You can use this approach to adjust the rate at which messages are received and passed to a service.</span></span>

- <span data-ttu-id="bb643-164">[スロットル パターン](./throttling.md)。</span><span class="sxs-lookup"><span data-stu-id="bb643-164">[Throttling pattern](./throttling.md).</span></span> <span data-ttu-id="bb643-165">サービスでスロットルを実装する簡単な方法は、キュー ベースの負荷平準化を使用し、メッセージ キューを通じてすべての要求をサービスにルーティングすることです。</span><span class="sxs-lookup"><span data-stu-id="bb643-165">A simple way to implement throttling with a service is to use queue-based load leveling and route all requests to a service through a message queue.</span></span> <span data-ttu-id="bb643-166">サービスは、必要なリソースを使い切らない速度で要求を処理し、発生する可能性のある競合量を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="bb643-166">The service can process requests at a rate that ensures that resources required by the service aren't exhausted, and to reduce the amount of contention that could occur.</span></span>

- <span data-ttu-id="bb643-167">[Azure メッセージング サービスの選択](/azure/event-grid/compare-messaging-services)。</span><span class="sxs-lookup"><span data-stu-id="bb643-167">[Choose between Azure messaging services](/azure/event-grid/compare-messaging-services).</span></span> <span data-ttu-id="bb643-168">Azure アプリケーションのメッセージングおよびキューイング メカニズムの選択に関する情報です。</span><span class="sxs-lookup"><span data-stu-id="bb643-168">Information about choosing a messaging and queuing mechanism in Azure applications.</span></span>

- <span data-ttu-id="bb643-169">[Azure Web アプリケーションのスケーラビリティの向上](../reference-architectures/app-service-web-app/scalable-web-app.md)。</span><span class="sxs-lookup"><span data-stu-id="bb643-169">[Improve scalability in an Azure web application](../reference-architectures/app-service-web-app/scalable-web-app.md).</span></span> <span data-ttu-id="bb643-170">この参照アーキテクチャには、アーキテクチャの一部として、キュー ベースの負荷の平準化が含まれています。</span><span class="sxs-lookup"><span data-stu-id="bb643-170">This reference architecture includes queue-based load leveling as part of the architecture.</span></span>
