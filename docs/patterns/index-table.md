---
title: インデックス テーブル パターン
titleSuffix: Cloud Design Patterns
description: クエリによって頻繁に参照されるデータ ストア内のフィールドにインデックスを作成します。
keywords: 設計パターン
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: e3373a50ba6298f7985182b7be244db5f6eaa703
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58249297"
---
# <a name="index-table-pattern"></a><span data-ttu-id="77b55-104">インデックス テーブル パターン</span><span class="sxs-lookup"><span data-stu-id="77b55-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="77b55-105">クエリによって頻繁に参照されるデータ ストア内のフィールドにインデックスを作成します。</span><span class="sxs-lookup"><span data-stu-id="77b55-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="77b55-106">このパターンによって、アプリケーションがデータ ストアから目的のデータを取得するまでの時間が短縮されるため、クエリのパフォーマンスが向上します。</span><span class="sxs-lookup"><span data-stu-id="77b55-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="77b55-107">コンテキストと問題</span><span class="sxs-lookup"><span data-stu-id="77b55-107">Context and problem</span></span>

<span data-ttu-id="77b55-108">多くのデータ ストアでは、エンティティの集合体を表すデータが主キーを使って整理されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="77b55-109">アプリケーションは、このキーを使ってデータを探し、取得することができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="77b55-110">この図は、顧客情報を保持するデータ ストアの例です。</span><span class="sxs-lookup"><span data-stu-id="77b55-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="77b55-111">主キーは Customer ID です。</span><span class="sxs-lookup"><span data-stu-id="77b55-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="77b55-112">この図を見ると、顧客情報が主キー (Customer ID) によって整理されていることがわかります。</span><span class="sxs-lookup"><span data-stu-id="77b55-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![図 1 - 主キー (Customer ID) によって整理された顧客情報](./_images/index-table-figure-1.png)

<span data-ttu-id="77b55-114">主キーは、その値に基づいてデータをフェッチするクエリには有効な手段となりますが、アプリケーションから他のフィールドに基づいてデータを取得する必要がある場合には、主キーを使うことが難しくなります。</span><span class="sxs-lookup"><span data-stu-id="77b55-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="77b55-115">この顧客情報の例で言えば、顧客の所在地 (Town) など、主キー (Customer ID) 以外の属性の値を参照してデータを照会するだけでは、顧客を取得することができません。</span><span class="sxs-lookup"><span data-stu-id="77b55-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="77b55-116">そのようなクエリを実行するためには、アプリケーションですべての顧客レコードをフェッチして調べる必要があり、処理が遅くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="77b55-117">多くのリレーショナル データベース管理システムでは、セカンダリ インデックスがサポートされています。</span><span class="sxs-lookup"><span data-stu-id="77b55-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="77b55-118">セカンダリ インデックスは、主キー以外 (セカンダリ) のキー フィールドによって体系化される独立したデータ構造であり、インデックス付けされた値がそれぞれどこに保存されているかを示すものです。</span><span class="sxs-lookup"><span data-stu-id="77b55-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="77b55-119">セカンダリ インデックス内の要素は通常、高速にデータを検索できるようセカンダリ キーの値で並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="77b55-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="77b55-120">これらのインデックスの管理は通常、データベース管理システムによって自動的に行われます。</span><span class="sxs-lookup"><span data-stu-id="77b55-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="77b55-121">実際のアプリケーションで実行されるさまざまなクエリに対応するために、必要に応じていくつでもセカンダリ インデックスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="77b55-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="77b55-122">たとえば、Customer ID を主キーとする Customers テーブルがリレーショナル データベースにあるとき、アプリケーションから顧客をその所在地で検索することが多ければ、Town フィールドにセカンダリ インデックスを追加することを検討します。</span><span class="sxs-lookup"><span data-stu-id="77b55-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="77b55-123">ところが、リレーショナル システムではセカンダリ インデックスが当たり前のように存在しますが、クラウド アプリケーションで使用される NoSQL データ ストアには、ほとんどの場合、同等の機能が備わっていません。</span><span class="sxs-lookup"><span data-stu-id="77b55-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="77b55-124">解決策</span><span class="sxs-lookup"><span data-stu-id="77b55-124">Solution</span></span>

<span data-ttu-id="77b55-125">データ ストアでセカンダリ インデックスがサポートされていない場合は、独自のインデックス テーブルを作成することにより、それらを手動でエミュレートすることができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="77b55-126">インデックス テーブルでは、指定されたキーでデータが整理されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="77b55-127">インデックス テーブルを構造化する場合、必要なセカンダリ インデックスの数とアプリケーションで実行するクエリの特性に応じて、一般に 3 つの方法が使用されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="77b55-128">1 つ目は、各インデックス テーブル内のデータを異なるキーで整理しつつ複製する方法です (完全非正規化)。</span><span class="sxs-lookup"><span data-stu-id="77b55-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="77b55-129">次の図は、同じ顧客情報を Town と LastName で整理したインデックス テーブルを示しています。</span><span class="sxs-lookup"><span data-stu-id="77b55-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![図 2 - 各インデックス テーブルにデータを複製](./_images/index-table-figure-2.png)

<span data-ttu-id="77b55-131">この方法は、それぞれのキーを使用してデータが照会される回数に比べて、データの変動が相対的に小さい場合に適しています。</span><span class="sxs-lookup"><span data-stu-id="77b55-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="77b55-132">データの変動が大きいと、それぞれのインデックス テーブルを管理する処理オーバーヘッドが大きくなりすぎて、このアプローチでは実用に耐えなくなってきます。</span><span class="sxs-lookup"><span data-stu-id="77b55-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="77b55-133">また、データが膨大な量になった場合、複製データを格納するために必要な領域の量もかなり大きくなります。</span><span class="sxs-lookup"><span data-stu-id="77b55-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="77b55-134">2 つ目は、異なるキーで整理された正規化インデックス テーブルを作成する方法です。データを複製するのではなく、主キーを使って元のデータを参照します。そのようすを示したのが次の図です。</span><span class="sxs-lookup"><span data-stu-id="77b55-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="77b55-135">元のデータは、ファクト テーブルと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="77b55-135">The original data is called a fact table.</span></span>

![図 3 - 各インデックス テーブルでデータを参照](./_images/index-table-figure-3.png)

<span data-ttu-id="77b55-137">この手法なら、領域が節約され、重複データを管理するオーバーヘッドも小さくて済みます。</span><span class="sxs-lookup"><span data-stu-id="77b55-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="77b55-138">短所は、セカンダリ キーを使ってデータを探すために、アプリケーションで 2 回の検索操作を実行する必要がある点です。</span><span class="sxs-lookup"><span data-stu-id="77b55-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="77b55-139">データの主キーをインデックス テーブルで見つけてから、その主キーを使ってファクト テーブル内のデータを検索する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="77b55-140">3 つ目は、頻繁に取得されるフィールドを複製し、異なるキーで整理して部分的に正規化したインデックス テーブルを作成する方法です。</span><span class="sxs-lookup"><span data-stu-id="77b55-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="77b55-141">アクセスされる頻度の低いフィールドには、ファクト テーブルを参照してアクセスします。</span><span class="sxs-lookup"><span data-stu-id="77b55-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="77b55-142">次の図は、アクセス頻度の高いデータがそれぞれのインデックス テーブルにどのように複製されるかを示したものです。</span><span class="sxs-lookup"><span data-stu-id="77b55-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![図 4 -アクセス頻度の高いデータを各インデックス テーブルに複製](./_images/index-table-figure-4.png)

<span data-ttu-id="77b55-144">この方法を使用すると、前述した 2 つのアプローチをうまく両立させることができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="77b55-145">頻繁に照会されるデータは 1 回の検索ですばやく取得することができ、しかも領域と管理のオーバーヘッドは、データセット全体を複製した場合ほど大きくならずに済みます。</span><span class="sxs-lookup"><span data-stu-id="77b55-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="77b55-146">"Redmond 在住で、かつ姓が Smith であるすべての顧客" を検索するなど、値の組み合わせを指定してアプリケーションで頻繁にデータを照会する場合、インデックス テーブルに格納される項目のキーを、Town 属性と LastName 属性を連結した文字列として実装することもできます。</span><span class="sxs-lookup"><span data-stu-id="77b55-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="77b55-147">次の図は、複合キーに基づくインデックス テーブルを示しています。</span><span class="sxs-lookup"><span data-stu-id="77b55-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="77b55-148">キーは、まず Town で並べ替えられた後、Town に関して同じ値を備えたレコードごとに LastName で並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="77b55-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![図 5 - 複合キーに基づくインデックス テーブル](./_images/index-table-figure-5.png)

<span data-ttu-id="77b55-150">シャード化されたデータに対するクエリ操作は、インデックス テーブルによって高速化できます。シャード キーがハッシュされている場合は特にそれが当てはまります。</span><span class="sxs-lookup"><span data-stu-id="77b55-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="77b55-151">以下の図は、シャード キーが Customer ID のハッシュになっている例です。</span><span class="sxs-lookup"><span data-stu-id="77b55-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="77b55-152">このインデックス テーブルは、ハッシュされていない値 (Town と LastName) でデータを整理し、ハッシュされたシャード キーを参照データとして返すことができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="77b55-153">そのため、ある範囲内のデータを取得する必要がある場合や、ハッシュされていないキーの順序でデータをフェッチする必要がある場合に、ハッシュ キーを繰り返し計算 (コストの大きい操作) する負担からアプリケーションが開放されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="77b55-154">たとえば "Redmond 在住のすべての顧客を検索" するクエリは、一致する項目 (いずれも連続するブロックに存在) をインデックス テーブルで特定することによってすぐに解決できます。</span><span class="sxs-lookup"><span data-stu-id="77b55-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="77b55-155">その後、インデックス テーブルに格納されているシャード キーを使用し、参照情報をたどって顧客データにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="77b55-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![図 6 - シャード化されたデータをすばやく検索できるインデックス テーブル](./_images/index-table-figure-6.png)

## <a name="issues-and-considerations"></a><span data-ttu-id="77b55-157">問題と注意事項</span><span class="sxs-lookup"><span data-stu-id="77b55-157">Issues and considerations</span></span>

<span data-ttu-id="77b55-158">このパターンの実装方法を決めるときには、以下の点に注意してください。</span><span class="sxs-lookup"><span data-stu-id="77b55-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="77b55-159">セカンダリ インデックスの管理オーバーヘッドが著しく大きくなる場合があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="77b55-160">実際のアプリケーションで使用するクエリを分析して理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="77b55-161">インデックス テーブルは、定期的に使用する可能性が高い場合にのみ作成してください。</span><span class="sxs-lookup"><span data-stu-id="77b55-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="77b55-162">アプリケーションで実行する機会のないクエリや、まれにしか実行しないクエリをサポートするために、思いつきでインデックス テーブルを作成しないでください。</span><span class="sxs-lookup"><span data-stu-id="77b55-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="77b55-163">インデックス テーブルにデータを複製することで、データのコピーを複数保持することに伴うストレージ コストや手間において、著しく大きなオーバーヘッドが生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="77b55-164">元のデータを参照する正規化された構造としてインデックス テーブルを実装する場合、アプリケーションは、データを見つけ出すために 2 回の検索操作を実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="77b55-165">1 回目の検索操作でインデックス テーブルから主キーを取得し、2 回目の操作でその主キーを使って目的のデータをフェッチします。</span><span class="sxs-lookup"><span data-stu-id="77b55-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="77b55-166">非常に大きなデータ セットを対象にしたインデックス テーブルを 1 つのシステムに多数組み込んだ場合、インデックス テーブルと元のデータとの間の整合性を維持することが難しくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="77b55-167">そのような場合は、結果整合性モデルでアプリケーションを設計することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="77b55-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="77b55-168">たとえばデータの挿入、更新、削除を行うために、アプリケーションからメッセージをキューにポストしておき、独立したタスクで非同期的に操作を実行したり、対象データを参照するインデックス テーブルを管理したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="77b55-169">結果整合性を実装する方法の詳細については、「[Data consistency primer (データ整合性入門)](https://msdn.microsoft.com/library/dn589800.aspx)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="77b55-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="77b55-170">Microsoft Azure Storage テーブルは、同じパーティションに保持されているデータへの変更に関して、トランザクション更新をサポートしています (エンティティ グループ トランザクションと呼ばれます)。</span><span class="sxs-lookup"><span data-stu-id="77b55-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="77b55-171">1 つのファクト テーブルのデータと 1 つまたは複数のインデックス テーブルのデータを同じパーティションに格納できる場合、この機能を利用して整合性を確保することができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="77b55-172">インデックス テーブルは、それ自体がパーティション分割されていたり、シャード化されていたりする可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="77b55-173">このパターンを使用する状況</span><span class="sxs-lookup"><span data-stu-id="77b55-173">When to use this pattern</span></span>

<span data-ttu-id="77b55-174">アプリケーションで主キー (またはシャード キー) 以外のキーを使って頻繁にデータを取得する必要がある場合、このパターンを使用してクエリ パフォーマンスを強化してください。</span><span class="sxs-lookup"><span data-stu-id="77b55-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="77b55-175">このパターンが適さない状況</span><span class="sxs-lookup"><span data-stu-id="77b55-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="77b55-176">データの変化が激しい。</span><span class="sxs-lookup"><span data-stu-id="77b55-176">Data is volatile.</span></span> <span data-ttu-id="77b55-177">インデックス テーブルがすぐに古くなり、効率が悪化したり、インデックス テーブルを使用することによって得られるメリットよりも、管理オーバーヘッドの方が大きくなったりします。</span><span class="sxs-lookup"><span data-stu-id="77b55-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="77b55-178">インデックス テーブルのセカンダリ キーとして選択するフィールドにデータの識別性がなく、ごくわずかな値の組み合わせしか保持できない (性別など)。</span><span class="sxs-lookup"><span data-stu-id="77b55-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="77b55-179">インデックス テーブルのセカンダリ キーとして選択するフィールドに格納されているデータの値の偏りが大きい。</span><span class="sxs-lookup"><span data-stu-id="77b55-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="77b55-180">たとえば 90% のレコードがあるフィールドに同じ値を格納している場合、そのフィールドに基づいてデータを検索するためのインデックス テーブルを作成、維持することは、データの先頭から逐次的にスキャンするよりもオーバーヘッドが大きくなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="77b55-181">ただしクエリで頻繁に検索する値が残りの 10% に存在するのであれば、このインデックスは役に立つ可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="77b55-182">実際のアプリケーションで実行するクエリとその実行頻度を把握しておくことが大切です。</span><span class="sxs-lookup"><span data-stu-id="77b55-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="77b55-183">例</span><span class="sxs-lookup"><span data-stu-id="77b55-183">Example</span></span>

<span data-ttu-id="77b55-184">Azure Storage テーブルは、クラウドで実行されるアプリケーションのためのスケーラビリティに優れたキー/値型のデータ ストアです。</span><span class="sxs-lookup"><span data-stu-id="77b55-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="77b55-185">アプリケーションは、キーを指定することによってデータ値を格納したり取得したりします。</span><span class="sxs-lookup"><span data-stu-id="77b55-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="77b55-186">データ値には、複数のフィールドを含めることができますが、テーブル ストレージからはデータ項目の構造が見えません。データ項目は単にバイトの配列として扱われます。</span><span class="sxs-lookup"><span data-stu-id="77b55-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="77b55-187">Azure Storage テーブルではシャーディングもサポートされます。</span><span class="sxs-lookup"><span data-stu-id="77b55-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="77b55-188">シャーディング キーは、パーティション キーと行キーの 2 つの要素を含んでいます。</span><span class="sxs-lookup"><span data-stu-id="77b55-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="77b55-189">同じパーティション キーを備えた項目は同じパーティション (シャード) に格納され、項目はシャード内の行キーの順序で格納されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="77b55-190">テーブル ストレージは、同じパーティション内の行キーの値が連続する範囲内にあるデータをフェッチするクエリに最適化されています。</span><span class="sxs-lookup"><span data-stu-id="77b55-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="77b55-191">Azure テーブルに情報を格納するクラウド アプリケーションを作成する場合は、この特徴を踏まえてデータの構造を決める必要があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="77b55-192">たとえば、映画に関する情報を格納するアプリケーションがあるとします。</span><span class="sxs-lookup"><span data-stu-id="77b55-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="77b55-193">そのアプリケーションでは、ジャンル (アクション、ドキュメンタリー、歴史、コメディ、ドラマなど) で映画を検索するクエリが頻繁に実行されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="77b55-194">この場合、ジャンルごとにパーティション分割された Azure テーブルを作成することが考えられます。次の図のように、ジャンルをパーティション キーとし、映画の名前を行キーとして指定します。</span><span class="sxs-lookup"><span data-stu-id="77b55-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![図 7 - Azure テーブルに格納された映画のデータ](./_images/index-table-figure-7.png)

<span data-ttu-id="77b55-196">この方法は、主演俳優で映画を照会する必要がある場合、効果が下がります。</span><span class="sxs-lookup"><span data-stu-id="77b55-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="77b55-197">その場合は、別途インデックス テーブルとして機能する Azure テーブルを作成することができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="77b55-198">パーティション キーを俳優に、行キーを映画名にします。</span><span class="sxs-lookup"><span data-stu-id="77b55-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="77b55-199">俳優ごとに、別々のパーティションにデータが格納されます。</span><span class="sxs-lookup"><span data-stu-id="77b55-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="77b55-200">複数の俳優が出演している場合、同じ映画が複数のパーティションに格納されることになります。</span><span class="sxs-lookup"><span data-stu-id="77b55-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="77b55-201">前出の「解決策」セクションで取り上げた 1 つ目の方法を採用すれば、各パーティションが保持する値に映画のデータを複製することができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="77b55-202">ただし、1 つの映画が複数回 (俳優 1 人につき 1 回) にわたって複製される可能性が高いので、データを部分的に非正規化した方が効率がよいでしょう。完全な情報を見つけ出すために必要なパーティション キーをジャンル パーティションに含めることで、使用頻度の非常に高いクエリ (他の俳優の名前など) に対応し、アプリケーションで残りの詳細データを取得することができます。</span><span class="sxs-lookup"><span data-stu-id="77b55-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="77b55-203">この方法は、「解決策」セクションの 3 つ目の選択肢で説明しています。</span><span class="sxs-lookup"><span data-stu-id="77b55-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="77b55-204">その方法を示したのが次の図です。</span><span class="sxs-lookup"><span data-stu-id="77b55-204">The next figure shows this approach.</span></span>

![図 8 - 映画データのインデックス テーブルとして機能する Actor パーティション](./_images/index-table-figure-8.png)

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="77b55-206">関連のあるパターンとガイダンス</span><span class="sxs-lookup"><span data-stu-id="77b55-206">Related patterns and guidance</span></span>

<span data-ttu-id="77b55-207">このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="77b55-208">[Data consistency primer (データ整合性入門)](https://msdn.microsoft.com/library/dn589800.aspx)。</span><span class="sxs-lookup"><span data-stu-id="77b55-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="77b55-209">インデックス テーブルは、インデックスの対象となるデータが変化するので、メンテナンスが必要です。</span><span class="sxs-lookup"><span data-stu-id="77b55-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="77b55-210">データに変更を加える同じトランザクションの一環としてインデックスを更新する操作は、クラウドでは実行できないか、できたとしても適切でない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="77b55-211">その場合は、結果整合性のアプローチの方が適しています。</span><span class="sxs-lookup"><span data-stu-id="77b55-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="77b55-212">このドキュメントには、結果整合性に関する問題についての情報が取り上げられています。</span><span class="sxs-lookup"><span data-stu-id="77b55-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="77b55-213">[シャーディング パターン](./sharding.md)。</span><span class="sxs-lookup"><span data-stu-id="77b55-213">[Sharding pattern](./sharding.md).</span></span> <span data-ttu-id="77b55-214">一般にインデックス テーブル パターンは、シャードを使ってパーティション分割されたデータと組み合わせて使用します。</span><span class="sxs-lookup"><span data-stu-id="77b55-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="77b55-215">「Sharding pattern (シャーディング パターン)」では、データ ストアを一連のシャードに分割する方法について詳しく取り上げています。</span><span class="sxs-lookup"><span data-stu-id="77b55-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="77b55-216">[Materialized View Pattern (具体化されたビュー パターン)](./materialized-view.md)</span><span class="sxs-lookup"><span data-stu-id="77b55-216">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="77b55-217">インデックスを作成することによってデータの概要を抽出するクエリをサポートするよりも、具体化されたデータのビューを作成した方がよい場合があります。</span><span class="sxs-lookup"><span data-stu-id="77b55-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="77b55-218">データの事前設定されたビューを生成することによって効率的な概要クエリをサポートする方法が説明されています。</span><span class="sxs-lookup"><span data-stu-id="77b55-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
