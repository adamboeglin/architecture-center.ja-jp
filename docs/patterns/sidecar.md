---
title: サイドカー パターン
titleSuffix: Cloud Design Patterns
description: アプリケーションのコンポーネントを別のプロセスまたはコンテナーにデプロイして、分離性とカプセル化を実現します。
keywords: 設計パターン
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 2b0e46a06f7fe47f281f726f73128db1d7dd1067
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58243563"
---
# <a name="sidecar-pattern"></a><span data-ttu-id="05537-104">サイドカー パターン</span><span class="sxs-lookup"><span data-stu-id="05537-104">Sidecar pattern</span></span>

<span data-ttu-id="05537-105">アプリケーションのコンポーネントを別のプロセスまたはコンテナーにデプロイして、分離性とカプセル化を実現します。</span><span class="sxs-lookup"><span data-stu-id="05537-105">Deploy components of an application into a separate process or container to provide isolation and encapsulation.</span></span> <span data-ttu-id="05537-106">このパターンは、種類が異なるコンポーネントとテクノロジでアプリケーションを構成することも可能にします。</span><span class="sxs-lookup"><span data-stu-id="05537-106">This pattern can also enable applications to be composed of heterogeneous components and technologies.</span></span>

<span data-ttu-id="05537-107">このパターンは、オートバイに取り付けられるサイドカーに似ているため、"*サイドカー*" と名付けられています。</span><span class="sxs-lookup"><span data-stu-id="05537-107">This pattern is named *Sidecar* because it resembles a sidecar attached to a motorcycle.</span></span> <span data-ttu-id="05537-108">このパターンでは、サイドカーは親アプリケーションに接続され、アプリケーションにサポート機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="05537-108">In the pattern, the sidecar is attached to a parent application and provides supporting features for the application.</span></span> <span data-ttu-id="05537-109">また、サイドカーは、親アプリケーションと同じライフ サイクルを共有し、親アプリケーションと共に作成され、終了します。</span><span class="sxs-lookup"><span data-stu-id="05537-109">The sidecar also shares the same lifecycle as the parent application, being created and retired alongside the parent.</span></span> <span data-ttu-id="05537-110">サイドカー パターンは、サイドキック パターンと呼ばれることもある分解パターンです。</span><span class="sxs-lookup"><span data-stu-id="05537-110">The sidecar pattern is sometimes referred to as the sidekick pattern and is a decomposition pattern.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="05537-111">コンテキストと問題</span><span class="sxs-lookup"><span data-stu-id="05537-111">Context and Problem</span></span>

<span data-ttu-id="05537-112">多くの場合、アプリケーションとサービスは、監視、ログ記録、構成、ネットワーク サービスなどの関連する機能を必要とします。</span><span class="sxs-lookup"><span data-stu-id="05537-112">Applications and services often require related functionality, such as monitoring, logging, configuration, and networking services.</span></span> <span data-ttu-id="05537-113">これらの周辺タスクを、独立したコンポーネントまたはサービスとして実装できます。</span><span class="sxs-lookup"><span data-stu-id="05537-113">These peripheral tasks can be implemented as separate components or services.</span></span>

<span data-ttu-id="05537-114">コンポーネントまたはサービスをアプリケーションに緊密に統合すると、アプリケーションと同じプロセスで実行でき、共有リソースを効率的に使用できます。</span><span class="sxs-lookup"><span data-stu-id="05537-114">If they are tightly integrated into the application, they can run in the same process as the application, making efficient use of shared resources.</span></span> <span data-ttu-id="05537-115">ただし、緊密な結合は、十分に分離されていないことも意味し、あるコンポーネントで発生した障害が他のコンポーネントやアプリケーション全体に影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05537-115">However, this also means they are not well isolated, and an outage in one of these components can affect other components or the entire application.</span></span> <span data-ttu-id="05537-116">さらに、通常は、親アプリケーションと同じ言語を使用して実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="05537-116">Also, they usually need to be implemented using the same language as the parent application.</span></span> <span data-ttu-id="05537-117">その結果、コンポーネントとアプリケーションは、密接に相互依存することになります。</span><span class="sxs-lookup"><span data-stu-id="05537-117">As a result, the component and the application have close interdependence on each other.</span></span>

<span data-ttu-id="05537-118">アプリケーションを複数のサービスに分解すれば、各サービスを異なる言語とテクノロジを使用して構築できます。</span><span class="sxs-lookup"><span data-stu-id="05537-118">If the application is decomposed into services, then each service can be built using different languages and technologies.</span></span> <span data-ttu-id="05537-119">これによって柔軟性は向上しますが、各コンポーネントが独自の依存関係を持つことになり、基になるプラットフォームと親アプリケーションと共有しているリソースにアクセスするには、言語固有のライブラリが必要であることを意味します。</span><span class="sxs-lookup"><span data-stu-id="05537-119">While this gives more flexibility, it means that each component has its own dependencies and requires language-specific libraries to access the underlying platform and any resources shared with the parent application.</span></span> <span data-ttu-id="05537-120">さらに、これらの機能を独立したサービスとしてデプロイすると、アプリケーションに待ち時間が追加される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05537-120">In addition, deploying these features as separate services can add latency to the application.</span></span> <span data-ttu-id="05537-121">さらに、これらの言語固有のインターフェイスのコードと依存関係の管理が非常に複雑になる可能性があります。これは特にホスト、デプロイ、および管理に当てはまります。</span><span class="sxs-lookup"><span data-stu-id="05537-121">Managing the code and dependencies for these language-specific interfaces can also add considerable complexity, especially for hosting, deployment, and management.</span></span>

## <a name="solution"></a><span data-ttu-id="05537-122">解決策</span><span class="sxs-lookup"><span data-stu-id="05537-122">Solution</span></span>

<span data-ttu-id="05537-123">まとまりのあるタスク セットをプライマリ アプリケーションと併置しますが、独自のプロセスまたはコンテナー内にセットを配置して、プラットフォーム サービス用の言語を越えた同種インターフェイスを実現します。</span><span class="sxs-lookup"><span data-stu-id="05537-123">Co-locate a cohesive set of tasks with the primary application, but place them inside their own process or container, providing a homogeneous interface for platform services across languages.</span></span>

![サイドカー パターンの図](./_images/sidecar.png)

<span data-ttu-id="05537-125">サイドカー サービスは、必ずアプリケーションの一部であるわけではありませんが、アプリケーションに接続されます。</span><span class="sxs-lookup"><span data-stu-id="05537-125">A sidecar service is not necessarily part of the application, but is connected to it.</span></span> <span data-ttu-id="05537-126">サイドカー サービスは、常に親アプリケーションの傍に存在します。</span><span class="sxs-lookup"><span data-stu-id="05537-126">It goes wherever the parent application goes.</span></span> <span data-ttu-id="05537-127">サイドカーは、プライマリ アプリケーションと共にデプロイされるサポート プロセスまたはサービスです。</span><span class="sxs-lookup"><span data-stu-id="05537-127">Sidecars are supporting processes or services that are deployed with the primary application.</span></span> <span data-ttu-id="05537-128">オートバイのサイドカーは、1 台のバイクに取り付けられ、オートバイはそれぞれ専用のサイドカーを持つことができます。</span><span class="sxs-lookup"><span data-stu-id="05537-128">On a motorcycle, the sidecar is attached to one motorcycle, and each motorcycle can have its own sidecar.</span></span> <span data-ttu-id="05537-129">同じように、サイドカー サービスは、その親アプリケーションと運命を共にします。</span><span class="sxs-lookup"><span data-stu-id="05537-129">In the same way, a sidecar service shares the fate of its parent application.</span></span> <span data-ttu-id="05537-130">アプリケーションの各インスタンスにサイドカー インスタンスがデプロイされ、一緒にホストされます。</span><span class="sxs-lookup"><span data-stu-id="05537-130">For each instance of the application, an instance of the sidecar is deployed and hosted alongside it.</span></span>

<span data-ttu-id="05537-131">サイドカー パターンを使用する利点は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="05537-131">Advantages of using a sidecar pattern include:</span></span>

- <span data-ttu-id="05537-132">サイドカーは、ランタイム環境とプログラミング言語に関してプライマリ アプリケーションから独立しているため、言語ごとにサイドカーを開発する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="05537-132">A sidecar is independent from its primary application in terms of runtime environment and programming language, so you don't need to develop one sidecar per language.</span></span>

- <span data-ttu-id="05537-133">サイドカーは、プライマリ アプリケーションと同じリソースにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="05537-133">The sidecar can access the same resources as the primary application.</span></span> <span data-ttu-id="05537-134">たとえば、サイドカーは、サイドカーとプライマリ アプリケーションの両方で使用されるシステム リソースを監視できます。</span><span class="sxs-lookup"><span data-stu-id="05537-134">For example, a sidecar can monitor system resources used by both the sidecar and the primary application.</span></span>

- <span data-ttu-id="05537-135">プライマリ アプリケーションに近接しているため、通信時に有意な待ち時間は発生しません。</span><span class="sxs-lookup"><span data-stu-id="05537-135">Because of its proximity to the primary application, there’s no significant latency when communicating between them.</span></span>

- <span data-ttu-id="05537-136">拡張メカニズムがないアプリケーションでも、サイドカーを 独自のプロセスとしてプライマリ アプリケーションと同じホストまたはサブコンテナーに接続することで、機能を拡張できます。</span><span class="sxs-lookup"><span data-stu-id="05537-136">Even for applications that don’t provide an extensibility mechanism, you can use a sidecar to extend functionality by attaching it as own process in the same host or sub-container as the primary application.</span></span>

<span data-ttu-id="05537-137">多くの場合、サイドカー パターンはコンテナーで使用され、サイドカー コンテナーまたはサイドキック コンテナーと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="05537-137">The sidecar pattern is often used with containers and referred to as a sidecar container or sidekick container.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="05537-138">問題と注意事項</span><span class="sxs-lookup"><span data-stu-id="05537-138">Issues and Considerations</span></span>

- <span data-ttu-id="05537-139">サービス、プロセス、またはコンテナーをデプロイするために使用するデプロイとパッケージの形式を検討します。</span><span class="sxs-lookup"><span data-stu-id="05537-139">Consider the deployment and packaging format you will use to deploy services, processes, or containers.</span></span> <span data-ttu-id="05537-140">サイドカー パターンに特に適しているのはコンテナーです。</span><span class="sxs-lookup"><span data-stu-id="05537-140">Containers are particularly well suited to the sidecar pattern.</span></span>
- <span data-ttu-id="05537-141">サイドカー サービスを設計する際は、プロセス間通信メカニズムを慎重に決定します。</span><span class="sxs-lookup"><span data-stu-id="05537-141">When designing a sidecar service, carefully decide on the interprocess communication mechanism.</span></span> <span data-ttu-id="05537-142">パフォーマンスの要件によって実現が難しい場合を除いて、言語またはフレームワークに依存しないテクノロジを使用するようにします。</span><span class="sxs-lookup"><span data-stu-id="05537-142">Try to use language- or framework-agnostic technologies unless performance requirements make that impractical.</span></span>
- <span data-ttu-id="05537-143">機能をサイドカーに配置する前に、独立したサービスまたは従来のデーモンのほうがうまく動作するかどうかを検討します。</span><span class="sxs-lookup"><span data-stu-id="05537-143">Before putting functionality into a sidecar, consider whether it would work better as a separate service or a more traditional daemon.</span></span>
- <span data-ttu-id="05537-144">さらに、機能をライブラリとして実装できるか、従来の拡張メカニズムを使用して実装できるかを検討します。</span><span class="sxs-lookup"><span data-stu-id="05537-144">Also consider whether the functionality could be implemented as a library or using a traditional extension mechanism.</span></span> <span data-ttu-id="05537-145">言語固有のライブラリのほうが、より深いレベルで統合され、ネットワークのオーバーヘッドが少ない場合があります。</span><span class="sxs-lookup"><span data-stu-id="05537-145">Language-specific libraries may have a deeper level of integration and less network overhead.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="05537-146">このパターンを使用する状況</span><span class="sxs-lookup"><span data-stu-id="05537-146">When to Use this Pattern</span></span>

<span data-ttu-id="05537-147">このパターンは次の状況で使用します。</span><span class="sxs-lookup"><span data-stu-id="05537-147">Use this pattern when:</span></span>

- <span data-ttu-id="05537-148">プライマリ アプリケーションが、異なる種類の言語とフレームワークのセットを使用している。</span><span class="sxs-lookup"><span data-stu-id="05537-148">Your primary application uses a heterogeneous set of languages and frameworks.</span></span> <span data-ttu-id="05537-149">サイドカー サービスに配置されるコンポーネントは、さまざまな言語で記述され、異なるフレームワークを使用しているアプリケーションによって使用できます。</span><span class="sxs-lookup"><span data-stu-id="05537-149">A component located in a sidecar service can be consumed by applications written in different languages using different frameworks.</span></span>
- <span data-ttu-id="05537-150">コンポーネントが、リモート チームまたは別の組織によって所有されている。</span><span class="sxs-lookup"><span data-stu-id="05537-150">A component is owned by a remote team or a different organization.</span></span>
- <span data-ttu-id="05537-151">コンポーネントまたは機能を、アプリケーションと同じホストに併置する必要がある。</span><span class="sxs-lookup"><span data-stu-id="05537-151">A component or feature must be co-located on the same host as the application</span></span>
- <span data-ttu-id="05537-152">メイン アプリケーションの全体的なライフ サイクルを共有するが、別々に更新できるサービスが必要である。</span><span class="sxs-lookup"><span data-stu-id="05537-152">You need a service that shares the overall lifecycle of your main application, but can be independently updated.</span></span>
- <span data-ttu-id="05537-153">特定のリソースまたはコンポーネントのリソース制限をきめ細かく制御する必要がある。</span><span class="sxs-lookup"><span data-stu-id="05537-153">You need fine-grained control over resource limits for a particular resource or component.</span></span> <span data-ttu-id="05537-154">たとえば、特定のコンポーネントが使用するメモリの量を制限できます。</span><span class="sxs-lookup"><span data-stu-id="05537-154">For example, you may want to restrict the amount of memory a specific component uses.</span></span> <span data-ttu-id="05537-155">コンポーネントをサイドカーとしてデプロイし、メイン アプリケーションとは別にメモリ使用量を管理できます。</span><span class="sxs-lookup"><span data-stu-id="05537-155">You can deploy the component as a sidecar and manage memory usage independently of the main application.</span></span>

<span data-ttu-id="05537-156">このパターンは、次の場合には適切でない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05537-156">This pattern may not be suitable:</span></span>

- <span data-ttu-id="05537-157">プロセス間通信を最適化する必要がある。</span><span class="sxs-lookup"><span data-stu-id="05537-157">When interprocess communication needs to be optimized.</span></span> <span data-ttu-id="05537-158">親アプリケーションとサイドカー サービス間の通信には、オーバーヘッドが含まれています。大きいのは、呼び出し時の待ち時間です。</span><span class="sxs-lookup"><span data-stu-id="05537-158">Communication between a parent application and sidecar services includes some overhead, notably latency in the calls.</span></span> <span data-ttu-id="05537-159">対話が多いインターフェイスでは、これは容認できるトレードオフではない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05537-159">This may not be an acceptable trade-off for chatty interfaces.</span></span>
- <span data-ttu-id="05537-160">各インスタンスにサイドカー サービスをデプロイするリソース コストと分離によるメリットが釣り合わない小規模なアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="05537-160">For small applications where the resource cost of deploying a sidecar service for each instance is not worth the advantage of isolation.</span></span>
- <span data-ttu-id="05537-161">サービスのスケールをメイン アプリケーションとは異なるようにするか、メイン アプリケーションと無関係にスケーリングする必要がある。</span><span class="sxs-lookup"><span data-stu-id="05537-161">When the service needs to scale differently than or independently from the main applications.</span></span> <span data-ttu-id="05537-162">この場合は、機能を別のサービスとしてデプロイするほうが適している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="05537-162">If so, it may be better to deploy the feature as a separate service.</span></span>

## <a name="example"></a><span data-ttu-id="05537-163">例</span><span class="sxs-lookup"><span data-stu-id="05537-163">Example</span></span>

<span data-ttu-id="05537-164">サイドカー パターンは多くのシナリオに適用できます。</span><span class="sxs-lookup"><span data-stu-id="05537-164">The sidecar pattern is applicable to many scenarios.</span></span> <span data-ttu-id="05537-165">一般的な例を次に示します。</span><span class="sxs-lookup"><span data-stu-id="05537-165">Some common examples:</span></span>

- <span data-ttu-id="05537-166">インフラストラクチャ API。</span><span class="sxs-lookup"><span data-stu-id="05537-166">Infrastructure API.</span></span> <span data-ttu-id="05537-167">インフラストラクチャ開発チームは、インフラストラクチャにアクセスするための言語固有のクライアント ライブラリではなく、各アプリケーションと一緒にデプロイされるサービスを作成します。</span><span class="sxs-lookup"><span data-stu-id="05537-167">The infrastructure development team creates a service that's deployed alongside each application, instead of a language-specific client library to access the infrastructure.</span></span> <span data-ttu-id="05537-168">サービスはサイドカーとして読み込まれ、ログ記録、環境データ、構成ストア、検出、正常性チェック、ウォッチドッグ サービスなどのインフラストラクチャ サービス用の共通層を提供します。</span><span class="sxs-lookup"><span data-stu-id="05537-168">The service is loaded as a sidecar and provides a common layer for infrastructure services, including logging, environment data, configuration store, discovery, health checks, and watchdog services.</span></span> <span data-ttu-id="05537-169">さらに、サイドカーは、親アプリケーションのホスト環境とプロセス (またはコンテナー) を監視し、情報を一元的なサービスに記録します。</span><span class="sxs-lookup"><span data-stu-id="05537-169">The sidecar also monitors the parent application's host environment and process (or container) and logs the information to a centralized service.</span></span>
- <span data-ttu-id="05537-170">NGINX/HAProxy を管理する。</span><span class="sxs-lookup"><span data-stu-id="05537-170">Manage NGINX/HAProxy.</span></span> <span data-ttu-id="05537-171">NGINX と環境の状態を監視するサイドカー サービスをデプロイした後、NGINX 構成ファイルを更新し、状態の変更が必要なときにプロセスをリサイクルします。</span><span class="sxs-lookup"><span data-stu-id="05537-171">Deploy NGINX with a sidecar service that monitors environment state, then updates the NGINX configuration file and recycles the process when a change in state is needed.</span></span>
- <span data-ttu-id="05537-172">アンバサダー サイドカー。</span><span class="sxs-lookup"><span data-stu-id="05537-172">Ambassador sidecar.</span></span> <span data-ttu-id="05537-173">[アンバサダー](./ambassador.md) サービスをサイドカーとしてデプロイします。</span><span class="sxs-lookup"><span data-stu-id="05537-173">Deploy an [ambassador](./ambassador.md) service as a sidecar.</span></span> <span data-ttu-id="05537-174">アプリケーションは、要求のログ、ルーティング、回線切断、およびその他の接続関連の機能を処理するアンバサダーを介して呼び出しを行います。</span><span class="sxs-lookup"><span data-stu-id="05537-174">The application calls through the ambassador, which handles request logging, routing, circuit breaking, and other connectivity related features.</span></span>
- <span data-ttu-id="05537-175">オフロード プロキシ。</span><span class="sxs-lookup"><span data-stu-id="05537-175">Offload proxy.</span></span> <span data-ttu-id="05537-176">node.js サービス インスタンスの前に NGINX プロキシを配置して、サービスの静的ファイルの内容を処理します。</span><span class="sxs-lookup"><span data-stu-id="05537-176">Place an NGINX proxy in front of a node.js service instance, to handle serving static file content for the service.</span></span>

## <a name="related-guidance"></a><span data-ttu-id="05537-177">関連するガイダンス</span><span class="sxs-lookup"><span data-stu-id="05537-177">Related guidance</span></span>

- [<span data-ttu-id="05537-178">アンバサダー パターン</span><span class="sxs-lookup"><span data-stu-id="05537-178">Ambassador pattern</span></span>](./ambassador.md)
