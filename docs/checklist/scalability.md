---
title: スケーラビリティのチェックリスト
titleSuffix: Azure Design Review Framework
description: Azure 自動スケールの設計に関するスケーラビリティのチェックリスト ガイダンス。
author: dragon119
ms.date: 01/10/2018
ms.topic: checklist
ms.service: architecture-center
ms.subservice: cloud-design-principles
ms.custom: checklist
ms.openlocfilehash: 7532926cc02316cef7a91a7072288cf841e83d30
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58243773"
---
# <a name="scalability-checklist"></a><span data-ttu-id="3feeb-103">スケーラビリティのチェックリスト</span><span class="sxs-lookup"><span data-stu-id="3feeb-103">Scalability checklist</span></span>

<span data-ttu-id="3feeb-104">スケーラビリティとは、増加した負荷を処理するシステムの能力であり、[ソフトウェア品質の重要な要素](../guide/pillars.md)の 1 つです。</span><span class="sxs-lookup"><span data-stu-id="3feeb-104">Scalability is the ability of a system to handle increased load, and is one of the [pillars of software quality](../guide/pillars.md).</span></span> <span data-ttu-id="3feeb-105">このチェックリストを使用して、スケーラビリティの観点からアプリケーション アーキテクチャを見直します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-105">Use this checklist to review your application architecture from a scalability standpoint.</span></span>

## <a name="application-design"></a><span data-ttu-id="3feeb-106">アプリケーションの設計</span><span class="sxs-lookup"><span data-stu-id="3feeb-106">Application design</span></span>

<span data-ttu-id="3feeb-107">**ワークロードを分割します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-107">**Partition the workload**.</span></span> <span data-ttu-id="3feeb-108">プロセスのパーツを別個に分解できるように設計します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-108">Design parts of the process to be discrete and decomposable.</span></span> <span data-ttu-id="3feeb-109">また、処理内容の独立の一般規則および単一責任の法則に従って、各パーツのサイズは最小限にします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-109">Minimize the size of each part, while following the usual rules for separation of concerns and the single responsibility principle.</span></span> <span data-ttu-id="3feeb-110">これにより、各コンピューティング ユニット (ロールやデータベース サーバーなど) を最大限に使用できるようにコンポーネントのパーツを分散できます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-110">This allows the component parts to be distributed in a way that maximizes use of each compute unit (such as a role or database server).</span></span> <span data-ttu-id="3feeb-111">また、特定のリソースのインスタンスを追加することで、アプリケーションのスケーリングが容易になります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-111">It also makes it easier to scale the application by adding instances of specific resources.</span></span> <span data-ttu-id="3feeb-112">複雑なドメインの場合、[マイクロサービス アーキテクチャ](..//guide/architecture-styles/microservices.md)の採用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-112">For complex domains, consider adopting a [microservices architecture](..//guide/architecture-styles/microservices.md).</span></span>

<span data-ttu-id="3feeb-113">**スケーリングを考慮して設計します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-113">**Design for scaling**.</span></span> <span data-ttu-id="3feeb-114">スケーリングにより、アプリケーションは、ロール、キュー、および使用する他のサービスのインスタンスの数を増減することで、変動負荷に対応できます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-114">Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services they use.</span></span> <span data-ttu-id="3feeb-115">ただし、アプリケーションを設計する際には、次の点を考慮に入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-115">However, the application must be designed with this in mind.</span></span> <span data-ttu-id="3feeb-116">たとえば、アプリケーションとそれが使用するサービスはステートレスにして、要求をどのインスタンスにもルーティングできるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-116">For example, the application and the services it uses must be stateless, to allow requests to be routed to any instance.</span></span> <span data-ttu-id="3feeb-117">また、特定のインスタンスの追加または削除によって、現行ユーザーに悪影響が及ばないようにします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-117">This also prevents the addition or removal of specific instances from adversely affecting current users.</span></span> <span data-ttu-id="3feeb-118">さらに、インスタンスの追加または削除時にインスタンスの再構成や自動検出を行うしくみを実装して、アプリケーション内のコードが必要なルーティングを実行できるようにします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-118">You should also implement configuration or auto-detection of instances as they are added and removed, so that code in the application can perform the necessary routing.</span></span> <span data-ttu-id="3feeb-119">たとえば、Web アプリケーションは一連のキューをラウンド ロビン方式で使用して、worker ロールで実行しているバックグラウンド サービスに要求をルーティングする場合があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-119">For example, a web application might use a set of queues in a round-robin approach to route requests to background services running in worker roles.</span></span> <span data-ttu-id="3feeb-120">Web アプリケーションは、要求を正しくルーティングして、アプリケーションへの負荷を均等にするために、キューの数の変更を検出できる必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-120">The web application must be able to detect changes in the number of queues, to successfully route requests and balance the load on the application.</span></span>

<span data-ttu-id="3feeb-121">**ユニットとしてスケールします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-121">**Scale as a unit**.</span></span> <span data-ttu-id="3feeb-122">成長に合わせてリソースを追加するように計画します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-122">Plan for additional resources to accommodate growth.</span></span> <span data-ttu-id="3feeb-123">リソースごとに、スケーリングの上限を確認し、シャーディングまたは分解を使用して、これらの限度を超える必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-123">For each resource, know the upper scaling limits, and use sharding or decomposition to go beyond these limits.</span></span> <span data-ttu-id="3feeb-124">明確に定義されたリソースのセットを単位として、システムのスケール ユニットを判別します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-124">Determine the scale units for the system in terms of well-defined sets of resources.</span></span> <span data-ttu-id="3feeb-125">これにより、スケールアウト操作の適用が容易になるだけでなく、システム全体のある部分でリソースが不足しているために制限が課され、アプリケーションに悪影響を及ぼす可能性を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-125">This makes applying scale-out operations easier, and less prone to negative impact on the application through limitations imposed by lack of resources in some part of the overall system.</span></span> <span data-ttu-id="3feeb-126">たとえば、x 個の Web ロールおよび worker ロールを追加すると、それらのロールによって生成される追加のワークロードを処理するために、y 個の追加キューおよび z 個のストレージ アカウントが必要になる場合があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-126">For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles.</span></span> <span data-ttu-id="3feeb-127">このスケール ユニットは x 個の Web ロールおよび worker ロール、*y* 個のキュー、*z* 個のストレージ アカウントで構成できます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-127">So a scale unit could consist of x web and worker roles, *y* queues, and *z* storage accounts.</span></span> <span data-ttu-id="3feeb-128">1 つ以上のスケール ユニットを追加することでスケーリングが容易になるように、アプリケーションを設計してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-128">Design the application so that it's easily scaled by adding one or more scale units.</span></span>

<span data-ttu-id="3feeb-129">**クライアント アフィニティを回避します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-129">**Avoid client affinity**.</span></span> <span data-ttu-id="3feeb-130">可能であれば、アプリケーションがアフィニティを必要としていないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-130">Where possible, ensure that the application does not require affinity.</span></span> <span data-ttu-id="3feeb-131">こうすることで、どのインスタンスにも要求をルーティングでき、インスタンスの数に影響されずに済みます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-131">Requests can thus be routed to any instance, and the number of instances is irrelevant.</span></span> <span data-ttu-id="3feeb-132">これにより、各ユーザーの状態情報を格納、取得、保守するためのオーバーヘッドが生じることもなくなります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-132">This also avoids the overhead of storing, retrieving, and maintaining state information for each user.</span></span>

<span data-ttu-id="3feeb-133">**プラットフォーム自動スケール機能を活用します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-133">**Take advantage of platform autoscaling features**.</span></span> <span data-ttu-id="3feeb-134">ホスティング プラットフォームが Azure 自動スケールなどの自動スケール機能をサポートする場合は、組み込みのメカニズムで要求を満たせない場合を除き、カスタムまたはサードパーティのメカニズムではなく自動スケール機能を使用してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-134">Where the hosting platform supports an autoscaling capability, such as Azure Autoscale, prefer it to custom or third-party mechanisms unless the built-in mechanism can't fulfill your requirements.</span></span> <span data-ttu-id="3feeb-135">可能な限り、スケジュールされたスケーリング ルールを使用し、起動時の遅延なしでリソースを使用可能にします。しかし、必要に応じてリアクティブ自動スケールをルールに追加し、予期しない要求の変化に対応する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-135">Use scheduled scaling rules where possible to ensure resources are available without a start-up delay, but add reactive autoscaling to the rules where appropriate to cope with unexpected changes in demand.</span></span> <span data-ttu-id="3feeb-136">Service Management API で自動スケール操作を使用して、自動スケールを微調整したり、カスタム カウンターをルールに追加したりできます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-136">You can use the autoscaling operations in the Service Management API to adjust autoscaling, and to add custom counters to rules.</span></span> <span data-ttu-id="3feeb-137">詳細については、「[自動スケール ガイダンス](../best-practices/auto-scaling.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-137">For more information, see [Auto-scaling guidance](../best-practices/auto-scaling.md).</span></span>

<span data-ttu-id="3feeb-138">**負荷の高い CPU/IO タスクをバックグラウンド タスクとしてオフロードします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-138">**Offload intensive CPU/IO tasks as background tasks**.</span></span> <span data-ttu-id="3feeb-139">サービスへの要求の実行に長時間かかったり、かなりのリソースを消費したりすることが予測される場合、この要求の処理を別個のタスクにオフロードします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-139">If a request to a service is expected to take a long time to run or absorb considerable resources, offload the processing for this request to a separate task.</span></span> <span data-ttu-id="3feeb-140">(ホスティング プラットフォームに応じ、) worker ロールまたはバックグラウンド ジョブを使用して、これらのタスクを実行します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-140">Use worker roles or background jobs (depending on the hosting platform) to execute these tasks.</span></span> <span data-ttu-id="3feeb-141">この戦略を使用すると、サービスはさらに多くの要求を引き続き受信したり、即座に対応したりすることが可能になります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-141">This strategy enables the service to continue receiving further requests and remain responsive.</span></span>  <span data-ttu-id="3feeb-142">詳細については、「 [Background jobs guidance (バックグラウンド ジョブのガイダンス)](../best-practices/background-jobs.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-142">For more information, see [Background jobs guidance](../best-practices/background-jobs.md).</span></span>

<span data-ttu-id="3feeb-143">**バックグラウンド タスクのワークロードを分散します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-143">**Distribute the workload for background tasks**.</span></span> <span data-ttu-id="3feeb-144">多くのバックグラウンド タスクがある場合、またはタスクの実行に相当の時間かリソースが必要な場合、複数のコンピューティング ユニット (worker ロールまたはバックグラウンド ジョブなど) に作業を分散します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-144">Where there are many background tasks, or the tasks require considerable time or resources, spread the work across multiple compute units (such as worker roles or background jobs).</span></span> <span data-ttu-id="3feeb-145">考えられる解決策の 1 つについては、[競合コンシューマー パターン](../patterns/competing-consumers.md)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-145">For one possible solution, see the [Competing Consumers pattern](../patterns/competing-consumers.md).</span></span>

<span data-ttu-id="3feeb-146">**"*シェアード ナッシング*" アーキテクチャの使用を検討します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-146">**Consider moving towards a *shared-nothing* architecture**.</span></span> <span data-ttu-id="3feeb-147">シェアード ナッシング アーキテクチャでは、ノードは独立し自律的で、単一競合箇所 (共有サービスや共有ストレージなど) がありません。</span><span class="sxs-lookup"><span data-stu-id="3feeb-147">A shared-nothing architecture uses independent, self-sufficient nodes that have no single point of contention (such as shared services or storage).</span></span> <span data-ttu-id="3feeb-148">理論上、そのようなシステムはほぼ無制限にスケールできます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-148">In theory, such a system can scale almost indefinitely.</span></span> <span data-ttu-id="3feeb-149">一般に、完全なシェアード ナッシング アプローチはほとんどのアプリケーションで実用的ではありませんが、スケーラビリティの向上を考慮に入れた設計には適している場合があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-149">While a fully shared-nothing approach is generally not practical for most applications, it may provide opportunities to design for better scalability.</span></span> <span data-ttu-id="3feeb-150">たとえば、サーバー側のセッション状態、クライアント アフィニティ、データのパーティション分割の使用を避けるという方法は、シェアード ナッシング アーキテクチャを使用する良い例です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-150">For example, avoiding the use of server-side session state, client affinity, and data partitioning are good examples of moving towards a shared-nothing architecture.</span></span>

## <a name="data-management"></a><span data-ttu-id="3feeb-151">データ管理</span><span class="sxs-lookup"><span data-stu-id="3feeb-151">Data management</span></span>

<span data-ttu-id="3feeb-152">**データのパーティション分割を使用します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-152">**Use data partitioning**.</span></span> <span data-ttu-id="3feeb-153">データを複数のデータベースおよびデータベース サーバーに分割するか、このパーティション分割を透過的に実行できるデータ ストレージ サービスを使用するようにアプリケーションを設計します (サービスの例として、Azure SQL Database Elastic Database や Azure Table Storage などがあります)。</span><span class="sxs-lookup"><span data-stu-id="3feeb-153">Divide the data across multiple databases and database servers, or design the application to use data storage services that can provide this partitioning transparently (examples include Azure SQL Database Elastic Database, and Azure Table storage).</span></span> <span data-ttu-id="3feeb-154">このアプローチを使用すると、パフォーマンスを最大化すると同時に、スケーリングを容易にすることが可能です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-154">This approach can help to maximize performance and allow easier scaling.</span></span> <span data-ttu-id="3feeb-155">パーティション分割には、水平的、垂直的、機能的など、さまざまな分割法があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-155">There are different partitioning techniques, such as horizontal, vertical, and functional.</span></span> <span data-ttu-id="3feeb-156">これらを組み合わせて使用すると、クエリのパフォーマンスの向上、シンプル化されたスケーラビリティ、より柔軟性のある管理、可用性の向上から得られるメリットを最大限に活用できるだけでなく、保持されるデータとデータ ストアの種類を一致させることができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-156">You can use a combination of these to achieve maximum benefit from increased query performance, simpler scalability, more flexible management, better availability, and to match the type of store to the data it will hold.</span></span> <span data-ttu-id="3feeb-157">さらに、データ タイプに応じて異なる種類のデータ ストアを使用したり、特定のデータ タイプに合わせて最適化した場合の状態に基づいてタイプを選択したりすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-157">Also, consider using different types of data store for different types of data, choosing the types based on how well they are optimized for the specific type of data.</span></span> <span data-ttu-id="3feeb-158">これには、リレーショナル データベースの代わりに、またはリレーショナル データベースと同時に、Table Storage、ドキュメント データベース、列ファミリ データ ストアを使用することが含まれます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-158">This may include using table storage, a document database, or a column-family data store, instead of, or as well as, a relational database.</span></span> <span data-ttu-id="3feeb-159">詳細については、「 [Data partitioning guidance (データのパーティション分割のガイダンス)](../best-practices/data-partitioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-159">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

<span data-ttu-id="3feeb-160">**最終的整合性を考慮して設計します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-160">**Design for eventual consistency**.</span></span> <span data-ttu-id="3feeb-161">結果整合性を取り入れると、複数のストアに分割された関連データを同期するために必要な時間が短縮されたり、またはその時間がなくなったりするため、スケーラビリティが向上します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-161">Eventual consistency improves scalability by reducing or removing the time needed to synchronize related data partitioned across multiple stores.</span></span> <span data-ttu-id="3feeb-162">ただしその反面、データはその読み取り時に常に整合性があるとは限りません。また、書き込み操作によっては競合が生じる場合があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-162">The cost is that data is not always consistent when it is read, and some write operations may cause conflicts.</span></span> <span data-ttu-id="3feeb-163">結果整合性は、同じデータの読み取りは頻繁に行われるが、書き込みはめったに行われない場合に有効です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-163">Eventual consistency is ideal for situations where the same data is read frequently but written infrequently.</span></span> <span data-ttu-id="3feeb-164">詳細については、「[Data Consistency Primer (データ整合性入門)](https://msdn.microsoft.com/library/dn589800.aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-164">For more information, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

<span data-ttu-id="3feeb-165">**コンポーネントとサービスの間の煩雑なやり取りを削減します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-165">**Reduce chatty interactions between components and services**.</span></span> <span data-ttu-id="3feeb-166">対話型のやりとりを要する設計は避けてください。こうした設計を行うと、アプリケーションがすべてのデータを 1 回のサービス呼び出しで返すのではなく、サービスを複数回呼び出す必要が生じます (各回の呼び出しで、データは少量ずつしか返されません)。</span><span class="sxs-lookup"><span data-stu-id="3feeb-166">Avoid designing interactions in which an application is required to make multiple calls to a service (each of which returns a small amount of data), rather than a single call that can return all of the data.</span></span> <span data-ttu-id="3feeb-167">サービスまたはコンポーネントの呼び出しに著しい待ち時間が生じる場合、可能であれば関連するいくつかの操作を組み合わせて 1 つの要求にまとめてください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-167">Where possible, combine several related operations into a single request when the call is to a service or component that has noticeable latency.</span></span> <span data-ttu-id="3feeb-168">そうすることで、パフォーマンスの監視と複雑な操作の最適化を容易に実行できます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-168">This makes it easier to monitor performance and optimize complex operations.</span></span> <span data-ttu-id="3feeb-169">たとえば、データベースでストアド プロシージャを使用して、複雑なロジックをカプセル化し、ラウンド トリップおよびリソース ロックの回数を減らすことができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-169">For example, use stored procedures in databases to encapsulate complex logic, and reduce the number of round trips and resource locking.</span></span>

<span data-ttu-id="3feeb-170">**キューを使用して負荷を均等にすることで、高速なデータ書き込みを可能にします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-170">**Use queues to level the load for high velocity data writes**.</span></span> <span data-ttu-id="3feeb-171">サービス要求の急増がそのサービスを圧迫し、障害を悪化させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-171">Surges in demand for a service can overwhelm that service and cause escalating failures.</span></span> <span data-ttu-id="3feeb-172">これを防ぐには、[キュー ベースの負荷平準化パターン](../patterns/queue-based-load-leveling.md)の実装を検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-172">To prevent this, consider implementing the [Queue-Based Load Leveling pattern](../patterns/queue-based-load-leveling.md).</span></span> <span data-ttu-id="3feeb-173">タスクとそのタスクが呼び出すサービスとの間でバッファとして機能するキューを使用します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-173">Use a queue that acts as a buffer between a task and a service that it invokes.</span></span> <span data-ttu-id="3feeb-174">これにより、サービスの障害やタスクのタイムアウトを引き起こしうる断続的で重大な負荷を平準化することができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-174">This can smooth intermittent heavy loads that may otherwise cause the service to fail or the task to time out.</span></span>

<span data-ttu-id="3feeb-175">**データ ストアへの負荷を最小化します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-175">**Minimize the load on the data store**.</span></span> <span data-ttu-id="3feeb-176">一般に、データ ストアは処理のボトルネックになる、コストの高いリソースです。また多くの場合、スケールアウトが容易ではありません。可能であれば、データ ストアからロジック (XML 文書や JSON オブジェクトの処理など) を除去し、アプリケーション内で処理を実行してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-176">The data store is commonly a processing bottleneck, a costly resource, and often not easy to scale out. Where possible, remove logic (such as processing XML documents or JSON objects) from the data store, and perform processing within the application.</span></span> <span data-ttu-id="3feeb-177">たとえば、XML を (ストレージの不明瞭な文字列以外として) データベースに渡す代わりに、アプリケーション層内で XML をシリアル化/逆シリアル化し、ネイティブな形式でデータ ストアに渡します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-177">For example, instead of passing XML to the database (other than as an opaque string for storage), serialize or deserialize the XML within the application layer and pass it in a form that is native to the data store.</span></span> <span data-ttu-id="3feeb-178">通常、アプリケーションをスケールアウトする方がデータ ストアをスケールアウトするよりはるかに容易なので、多くのコンピューティング処理を要する処理はできるだけアプリケーション内で実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-178">It's typically much easier to scale out the application than the data store, so you should attempt to do as much of the compute-intensive processing as possible within the application.</span></span>

<span data-ttu-id="3feeb-179">**取得するデータの量を最小化します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-179">**Minimize the volume of data retrieved**.</span></span> <span data-ttu-id="3feeb-180">列を指定し、条件を使用して行を選択することにより、必要なデータのみ取得します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-180">Retrieve only the data you require by specifying columns and using criteria to select rows.</span></span> <span data-ttu-id="3feeb-181">テーブル値パラメーターおよび適切な分離レベルを使用します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-181">Make use of table value parameters and the appropriate isolation level.</span></span> <span data-ttu-id="3feeb-182">エンティティ タグなどのメカニズムを使用して、不要なデータを取得しないようにします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-182">Use mechanisms like entity tags to avoid retrieving data unnecessarily.</span></span>

<span data-ttu-id="3feeb-183">**キャッシングを積極的に使用します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-183">**Aggressively use caching**.</span></span> <span data-ttu-id="3feeb-184">可能な限りキャッシングを使用して、データを生成または配信するリソースおよびサービスへの負荷を削減してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-184">Use caching wherever possible to reduce the load on resources and services that generate or deliver data.</span></span> <span data-ttu-id="3feeb-185">通常、キャッシュは、比較的静的なデータ、または取得のためにかなりの量の処理を必要とするデータに適しています。</span><span class="sxs-lookup"><span data-stu-id="3feeb-185">Caching is typically suited to data that is relatively static, or that requires considerable processing to obtain.</span></span> <span data-ttu-id="3feeb-186">キャッシングは、データ アクセスとユーザー インターフェイスの生成などのアプリケーションの各層で、必要に応じてすべてのレベルで行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-186">Caching should occur at all levels where appropriate in each layer of the application, including data access and user interface generation.</span></span> <span data-ttu-id="3feeb-187">詳細については、「 [Caching Guidance (キャッシュのガイダンス)](../best-practices/caching.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-187">For more information, see the [Caching Guidance](../best-practices/caching.md).</span></span>

<span data-ttu-id="3feeb-188">**データの増大および保存に対処します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-188">**Handle data growth and retention**.</span></span> <span data-ttu-id="3feeb-189">アプリケーションが格納するデータの量は、時間の経過と共に増大します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-189">The amount of data stored by an application grows over time.</span></span> <span data-ttu-id="3feeb-190">この増大により、ストレージ コストは上昇し、データ アクセス時の待ち時間も増加します。このことは、アプリケーションのスループットおよびパフォーマンスに影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-190">This growth increases storage costs as well as latency when accessing the data, affecting application throughput and performance.</span></span> <span data-ttu-id="3feeb-191">アクセスされなくなっている古いデータを定期的にアーカイブするか、めったにアクセスしないデータを、アクセスの待ち時間がより長いが、コスト効率の良い長期保存向けのストレージに移動したりできる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-191">It may be possible to periodically archive some of the old data that is no longer accessed, or move data that is rarely accessed into long-term storage that is more cost efficient, even if the access latency is higher.</span></span>

<span data-ttu-id="3feeb-192">**効率の良いバイナリ形式でデータ転送オブジェクト (DTO) を最適化します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-192">**Optimize Data Transfer Objects (DTOs) using an efficient binary format**.</span></span> <span data-ttu-id="3feeb-193">DTO はアプリケーションの層の間で何度も渡されます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-193">DTOs are passed between the layers of an application many times.</span></span> <span data-ttu-id="3feeb-194">サイズを最小化すると、リソースとネットワークへの負荷が軽減されます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-194">Minimizing the size reduces the load on resources and the network.</span></span> <span data-ttu-id="3feeb-195">ただし、データが使用される各場所で、データを必要な形式に変換するオーバーヘッドと負荷軽減とのバランスを保つようにします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-195">However, balance the savings with the overhead of converting the data to the required format in each location where it is used.</span></span> <span data-ttu-id="3feeb-196">コンポーネントの再利用を容易にするために、相互運用性の最も高い形式を採用してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-196">Adopt a format that has the maximum interoperability to enable easy reuse of a component.</span></span>

<span data-ttu-id="3feeb-197">**キャッシュ制御を設定します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-197">**Set cache control**.</span></span> <span data-ttu-id="3feeb-198">可能な限り、出力キャッシングまたはフラグメント キャッシングを使用して、処理負荷を最小限に抑えるようにアプリケーションを設計および構成します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-198">Design and configure the application to use output caching or fragment caching where possible, to minimize processing load.</span></span>

<span data-ttu-id="3feeb-199">**クライアント側キャッシングを有効にします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-199">**Enable client side caching**.</span></span> <span data-ttu-id="3feeb-200">Web アプリケーションでは、キャッシュ可能なコンテンツ上でキャッシュ設定を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-200">Web applications should enable cache settings on the content that can be cached.</span></span> <span data-ttu-id="3feeb-201">通常、規定では無効になっています。</span><span class="sxs-lookup"><span data-stu-id="3feeb-201">This is commonly disabled by default.</span></span> <span data-ttu-id="3feeb-202">プロキシ サーバーおよびクラアント上でコンテンツのキャッシングを有効にするために、適切なキャッシュ制御ヘッダーを提供するようサーバーを構成します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-202">Configure the server to deliver the appropriate cache control headers to enable caching of content on proxy servers and clients.</span></span>

<span data-ttu-id="3feeb-203">**Azure BLOB Storage と Azure Content Delivery Network を使用して、アプリケーションへの負荷を軽減します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-203">**Use Azure blob storage and the Azure Content Delivery Network to reduce the load on the application**.</span></span> <span data-ttu-id="3feeb-204">イメージ、リソース、スクリプト、スタイル シートといった静的または比較的静的なパブリック コンテンツを Blob Storage に格納することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-204">Consider storing static or relatively static public content, such as images, resources, scripts, and style sheets, in blob storage.</span></span> <span data-ttu-id="3feeb-205">このアプローチにより、要求ごとにこのコンテンツを動的に生成することで発生する負荷をアプリケーションから除くことができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-205">This approach relieves the application of the load caused by dynamically generating this content for each request.</span></span> <span data-ttu-id="3feeb-206">さらに、Content Delivery Network を使用してこのコンテンツをキャッシュし、クライアントに配信することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-206">Additionally, consider using the Content Delivery Network to cache this content and deliver it to clients.</span></span> <span data-ttu-id="3feeb-207">Content Delivery Network を使用すると、クライアント側のパフォーマンスを向上できます。なぜなら、コンテンツは、Content Delivery Network キャッシュを利用できる地理的に最も近いデータセンターから配信されるからです。</span><span class="sxs-lookup"><span data-stu-id="3feeb-207">Using the Content Delivery Network can improve performance at the client because the content is delivered from the geographically closest datacenter that contains a Content Delivery Network cache.</span></span> <span data-ttu-id="3feeb-208">詳細については、[コンテンツ配信ネットワークのガイダンス](../best-practices/cdn.md)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-208">For more information, see the [Content Delivery Network Guidance](../best-practices/cdn.md).</span></span>

<span data-ttu-id="3feeb-209">**SQL クエリおよびインデックスを最適化し、調整します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-209">**Optimize and tune SQL queries and indexes**.</span></span> <span data-ttu-id="3feeb-210">T-SQL ステートメントまたはコンストラクトの中には、パフォーマンスに悪影響を与えるものがあります。この影響は、ストアド プロシージャでコードを最適化することにより軽減できます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-210">Some T-SQL statements or constructs may have an adverse effect on performance that can be reduced by optimizing the code in a stored procedure.</span></span> <span data-ttu-id="3feeb-211">たとえば、**datetime** 型を **varchar** に変換してから **datetime** リテラル値と比較しないでください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-211">For example, avoid converting **datetime** types to a **varchar** before comparing with a **datetime** literal value.</span></span> <span data-ttu-id="3feeb-212">代わりに日付/時刻比較関数を使用します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-212">Use date/time comparison functions instead.</span></span> <span data-ttu-id="3feeb-213">適切なインデックスがないと、クエリの実行が遅くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-213">Lack of appropriate indexes can also slow query execution.</span></span> <span data-ttu-id="3feeb-214">オブジェクト/リレーショナル マッピング フレームワークを使用する場合、その動作およびデータ アクセス層のパフォーマンスへの影響を理解しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-214">If you use an object/relational mapping framework, understand how it works and how it may affect performance of the data access layer.</span></span> <span data-ttu-id="3feeb-215">詳細については、「[クエリのチューニング](https://technet.microsoft.com/library/ms176005.aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-215">For more information, see [Query Tuning](https://technet.microsoft.com/library/ms176005.aspx).</span></span>

<span data-ttu-id="3feeb-216">**データの非正規化を検討します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-216">**Consider de-normalizing data**.</span></span> <span data-ttu-id="3feeb-217">データの非正規化により、重複や不整合を避けることができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-217">Data normalization helps to avoid duplication and inconsistency.</span></span> <span data-ttu-id="3feeb-218">しかし、複数のインデックスを保守する、参照整合性を検査する、小さいデータ チャンクに複数回アクセスを実行する、テーブルを結合してデータを再アセンブルするといった作業が必要になるため、オーバーヘッドが生じて、パフォーマンスに影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-218">However, maintaining multiple indexes, checking for referential integrity, performing multiple accesses to small chunks of data, and joining tables to reassemble the data imposes an overhead that can affect performance.</span></span> <span data-ttu-id="3feeb-219">データ ストアへの負荷を軽減するために、追加のストレージ ボリュームおよび重複を受け入れられるかどうかを検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-219">Consider if some additional storage volume and duplication is acceptable in order to reduce the load on the data store.</span></span> <span data-ttu-id="3feeb-220">また、データ ストアへの負荷を軽減するために、参照整合性の管理などのタスクの引き継ぎにアプリケーションそのもの (通常は、スケーリングがより容易) を利用できるかどうかも検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-220">Also, consider if the application itself (which is typically easier to scale) can be relied upon to take over tasks such as managing referential integrity in order to reduce the load on the data store.</span></span> <span data-ttu-id="3feeb-221">詳細については、「 [Data partitioning guidance (データのパーティション分割のガイダンス)](../best-practices/data-partitioning.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-221">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

## <a name="implementation"></a><span data-ttu-id="3feeb-222">実装</span><span class="sxs-lookup"><span data-stu-id="3feeb-222">Implementation</span></span>

<span data-ttu-id="3feeb-223">**パフォーマンスのアンチパターンを確認します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-223">**Review the performance antipatterns**.</span></span> <span data-ttu-id="3feeb-224">アプリケーションの負荷が高いときに、スケーラビリティの問題を引き起こす可能性がある一般的なプラクティスについては、「[クラウド アプリケーションのパフォーマンスのアンチパターン](../antipatterns/index.md)」をご覧ください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-224">See [Performance antipatterns for cloud applications](../antipatterns/index.md) for common practices that are likely to cause scalability problems when an application is under pressure.</span></span>

<span data-ttu-id="3feeb-225">**非同期呼び出しを使用します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-225">**Use asynchronous calls**.</span></span> <span data-ttu-id="3feeb-226">I/O またはネットワーク帯域幅によって制限される可能性があるリソースまたはサービス、あるいは著しい待ち時間があるリソースまたはサービスにアクセスする際には、呼び出し側のスレッドをロックしないために、可能な限り非同期コードを使用します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-226">Use asynchronous code wherever possible when accessing resources or services that may be limited by I/O or network bandwidth, or that have a noticeable latency, in order to avoid locking the calling thread.</span></span>

<span data-ttu-id="3feeb-227">**リソースのロックを避け、代わりにオプティミスティック アプローチを使用します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-227">**Avoid locking resources, and use an optimistic approach instead**.</span></span> <span data-ttu-id="3feeb-228">ストレージなどのリソースまたは著しい待ち時間がある他のサービスへのアクセスをロックしないでください。なぜなら、パフォーマンス低下の主な原因は、このロックだからです。</span><span class="sxs-lookup"><span data-stu-id="3feeb-228">Never lock access to resources such as storage or other services that have noticeable latency, because this is a primary cause of poor performance.</span></span> <span data-ttu-id="3feeb-229">ストレージへの書き込みなどの並行操作の管理には、常にオプティミスティック アプローチを使用してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-229">Always use optimistic approaches to managing concurrent operations, such as writing to storage.</span></span> <span data-ttu-id="3feeb-230">また、競合の管理には、ストレージ層の機能を使用してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-230">Use features of the storage layer to manage conflicts.</span></span> <span data-ttu-id="3feeb-231">分散化アプリケーションでは、データの一貫性は最終的にしか保たれない場合があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-231">In distributed applications, data may be only eventually consistent.</span></span>

<span data-ttu-id="3feeb-232">**高遅延で低帯域幅のネットワークを使用する場合、高圧縮可能なデータを圧縮します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-232">**Compress highly compressible data over high latency, low bandwidth networks**.</span></span> <span data-ttu-id="3feeb-233">Web アプリケーションではほとんどの場合、アプリケーションによって生成され、ネットワーク上で渡される最大のデータは、クライアントの要求に対する HTTP 応答です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-233">In the majority of cases in a web application, the largest volume of data generated by the application and passed over the network is HTTP responses to client requests.</span></span> <span data-ttu-id="3feeb-234">この大きさは、HTTP 圧縮により、大幅に縮小できます。特に静的コンテンツの場合には効果的です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-234">HTTP compression can reduce this considerably, especially for static content.</span></span> <span data-ttu-id="3feeb-235">これにより、コストを削減できるだけでなく、ネットワークへの負荷も削減できます。ただし、動的コンテンツの圧縮では、部分的に高い負荷がサーバーにかかります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-235">This can reduce cost as well as reducing the load on the network, though compressing dynamic content does apply a fractionally higher load on the server.</span></span> <span data-ttu-id="3feeb-236">より汎用的な他の環境では、データを圧縮してデータ転送量を削減することで、転送時間とコストを最小化できますが、圧縮と展開のプロセスによるオーバーヘッドが発生します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-236">In other, more generalized environments, data compression can reduce the volume of data transmitted and minimize transfer time and costs, but the compression and decompression processes incur overhead.</span></span> <span data-ttu-id="3feeb-237">そのため、データ圧縮は、パフォーマンス面で明らかなメリットがある場合に限り使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-237">As such, compression should only be used when there is a demonstrable gain in performance.</span></span> <span data-ttu-id="3feeb-238">JSON やバイナリ エンコーディングなど、他のシリアル化方式では、パフォーマンスにそれほど影響を与えずに、ペイロード サイズを減らすことができます。一方、XML ではペイロード サイズが増加する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-238">Other serialization methods, such as JSON or binary encodings, may reduce the payload size while having less impact on performance, whereas XML is likely to increase it.</span></span>

<span data-ttu-id="3feeb-239">**接続およびリソースが使用されている時間を最小限にします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-239">**Minimize the time that connections and resources are in use**.</span></span> <span data-ttu-id="3feeb-240">接続およびリソースは、必要な期間だけ維持します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-240">Maintain connections and resources only for as long as you need to use them.</span></span> <span data-ttu-id="3feeb-241">たとえば、接続を開くのはできるだけ遅く、接続プールに返すのはできるだけ早くします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-241">For example, open connections as late as possible, and allow them to be returned to the connection pool as soon as possible.</span></span> <span data-ttu-id="3feeb-242">リソースの取得はできるだけ遅くし、解放はできるだけ早くします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-242">Acquire resources as late as possible, and dispose of them as soon as possible.</span></span>

<span data-ttu-id="3feeb-243">**必要な接続の数を最小限にします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-243">**Minimize the number of connections required**.</span></span> <span data-ttu-id="3feeb-244">サービス接続はリソースを消費します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-244">Service connections absorb resources.</span></span> <span data-ttu-id="3feeb-245">必要な数を制限し、可能な場合には既存の接続を再利用するようにします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-245">Limit the number that are required and ensure that existing connections are reused whenever possible.</span></span> <span data-ttu-id="3feeb-246">たとえば、認証の実行後、必要に応じて権限借用を使用し、コードを特定の ID として実行します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-246">For example, after performing authentication, use impersonation where appropriate to run code as a specific identity.</span></span> <span data-ttu-id="3feeb-247">これにより、接続が再利用されるため、接続プールを最大限に活用できます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-247">This can help to make best use of the connection pool by reusing connections.</span></span>
  
> [!NOTE]
> <span data-ttu-id="3feeb-248">一部のサービスの API では、サービス固有のガイドラインに従っていることを前提に接続が自動的に再利用されます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-248">APIs for some services automatically reuse connections, provided service-specific guidelines are followed.</span></span> <span data-ttu-id="3feeb-249">アプリケーションで使用される各サービスに対して接続の再利用を有効にする条件を理解しておくことが重要です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-249">It's important that you understand the conditions that enable connection reuse for each service that your application uses.</span></span>

<span data-ttu-id="3feeb-250">**要求をバッチで送信して、ネットワークの使用を最適化します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-250">**Send requests in batches to optimize network use**.</span></span> <span data-ttu-id="3feeb-251">たとえば、キューにアクセスするときにはメッセージの送信および読み取りをバッチで行い、ストレージまたはキャッシュにアクセスするときには複数の読み取りまたは書き込みをバッチとして実行します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-251">For example, send and read messages in batches when accessing a queue, and perform multiple reads or writes as a batch when accessing storage or a cache.</span></span> <span data-ttu-id="3feeb-252">このように、ネットワーク上の呼び出しの数を減らすことで、サービスおよびデータ ストアの効率を最大限に高めることができます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-252">This can help to maximize efficiency of the services and data stores by reducing the number of calls across the network.</span></span>

<span data-ttu-id="3feeb-253">可能な場合には、**サーバー側のセッション状態を格納しないで済むようにします**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-253">**Avoid a requirement to store server-side session state** where possible.</span></span> <span data-ttu-id="3feeb-254">通常、サーバー側のセッション状態の管理にはクライアント アフィニティが必要です (つまり、各要求を同じサーバー インスタンスにルーティングします)。これはシステムのスケール能力に影響を与えます。</span><span class="sxs-lookup"><span data-stu-id="3feeb-254">Server-side session state management typically requires client affinity (that is, routing each request to the same server instance), which affects the ability of the system to scale.</span></span> <span data-ttu-id="3feeb-255">理想的には、クライアントが使用するサーバーに対して、クライアントをステートレスに設計する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-255">Ideally, you should design clients to be stateless with respect to the servers that they use.</span></span> <span data-ttu-id="3feeb-256">ただし、アプリケーションがセッション状態を維持する必要がある場合、機密性の高いデータまたはクライアントごとの大量データは、アプリケーションのすべてのインスタンスがアクセスできる分散されたサーバー側のキャッシュに格納してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-256">However, if the application must maintain session state, store sensitive data or large volumes of per-client data in a distributed server-side cache that all instances of the application can access.</span></span>

<span data-ttu-id="3feeb-257">**テーブル ストレージ スキーマを最適化します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-257">**Optimize table storage schemas**.</span></span> <span data-ttu-id="3feeb-258">Azure Table Storage のように、テーブルと列の名前をクエリごとに渡して処理する必要があるテーブル ストアを使用する場合は、このオーバーヘッドを減らすために短い名前の使用を検討してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-258">When using table stores that require the table and column names to be passed and processed with every query, such as Azure table storage, consider using shorter names to reduce this overhead.</span></span> <span data-ttu-id="3feeb-259">ただし、名前を極端に短くして、読みやすさや管理の容易さが犠牲にならないようにします。</span><span class="sxs-lookup"><span data-stu-id="3feeb-259">However, do not sacrifice readability or manageability by using overly compact names.</span></span>

<span data-ttu-id="3feeb-260">**デプロイ中またはアプリケーションのスタートアップ時にリソースの依存関係を作成します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-260">**Create resource dependencies during deployment or at application startup**.</span></span> <span data-ttu-id="3feeb-261">リソースが存在するかどうかをテストするメソッドを繰り返し呼び出して、リソースが存在しない場合に作成するというロジックは組み込まないでください </span><span class="sxs-lookup"><span data-stu-id="3feeb-261">Avoid repeated calls to methods that test the existence of a resource and then create the resource if it does not exist.</span></span> <span data-ttu-id="3feeb-262">Azure Storage クライアント ライブラリ内の *CloudTable.CreateIfNotExists* や *CloudQueue.CreateIfNotExists* などのメソッドは、このパターンに従っています。</span><span class="sxs-lookup"><span data-stu-id="3feeb-262">Methods such as *CloudTable.CreateIfNotExists* and *CloudQueue.CreateIfNotExists* in the Azure Storage Client Library follow this pattern.</span></span> <span data-ttu-id="3feeb-263">ストレージ テーブルまたはストレージ キューにアクセスする前に、毎回これらのメソッドが呼び出される場合、著しいオーバーヘッドが生じる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-263">These methods can impose considerable overhead if they are invoked before each access to a storage table or storage queue.</span></span> <span data-ttu-id="3feeb-264">その代わりに、次の方法を使用します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-264">Instead:</span></span>

- <span data-ttu-id="3feeb-265">アプリケーションのデプロイ時または初回の起動時に必要なリソースを作成します (各リソースについて、Web ロールまたは worker ロール用のスタートアップ コードで *CreateIfNotExists* を 1 回呼び出すのが適切です)。</span><span class="sxs-lookup"><span data-stu-id="3feeb-265">Create the required resources when the application is deployed, or when it first starts (a single call to *CreateIfNotExists* for each resource in the startup code for a web or worker role is acceptable).</span></span> <span data-ttu-id="3feeb-266">ただし、存在しないリソースに対してコードがアクセスしようとする場合に生じる可能性がある例外を必ず処理します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-266">However, be sure to handle exceptions that may arise if your code attempts to access a resource that doesn't exist.</span></span> <span data-ttu-id="3feeb-267">こうした状況では、例外を記録し、リソースが見つからないことをオペレーターに可能な限り警告する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-267">In these situations, you should log the exception, and possibly alert an operator that a resource is missing.</span></span>
- <span data-ttu-id="3feeb-268">状況によっては、見つからないリソースを例外処理コードの一部として作成することが適切です。</span><span class="sxs-lookup"><span data-stu-id="3feeb-268">Under some circumstances, it may be appropriate to create the missing resource as part of the exception handling code.</span></span> <span data-ttu-id="3feeb-269">ただし、リソースが見つからない理由として、プログラミング エラー (リソース名のスペルミスなど) や他のインフラストラクチャ レベルの問題も考えられるため、このアプローチは慎重に採用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-269">But you should adopt this approach with caution as the non-existence of the resource might be indicative of a programming error (a misspelled resource name for example), or some other infrastructure-level issue.</span></span>

<span data-ttu-id="3feeb-270">**軽量フレームワークを使用します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-270">**Use lightweight frameworks**.</span></span> <span data-ttu-id="3feeb-271">リソース使用量、実行時間、アプリケーションへの全体的な負荷を最小限にするために、使用する API およびフレームワークを慎重に検討します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-271">Carefully choose the APIs and frameworks you use to minimize resource usage, execution time, and overall load on the application.</span></span> <span data-ttu-id="3feeb-272">たとえば、Web API を使用してサービス要求を処理すると、アプリケーションのフットプリントが小さくなり、実行速度が向上します。しかし、Windows Communication Foundation の追加機能が必要となる高度なシナリオには適さない場合があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-272">For example, using Web API to handle service requests can reduce the application footprint and increase execution speed, but it may not be suitable for advanced scenarios where the additional capabilities of Windows Communication Foundation are required.</span></span>

<span data-ttu-id="3feeb-273">**サービス アカウントの数を最小限にすることを検討します**。</span><span class="sxs-lookup"><span data-stu-id="3feeb-273">**Consider minimizing the number of service accounts**.</span></span> <span data-ttu-id="3feeb-274">たとえば、接続に制限が課されているリソースまたはサービスにアクセスしたり、維持する接続の数を少なくするとパフォーマンスが向上したりする場合は、固有のアカウントを使用します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-274">For example, use a specific account to access resources or services that impose a limit on connections, or perform better where fewer connections are maintained.</span></span> <span data-ttu-id="3feeb-275">このアプローチは、データベースなどのサービスには一般的ですが、元のユーザーの権限借用であるため、操作を正確に監査する能力に影響する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-275">This approach is common for services such as databases, but it can affect the ability to accurately audit operations due to the impersonation of the original user.</span></span>

<span data-ttu-id="3feeb-276">**パフォーマンスのプロファイリングおよび負荷テストを行って** 、アプリケーションのパフォーマンスおよびスケーリングが要求どおりであることを確認します。</span><span class="sxs-lookup"><span data-stu-id="3feeb-276">**Carry out performance profiling and load testing** during development, as part of test routines, and before final release to ensure the application performs and scales as required.</span></span> <span data-ttu-id="3feeb-277">このテストは、運用プラットフォームと同じタイプのハードウェアに対して、さらに運用中に生じるデータおよびユーザー負荷と同じタイプおよび数量を用いて実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="3feeb-277">This testing should occur on the same type of hardware as the production platform, and with the same types and quantities of data and user load as it will encounter in production.</span></span> <span data-ttu-id="3feeb-278">詳細については、「 [クラウド サービスのパフォーマンスのテスト](/azure/vs-azure-tools-performance-profiling-cloud-services/)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="3feeb-278">For more information, see [Testing the performance of a cloud service](/azure/vs-azure-tools-performance-profiling-cloud-services/).</span></span>
