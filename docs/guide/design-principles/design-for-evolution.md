---
title: 変更を見込んだ設計
titleSuffix: Azure Application Architecture Guide
description: 改良を見込んだ設計は、継続的なイノベーションのための鍵です。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 4a1ed92f70660f16c07b4b472c3ef358af4319c9
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/20/2019
ms.locfileid: "58245703"
---
# <a name="design-for-evolution"></a><span data-ttu-id="5d8c3-103">改良を見込んだ設計</span><span class="sxs-lookup"><span data-stu-id="5d8c3-103">Design for evolution</span></span>

## <a name="an-evolutionary-design-is-key-for-continuous-innovation"></a><span data-ttu-id="5d8c3-104">改良を見込んだ設計は、継続的なイノベーションのための鍵</span><span class="sxs-lookup"><span data-stu-id="5d8c3-104">An evolutionary design is key for continuous innovation</span></span>

<span data-ttu-id="5d8c3-105">いかによくできたアプリケーションであっても、長く使用していくうちに、バグを修正したり、新機能を追加したり、新しいテクノロジを導入したり、既存のシステムのスケーラビリティや回復性を改善したりするために、変更が加えられていきます。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-105">All successful applications change over time, whether to fix bugs, add new features, bring in new technologies, or make existing systems more scalable and resilient.</span></span> <span data-ttu-id="5d8c3-106">アプリケーションのすべての部分が緊密に結合されていると、システムに変更を加えることが非常に困難になります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-106">If all the parts of an application are tightly coupled, it becomes very hard to introduce changes into the system.</span></span> <span data-ttu-id="5d8c3-107">アプリケーションの 1 か所に変更を加えることで、別の部分が機能しなくなったり、コードベース全体に変更の影響が波及する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-107">A change in one part of the application may break another part, or cause changes to ripple through the entire codebase.</span></span>

<span data-ttu-id="5d8c3-108">この問題は、モノリシックなアプリケーションにだけ起こることではありません。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-108">This problem is not limited to monolithic applications.</span></span> <span data-ttu-id="5d8c3-109">アプリケーションが複数のサービスに分かれていても、結合性が高ければ、システムが固定的になり、機能が故障しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-109">An application can be decomposed into services, but still exhibit the sort of tight coupling that leaves the system rigid and brittle.</span></span> <span data-ttu-id="5d8c3-110">しかし、将来の改良を見込んだ方法でサービスが設計されていれば、イノベーションを導入しながら、継続的に新しい機能を提供していくことができます。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-110">But when services are designed to evolve, teams can innovate and continuously deliver new features.</span></span>

<span data-ttu-id="5d8c3-111">マイクロサービスは、以下の考慮事項の多くに対応しているため、改良に耐える設計を実現するための一般的な手段になりつつあります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-111">Microservices are becoming a popular way to achieve an evolutionary design, because they address many of the considerations listed here.</span></span>

## <a name="recommendations"></a><span data-ttu-id="5d8c3-112">Recommendations</span><span class="sxs-lookup"><span data-stu-id="5d8c3-112">Recommendations</span></span>

<span data-ttu-id="5d8c3-113">**高凝集と疎結合を徹底する**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-113">**Enforce high cohesion and loose coupling**.</span></span> <span data-ttu-id="5d8c3-114">サービスが*高凝集*であるというのは、その機能に論理的なまとまりがあるという意味です。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-114">A service is *cohesive* if it provides functionality that logically belongs together.</span></span> <span data-ttu-id="5d8c3-115">サービスが*疎結合*であるというのは、1 つのサービスを変更しても、他のサービスを変更する必要が生じないという意味です。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-115">Services are *loosely coupled* if you can change one service without changing the other.</span></span> <span data-ttu-id="5d8c3-116">高凝集は通常、1 つの機能を変更しても他の関連機能を変更する必要がないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-116">High cohesion generally means that changes in one function will require changes in other related functions.</span></span> <span data-ttu-id="5d8c3-117">あるサービスを更新するために他のサービスも連携的に更新する必要がある場合、それはサービスが高凝集でないことの表れかもしれません。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-117">If you find that updating a service requires coordinated updates to other services, it may be a sign that your services are not cohesive.</span></span> <span data-ttu-id="5d8c3-118">ドメイン ベース デザイン (DDD) の目的の 1 つは、それらの境界を特定することです。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-118">One of the goals of domain-driven design (DDD) is to identify those boundaries.</span></span>

<span data-ttu-id="5d8c3-119">**ドメイン ナレッジをカプセル化する**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-119">**Encapsulate domain knowledge**.</span></span> <span data-ttu-id="5d8c3-120">クライアントがサービスを利用する際、ドメインのビジネス ルールを実施する責任をクライアントに負わせることは適切ではありません。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-120">When a client consumes a service, the responsibility for enforcing the business rules of the domain should not fall on the client.</span></span> <span data-ttu-id="5d8c3-121">代わりに、サービス側で当該のドメイン ナレッジをすべてカプセル化するようにしましょう。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-121">Instead, the service should encapsulate all of the domain knowledge that falls under its responsibility.</span></span> <span data-ttu-id="5d8c3-122">そうしないと、各クライアントでビジネス ルールを実施しなければならなくなり、ドメイン ナレッジがアプリケーションのさまざまな部分に分散することになります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-122">Otherwise, every client has to enforce the business rules, and you end up with domain knowledge spread across different parts of the application.</span></span>

<span data-ttu-id="5d8c3-123">**非同期メッセージングを使用する**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-123">**Use asynchronous messaging**.</span></span> <span data-ttu-id="5d8c3-124">非同期メッセージングは、メッセージ プロデューサーをコンシューマーから分離するための手段です。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-124">Asynchronous messaging is a way to decouple the message producer from the consumer.</span></span> <span data-ttu-id="5d8c3-125">プロデューサーは、コンシューマーがメッセージに応答したり、特定のアクションを実行することに依存しません。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-125">The producer does not depend on the consumer responding to the message or taking any particular action.</span></span> <span data-ttu-id="5d8c3-126">パブリッシュ/サブスクライブ アーキテクチャでは、メッセージを消費するユーザーをプロデューサー側で把握できないこともあります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-126">With a pub/sub architecture, the producer may not even know who is consuming the message.</span></span> <span data-ttu-id="5d8c3-127">新しいサービスでは、プロデューサーを変更することなく、メッセージを簡単に消費できます。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-127">New services can easily consume the messages without any modifications to the producer.</span></span>

<span data-ttu-id="5d8c3-128">**ドメイン ナレッジをゲートウェイ内に構築しない**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-128">**Don't build domain knowledge into a gateway**.</span></span> <span data-ttu-id="5d8c3-129">マイクロサービス アーキテクチャでは、要求のルーティング、プロトコル変換、負荷分散、認証などにゲートウェイが役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-129">Gateways can be useful in a microservices architecture, for things like request routing, protocol translation, load balancing, or authentication.</span></span> <span data-ttu-id="5d8c3-130">ただし、ゲートウェイの使用は、この種のインフラストラクチャ機能だけに制限する必要があります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-130">However, the gateway should be restricted to this sort of infrastructure functionality.</span></span> <span data-ttu-id="5d8c3-131">依存性が大きくなるのを避けるため、ゲートウェイにはドメイン ナレッジを実装しないようにしてください。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-131">It should not implement any domain knowledge, to avoid becoming a heavy dependency.</span></span>

<span data-ttu-id="5d8c3-132">**オープン インターフェイスを公開する**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-132">**Expose open interfaces**.</span></span> <span data-ttu-id="5d8c3-133">サービス間にカスタム変換レイヤーを作成することは避けてください。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-133">Avoid creating custom translation layers that sit between services.</span></span> <span data-ttu-id="5d8c3-134">代わりに、サービスでは、API コントラクトが適切に定義された API を公開するようにしましょう。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-134">Instead, a service should expose an API with a well-defined API contract.</span></span> <span data-ttu-id="5d8c3-135">また、API をバージョン管理して、旧バージョンとの互換性を維持しながら改良を加えていけるようにしましょう。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-135">The API should be versioned, so that you can evolve the API while maintaining backward compatibility.</span></span> <span data-ttu-id="5d8c3-136">そうすることで、依存するすべての上位サービスを更新しなくても、サービスを更新できるようになります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-136">That way, you can update a service without coordinating updates to all of the upstream services that depend on it.</span></span> <span data-ttu-id="5d8c3-137">パブリックに公開されるサービスでは、HTTP 経由で RESTful API を公開するようにしましょう。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-137">Public facing services should expose a RESTful API over HTTP.</span></span> <span data-ttu-id="5d8c3-138">バックエンド サービスでは、パフォーマンス上の理由で、RPC スタイルのメッセージング プロトコルが使用される場合もあります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-138">Backend services might use an RPC-style messaging protocol for performance reasons.</span></span>

<span data-ttu-id="5d8c3-139">**サービス コントラクトを設計し、テストする**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-139">**Design and test against service contracts**.</span></span> <span data-ttu-id="5d8c3-140">適切に定義された API がサービスで公開されていれば、それらの API に準じた開発やテストが可能になります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-140">When services expose well-defined APIs, you can develop and test against those APIs.</span></span> <span data-ttu-id="5d8c3-141">そうすることで、すべての依存サービスに混乱をもたらすことなく、個々 のサービスを開発し、テストできるようになります</span><span class="sxs-lookup"><span data-stu-id="5d8c3-141">That way, you can develop and test an individual service without spinning up all of its dependent services.</span></span> <span data-ttu-id="5d8c3-142">(当然ながら、統合とロードのテストは実際のサービスに対して実行する必要があります)。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-142">(Of course, you would still perform integration and load testing against the real services.)</span></span>

<span data-ttu-id="5d8c3-143">**抽象インフラストラクチャをドメイン ロジックと分離する**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-143">**Abstract infrastructure away from domain logic**.</span></span> <span data-ttu-id="5d8c3-144">ドメイン ロジックをインフラストラクチャ関連の機能 (メッセージングや永続化など) と関係させることは避けてください。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-144">Don't let domain logic get mixed up with infrastructure-related functionality, such as messaging or persistence.</span></span> <span data-ttu-id="5d8c3-145">そうしないと、ドメイン ロジックが変更された場合に、インフラストラクチャ レイヤーでも更新が必要になります (逆も同様)。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-145">Otherwise, changes in the domain logic will require updates to the infrastructure layers and vice versa.</span></span>

<span data-ttu-id="5d8c3-146">**複数のサービスにまたがる機能を専用のサービスにオフロードする**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-146">**Offload cross-cutting concerns to a separate service**.</span></span> <span data-ttu-id="5d8c3-147">たとえば、複数のサービスで要求を認証する必要がある場合には、その機能を専用のサービスに移動するなどしてください。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-147">For example, if several services need to authenticate requests, you could move this functionality into its own service.</span></span> <span data-ttu-id="5d8c3-148">そうすれば、認証を使用するサービスに手を加えなくても、認証サービスを改良できるようになります (新しい認証フローを追加するなど)。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-148">Then you could evolve the authentication service &mdash; for example, by adding a new authentication flow &mdash; without touching any of the services that use it.</span></span>

<span data-ttu-id="5d8c3-149">**サービスを個別にデプロイする**。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-149">**Deploy services independently**.</span></span> <span data-ttu-id="5d8c3-150">DevOps チームがサービスをデプロイする際、アプリケーション内の他のサービスと切り離して作業できるようにすれば、更新もすばやく安全に行えるようになります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-150">When the DevOps team can deploy a single service independently of other services in the application, updates can happen more quickly and safely.</span></span> <span data-ttu-id="5d8c3-151">バグ修正や新機能も、より定期的な間隔で展開できるようになります。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-151">Bug fixes and new features can be rolled out at a more regular cadence.</span></span> <span data-ttu-id="5d8c3-152">アプリケーションとリリース プロセスのどちらについても、独立した更新をサポートできる設計を行いましょう。</span><span class="sxs-lookup"><span data-stu-id="5d8c3-152">Design both the application and the release process to support independent updates.</span></span>
