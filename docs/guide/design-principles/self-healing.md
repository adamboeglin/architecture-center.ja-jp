---
title: 自己復旧の設計
titleSuffix: Azure Application Architecture Guide
description: 回復性の高いアプリケーションは、手動介入なしで障害から回復することができます。
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 84bc6e5c8d78517e3dc1dc0ee8d250346a33ce43
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2019
ms.locfileid: "59641197"
---
# <a name="design-for-self-healing"></a><span data-ttu-id="004f9-103">自己復旧の設計</span><span class="sxs-lookup"><span data-stu-id="004f9-103">Design for self healing</span></span>

## <a name="design-your-application-to-be-self-healing-when-failures-occur"></a><span data-ttu-id="004f9-104">障害の発生に備えてアプリケーションの自己復旧を設計する</span><span class="sxs-lookup"><span data-stu-id="004f9-104">Design your application to be self healing when failures occur</span></span>

<span data-ttu-id="004f9-105">分散システムでは、障害が発生します。</span><span class="sxs-lookup"><span data-stu-id="004f9-105">In a distributed system, failures happen.</span></span> <span data-ttu-id="004f9-106">ハードウェアのエラーがありえます。</span><span class="sxs-lookup"><span data-stu-id="004f9-106">Hardware can fail.</span></span> <span data-ttu-id="004f9-107">ネットワークに一時的な障害が起きることがあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-107">The network can have transient failures.</span></span> <span data-ttu-id="004f9-108">まれに、サービス全体またはリージョン全体で中断が発生する可能性がありますが、こうしたことについても計画しておく必要があります。</span><span class="sxs-lookup"><span data-stu-id="004f9-108">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="004f9-109">そこで、障害の発生に備えて、自己復旧するようにアプリケーションを設計します。</span><span class="sxs-lookup"><span data-stu-id="004f9-109">Therefore, design an application to be self healing when failures occur.</span></span> <span data-ttu-id="004f9-110">これには、3 つのアプローチが必要です。</span><span class="sxs-lookup"><span data-stu-id="004f9-110">This requires a three-pronged approach:</span></span>

- <span data-ttu-id="004f9-111">障害を検出する。</span><span class="sxs-lookup"><span data-stu-id="004f9-111">Detect failures.</span></span>
- <span data-ttu-id="004f9-112">障害に適切に対応する。</span><span class="sxs-lookup"><span data-stu-id="004f9-112">Respond to failures gracefully.</span></span>
- <span data-ttu-id="004f9-113">障害をログ記録および監視し、運用に関する分析情報を提供する。</span><span class="sxs-lookup"><span data-stu-id="004f9-113">Log and monitor failures, to give operational insight.</span></span>

<span data-ttu-id="004f9-114">特定の種類の障害にどのように対応するかは、アプリケーションの可用性要件によって異なります。</span><span class="sxs-lookup"><span data-stu-id="004f9-114">How you respond to a particular type of failure may depend on your application's availability requirements.</span></span> <span data-ttu-id="004f9-115">たとえば、非常に高い可用性を必要とする場合、リージョン障害中は自動的にセカンダリ リージョンにフェールオーバーさせるかもしれません。</span><span class="sxs-lookup"><span data-stu-id="004f9-115">For example, if you require very high availability, you might automatically fail over to a secondary region during a regional outage.</span></span> <span data-ttu-id="004f9-116">ただし、単一リージョンのデプロイよりも高いコストが発生することになります。</span><span class="sxs-lookup"><span data-stu-id="004f9-116">However, that will incur a higher cost than a single-region deployment.</span></span>

<span data-ttu-id="004f9-117">また、リージョン障害などの大規模な事象は通常まれなので、それだけを考慮するのではいけません。</span><span class="sxs-lookup"><span data-stu-id="004f9-117">Also, don't just consider big events like regional outages, which are generally rare.</span></span> <span data-ttu-id="004f9-118">それ以上ではないにしてもそれと同等程度に、ネットワーク接続障害やデータベース接続障害といったローカルで短期間の障害の処理を、重視する必要があります。</span><span class="sxs-lookup"><span data-stu-id="004f9-118">You should focus as much, if not more, on handling local, short-lived failures, such as network connectivity failures or failed database connections.</span></span>

## <a name="recommendations"></a><span data-ttu-id="004f9-119">Recommendations</span><span class="sxs-lookup"><span data-stu-id="004f9-119">Recommendations</span></span>

<span data-ttu-id="004f9-120">**失敗した操作を再試行する**。</span><span class="sxs-lookup"><span data-stu-id="004f9-120">**Retry failed operations**.</span></span> <span data-ttu-id="004f9-121">一時的な障害は、ネットワーク接続の一時的な喪失、データベース接続の欠落、またはサービスがビジー状態のときのタイムアウトが原因で発生します。</span><span class="sxs-lookup"><span data-stu-id="004f9-121">Transient failures may occur due to momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="004f9-122">アプリケーションに再試行ロジックを構築して、一時的な障害を処理します。</span><span class="sxs-lookup"><span data-stu-id="004f9-122">Build retry logic into your application to handle transient failures.</span></span> <span data-ttu-id="004f9-123">多くの Azure サービスでは、クライアント SDK が自動再試行を実装します。</span><span class="sxs-lookup"><span data-stu-id="004f9-123">For many Azure services, the client SDK implements automatic retries.</span></span> <span data-ttu-id="004f9-124">詳細については、「[一時的な障害の処理][transient-fault-handling]」および「[再試行パターン][retry]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="004f9-124">For more information, see [Transient fault handling][transient-fault-handling] and the [Retry pattern][retry].</span></span>

<span data-ttu-id="004f9-125">**リモート サービスを保護する (サーキット ブレーカー)**。</span><span class="sxs-lookup"><span data-stu-id="004f9-125">**Protect failing remote services (Circuit Breaker)**.</span></span> <span data-ttu-id="004f9-126">一時的な障害の後に再試行するのはよいのですが、障害が解決しない場合には、障害が起きているサービスにアクセスする呼び出し元が多すぎる、ということになりかねません。</span><span class="sxs-lookup"><span data-stu-id="004f9-126">It's good to retry after a transient failure, but if the failure persists, you can end up with too many callers hammering a failing service.</span></span> <span data-ttu-id="004f9-127">要求はバックアップされるため、これでは障害が山積みになっていくことになります。</span><span class="sxs-lookup"><span data-stu-id="004f9-127">This can lead to cascading failures, as requests back up.</span></span> <span data-ttu-id="004f9-128">[サーキット ブレーカー パターン][circuit-breaker]を使用して、操作が失敗しそうなときに (リモート呼び出しを行わずに) フェイル ファストします。</span><span class="sxs-lookup"><span data-stu-id="004f9-128">Use the [Circuit Breaker pattern][circuit-breaker] to fail fast (without making the remote call) when an operation is likely to fail.</span></span>

<span data-ttu-id="004f9-129">**重要なリソースを分離する (バルクヘッド)**。</span><span class="sxs-lookup"><span data-stu-id="004f9-129">**Isolate critical resources (Bulkhead)**.</span></span> <span data-ttu-id="004f9-130">1 つのサブシステムで障害が連鎖することがあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-130">Failures in one subsystem can sometimes cascade.</span></span> <span data-ttu-id="004f9-131">これが起きるのは、障害によってスレッドやソケットなどのリソースが適切なタイミングで解放されない場合で、リソースの消費につながります。</span><span class="sxs-lookup"><span data-stu-id="004f9-131">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> <span data-ttu-id="004f9-132">これを回避するには、システムを分離グループに分割して、1 つのパーティションでの障害がシステム全体をダウンさせないようにします。</span><span class="sxs-lookup"><span data-stu-id="004f9-132">To avoid this, partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span>

<span data-ttu-id="004f9-133">**負荷平準化を行う**。</span><span class="sxs-lookup"><span data-stu-id="004f9-133">**Perform load leveling**.</span></span> <span data-ttu-id="004f9-134">アプリケーションではトラフィックの急増が起きることがあり、これがバックエンドのサービスに大きな負荷をかけることがあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-134">Applications may experience sudden spikes in traffic that can overwhelm services on the backend.</span></span> <span data-ttu-id="004f9-135">これを回避するには、[キュー ベースの負荷平準化パターン][load-level]を使用し、作業項目をキューに登録して非同期的に実行します。</span><span class="sxs-lookup"><span data-stu-id="004f9-135">To avoid this, use the [Queue-Based Load Leveling pattern][load-level] to queue work items to run asynchronously.</span></span> <span data-ttu-id="004f9-136">キューは、負荷のピークを平準化するバッファーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="004f9-136">The queue acts as a buffer that smooths out peaks in the load.</span></span>

<span data-ttu-id="004f9-137">**フェールオーバーする**。</span><span class="sxs-lookup"><span data-stu-id="004f9-137">**Fail over**.</span></span> <span data-ttu-id="004f9-138">インスタンスに到達できない場合は、別のインスタンスにフェールオーバーします。</span><span class="sxs-lookup"><span data-stu-id="004f9-138">If an instance can't be reached, fail over to another instance.</span></span> <span data-ttu-id="004f9-139">Web サーバーのようなステートレスなものについては、複数のインスタンスを、ロード バランサーまたはトラフィック マネージャーの背後に配置します。</span><span class="sxs-lookup"><span data-stu-id="004f9-139">For things that are stateless, like a web server, put several instances behind a load balancer or traffic manager.</span></span> <span data-ttu-id="004f9-140">データベースのように状態を保持するものについては、レプリカを使用してフェールオーバーします。</span><span class="sxs-lookup"><span data-stu-id="004f9-140">For things that store state, like a database, use replicas and fail over.</span></span> <span data-ttu-id="004f9-141">データ ストアとそのレプリケート方法によっては、最終的な整合性に対処するアプリケーションが必要なことがあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-141">Depending on the data store and how it replicates, this may require the application to deal with eventual consistency.</span></span>

<span data-ttu-id="004f9-142">**失敗したトランザクションを補正する**。</span><span class="sxs-lookup"><span data-stu-id="004f9-142">**Compensate failed transactions**.</span></span> <span data-ttu-id="004f9-143">一般的に、分散トランザクションは避けてください。サービスとリソースの間で調整が必要になるからです。</span><span class="sxs-lookup"><span data-stu-id="004f9-143">In general, avoid distributed transactions, as they require coordination across services and resources.</span></span> <span data-ttu-id="004f9-144">代わりに、より小さな個別のトランザクションで 1 つの操作を構成します。</span><span class="sxs-lookup"><span data-stu-id="004f9-144">Instead, compose an operation from smaller individual transactions.</span></span> <span data-ttu-id="004f9-145">操作が途中で失敗したら、[補正トランザクション][compensating-transactions]を使用して、既に完了している手順をすべて元に戻します。</span><span class="sxs-lookup"><span data-stu-id="004f9-145">If the operation fails midway through, use [Compensating Transactions][compensating-transactions] to undo any step that already completed.</span></span>

<span data-ttu-id="004f9-146">**実行時間の長いトランザクションにチェックポイントを設ける**。</span><span class="sxs-lookup"><span data-stu-id="004f9-146">**Checkpoint long-running transactions**.</span></span> <span data-ttu-id="004f9-147">実行時間の長い操作が失敗した場合には、チェックポイントで回復性を実現できます。</span><span class="sxs-lookup"><span data-stu-id="004f9-147">Checkpoints can provide resiliency if a long-running operation fails.</span></span> <span data-ttu-id="004f9-148">操作が再起動する (たとえば、別の VM で取得される) ときに、最後のチェックポイントから再開できます。</span><span class="sxs-lookup"><span data-stu-id="004f9-148">When the operation restarts (for example, it is picked up by another VM), it can be resumed from the last checkpoint.</span></span>

<span data-ttu-id="004f9-149">**潔く機能を減らす**。</span><span class="sxs-lookup"><span data-stu-id="004f9-149">**Degrade gracefully**.</span></span> <span data-ttu-id="004f9-150">ときには問題を処理できないこともありますが、制限された内容でもなお役立つような機能を提供することは可能です。</span><span class="sxs-lookup"><span data-stu-id="004f9-150">Sometimes you can't work around a problem, but you can provide reduced functionality that is still useful.</span></span> <span data-ttu-id="004f9-151">書籍のカタログを表示するアプリケーションを考えてみてください。</span><span class="sxs-lookup"><span data-stu-id="004f9-151">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="004f9-152">そのアプリケーションが表紙のサムネイル画像を取得できない場合は、プレース ホルダー イメージを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="004f9-152">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="004f9-153">サブシステム全体が、アプリケーションにとって重要でない場合もあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-153">Entire subsystems might be noncritical for the application.</span></span> <span data-ttu-id="004f9-154">たとえば電子商取引サイトでは、おすすめ製品の表示は、注文の処理よりもおそらく重要度が低いでしょう。</span><span class="sxs-lookup"><span data-stu-id="004f9-154">For example, in an e-commerce site, showing product recommendations is probably less critical than processing orders.</span></span>

<span data-ttu-id="004f9-155">**クライアントを制限する**。</span><span class="sxs-lookup"><span data-stu-id="004f9-155">**Throttle clients**.</span></span> <span data-ttu-id="004f9-156">少数のユーザーによって過度の負荷が発生することがありますが、これにより他のユーザーに対するアプリケーションの可用性が低下することがあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-156">Sometimes a small number of users create excessive load, which can reduce your application's availability for other users.</span></span> <span data-ttu-id="004f9-157">このような状況では、一定の時間、そのクライアントを制限します。</span><span class="sxs-lookup"><span data-stu-id="004f9-157">In this situation, throttle the client for a certain period of time.</span></span> <span data-ttu-id="004f9-158">「[調整パターン][throttle]」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="004f9-158">See the [Throttling pattern][throttle].</span></span>

<span data-ttu-id="004f9-159">**問題のあるユーザーをブロックする**。</span><span class="sxs-lookup"><span data-stu-id="004f9-159">**Block bad actors**.</span></span> <span data-ttu-id="004f9-160">クライアントを制限するからと言って、そのクライアントが悪意を持って操作していたことにはなりません。</span><span class="sxs-lookup"><span data-stu-id="004f9-160">Just because you throttle a client, it doesn't mean client was acting maliciously.</span></span> <span data-ttu-id="004f9-161">そのクライアントがサービスのクォータを超えたというだけです。</span><span class="sxs-lookup"><span data-stu-id="004f9-161">It just means the client exceeded their service quota.</span></span> <span data-ttu-id="004f9-162">しかしクライアントが一貫してクォータを超えるまたは不適切な動作をする場合は、それをブロックすることもあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-162">But if a client consistently exceeds their quota or otherwise behaves badly, you might block them.</span></span> <span data-ttu-id="004f9-163">ユーザーがブロック解除を要求できるように、定型外のプロセスを定義しておきます。</span><span class="sxs-lookup"><span data-stu-id="004f9-163">Define an out-of-band process for user to request getting unblocked.</span></span>

<span data-ttu-id="004f9-164">**リーダー選択を使用する**。</span><span class="sxs-lookup"><span data-stu-id="004f9-164">**Use leader election**.</span></span> <span data-ttu-id="004f9-165">タスクを調整する必要がある場合には、[リーダー選択][leader-election]を使用してコーディネーターを選択します。</span><span class="sxs-lookup"><span data-stu-id="004f9-165">When you need to coordinate a task, use [Leader Election][leader-election] to select a coordinator.</span></span> <span data-ttu-id="004f9-166">そうすると、コーディネーターは単一障害点ではありません。</span><span class="sxs-lookup"><span data-stu-id="004f9-166">That way, the coordinator is not a single point of failure.</span></span> <span data-ttu-id="004f9-167">コーディネーターが失敗すると、新しいコーディネーターが選択されます。</span><span class="sxs-lookup"><span data-stu-id="004f9-167">If the coordinator fails, a new one is selected.</span></span> <span data-ttu-id="004f9-168">最初からリーダー選択アルゴリズムを実装するよりも、Zookeeper などの既製のソリューションを検討してください。</span><span class="sxs-lookup"><span data-stu-id="004f9-168">Rather than implement a leader election algorithm from scratch, consider an off-the-shelf solution such as Zookeeper.</span></span>

<span data-ttu-id="004f9-169">**フォールト挿入でテストする**。</span><span class="sxs-lookup"><span data-stu-id="004f9-169">**Test with fault injection**.</span></span> <span data-ttu-id="004f9-170">ほとんどの場合、成功のパスは十分にテストされますが、障害のパスはそうではありません。</span><span class="sxs-lookup"><span data-stu-id="004f9-170">All too often, the success path is well tested but not the failure path.</span></span> <span data-ttu-id="004f9-171">システムが実稼働環境で長期間にわたり実行されてから初めて、障害のパスが実行されることもあります。</span><span class="sxs-lookup"><span data-stu-id="004f9-171">A system could run in production for a long time before a failure path is exercised.</span></span> <span data-ttu-id="004f9-172">フォールト挿入を使用して、実際のエラーをトリガーするまたはシミュレートすることによって、システムの障害への回復性をテストすることができます。</span><span class="sxs-lookup"><span data-stu-id="004f9-172">Use fault injection to test the resiliency of the system to failures, either by triggering actual failures or by simulating them.</span></span>

<span data-ttu-id="004f9-173">**Chaos エンジニアリングを利用する**。</span><span class="sxs-lookup"><span data-stu-id="004f9-173">**Embrace chaos engineering**.</span></span> <span data-ttu-id="004f9-174">Chaos エンジニアリングは、実稼働インスタンスに障害や異常な状態をランダムに挿入することで、フォールト挿入の概念を拡張するものです。</span><span class="sxs-lookup"><span data-stu-id="004f9-174">Chaos engineering extends the notion of fault injection, by randomly injecting failures or abnormal conditions into production instances.</span></span>

<span data-ttu-id="004f9-175">アプリケーションを自己復旧させるための構造化されたアプローチについては、[信頼性の高い Azure 用アプリケーションの設計][resiliency-overview]に関するページをご覧ください。</span><span class="sxs-lookup"><span data-stu-id="004f9-175">For a structured approach to making your applications self healing, see [Design reliable applications for Azure][resiliency-overview].</span></span>

<!-- links -->

[circuit-breaker]: ../../patterns/circuit-breaker.md
[compensating-transactions]: ../../patterns/compensating-transaction.md
[leader-election]: ../../patterns/leader-election.md
[load-level]: ../../patterns/queue-based-load-leveling.md
[resiliency-overview]: ../../reliability/index.md
[retry]: ../../patterns/retry.md
[throttle]: ../../patterns/throttling.md
[transient-fault-handling]: ../../best-practices/transient-faults.md
